How does Python stack up?
=========================

:date: 2005-10-07 03:34
:tags: building skills books,python features
:slug: 2005_10_07-how_does_python_stack_up
:category: Books
:status: published





`PJHyett <http://pjhyett.com/articles/2005/10/06/why-hasnt-anything-changed-since-the-50s>`_ asks



Why is it that selling points of
newer langauges are features that Lisp had decades ago? Java has garbage
collection, Ruby has closures, Perl is dynamically typed, etc. What the hell
have we been doing this whole time besides reinventing the
wheel?



Call me lazy, but I want my
language to do as much of the work as possible. So I pose this question, not to
start a religious war, but aren't languages that allow the programmer to solve
problems with less, but not cryptic, code
better?



In  `Marginalia <http://adamconnor.org/?p=38>`_ there
are some answers.



Techno-Detail by
Techno-Detail, (garbage collection, closures, dynamic typing, better code,
language does more) Python seems to fit the bill.  It has this ugliness about
the
*self* 
variable, but I'm willing to put up with
that.



From PJHyett "I'm a computer
scientist, and I never want to see another pointer
again."



I echo that.  I find the C/C++
stuff tedious, and I find some of the conversations deeply
strange.



"We support VB, C/C++, People
Talk and (I'm drawing a blank)" the client says, with a straight face.  I want
to say "and that's not diluting your talent pool?"  But that's not the right
thing to quibble over.  They have other problems.  Apparently stemming from the
fact that they support a variety of platforms and languages.  Which stems from
them doing extensive customization on every package they
buy.



Perhaps they
*could* 
stop looking at pointers if they would stop engaging in their hobby of
programming.  Perhaps much of the debate on good vs. bad vs. usable vs. antique
programming language stems from a certain amount of hobby programming justified
as necessary to making the software fit the
business.



Perhaps if we had less
programming, but a more serious attempt to maximize the value from that
programming, we'd have fewer languages, fewer bugs, less maintenance and
support.








