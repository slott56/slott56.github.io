Ancient Software and A Small Value of "Works"
=============================================

:date: 2017-05-30 08:00
:tags: Design Principles,architecture
:slug: 2017_05_30-ancient_software_and_a_small_value_of_works
:category: Technologies
:status: published

Tweet:

    Blaming people for using ancient software is really weird.
    There’s no other context where we demand constant replacement
    of things that work

    — Pinboard (@Pinboard) `May 12, 2017 <https://twitter.com/Pinboard/status/863127228531519489>`__

I'm not sold about this argument at all.

The "constant replacement" issue has two sides to it. If you follow
the thread, there's a certain amount of (appropriate) bashing of the
acquisitiveness that -- when exploited ruthlessly -- is a damning
indictment of capitalism. There's a lot of value in recognizing the
core capitalistic "buy more stuff" part of this.

But there's more.

One problem with this tweet is the threshold for "things that work."
Consumer software tends to be rather complex. It's often fat with
features. If the feature you use aren't obviously broken, then you
can say the software "works." But it's heavily qualified. Your
interesting feature set may be rather small when compared to the
whole.

Also, the technology stack tends to be quite tall. Your consumer
software sits on top of a consumer OS and consumer-friendly
libraries. All of which have to "work" to claim that your software
"works."

As with the app, you're only using a subset of OS and runtime library
features. This wraps the threshold for "works" in more and more
layers of qualification. Smaller and smaller percentages of the code
are involved in "works."

I'd suggest there's no other context where things are quite so
complex and interdependent as software. The narrow feature set that
appears to "work" may be adjacent to numerous security flaws and bugs
and unintended consequences. The constant replacement may be
necessary bug fixes.

There's more.

Part of the "constant replacement" situation stems from the cost and
complexity of innovation. I think that some companies have a
`rentier <https://en.wikipedia.org/wiki/Rentier_capitalism>`__
mind-set. Once the software is written, they hope to derive ongoing
revenue from the software. This doesn't happen because other
companies innovate, the product becomes obsolete. So they scramble
around trying to make money without doing too much real work.

There are three scenarios where ancient software gets replaced:

-   A new version include bug fixes. See above; the previous version
    didn't really "work" for large values of work. Blame for using
    ancient software is deserved. Keeping the old security flaws is
    not a virtue.

-   A new version is incremental feature creep. This is (potentially)
    rampant capitalism. Add a little something and sell the product as
    "new and improved." Keeping the old software because the new
    features aren't helpful makes sense.

-   Some businesses have a rentier mind-set. They want an ongoing
    revenue stream. There aren't any material improvements. Keep the
    old software. Make these people do real work.

Traditional manufacturing business models rely on things wearing out.
In the world of atoms, things need to be replaced. A good product has
a long future because of parts. And Service. Possibly even
customization. I lived on a sailboat made in 1982. I've been
carefully rebuilding and replacing pieces all over the boat.

A software "platform" (e.g. OS, database, etc.) can have good
long-term value. A software product, however, lives in a
hyper-competitive marketplace where improvements appear constantly.
The lazy route of non-innovative upgrades is tempting.

I think that there is a place to blame people for having too low a
threshold for "works."





