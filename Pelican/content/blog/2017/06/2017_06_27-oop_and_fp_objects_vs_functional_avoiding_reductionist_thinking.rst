OOP and FP -- Objects vs. Functional  -- Avoiding reductionist thinking
=======================================================================

:date: 2017-06-27 08:00
:tags: object-oriented programming,#python,functional programming
:slug: 2017_06_27-oop_and_fp_objects_vs_functional_avoiding_reductionist_thinking
:category: Technologies
:status: published

Real Quote (lightly edited to remove tangential nonsense.)

   Recently, I watched a video and it stated that OO is about nouns and
   Functional programming is about the verbs. Also, ... Aspect-Oriented
   Programming with the e Verification Language  by David Robinson

   It would be nice to have a blog post which summarized the various
   mindset associated w/ the various paradigms.


Sigh.


I find the word "mindset" to be challenging.


Yes. All Turing Complete programming languages do have a kind of
fundamental equivalence at the level of computing stuff represented
as numbers. This, however, seems reductionist.

["All languages were one language to him. All languages were
'woddly'." Paraphrased from James Thurber's "The Great Quillow", a
must-read.]


So. Beyond the core Turing Completeness features of a language, the
rest is reduced to a difference in "mindset"? The only difference is
how we pronounce "Woddly?"


"Mindset" feels reductionist. It replaces a useful summary of
language features with a dismissive "mindset" categorization of
languages. In a way, this seems to result from bracketing technology
choices as "religious wars," where the passion for a particular
choice outweighs the actual relevance; i.e., "All languages have
problems, so use Java."


In my day job, I work with three kinds of Python problems:


-  Data Science
-  API Services
-  DevOps/TechOps Automation


In many cases, one person can have all three problems. These aren't
groups of people. These are problem domains.

I think the first step is to replace "mindset" with "problem domain".
It's a start, but I'm not sure it's that simple.

When someone has a data science problem, they often solve it with
purely function features of Python. Generally they do this via numpy,
but I've been providing examples of generator expressions and
comprehensions in my Code Dojo webinars. Generator expressions are an
elegant, functional approach to working with stateless data objects.


In Python 3, the following kind of code doesn't create gigantic
intermediate data structures. The functional transformations are
applied to each item generated by the "source".

::

   x = map(transform, source)
   y = filter(selector_rule, x)
   z = Counter(y)



I prefer to suggest that a fair amount of data analysis involves
little or no mutation of state. Functional features of a language
seem to work well with immutable data.

There is state change, but it's at a macro level. For example, the
persistence of capturing data is a large-scale state change that's
often implemented at the OS level, not the language level.

When someone's building an API, on the other hand, they're often
working with objects that have a mutating state. Some elements of an
API will involve state change, and objects model state change
elegantly. RESTful API's can deserialize objects from storage, make
changes, and serialize the modified object again.

[This summary of RESTful services is also reductionist, and
therefore, possibly unhelpful.]

When there's mutability, then objects might be more appropriate than
functions.

I'm reluctant to call this "mindset." It may not be "problem domain."
It seems to be a model that involves mutable or immutable state.

When someone's automating their processing, they're wrestling with OS
features, and OS management of state change. They might be installing
stuff, or building Docker images, or gluing together items in a CI/CD
pipeline, setting the SSL keys, or figuring out how to capture Behave
output as part of Gherkin acceptance testing. Lots of interesting
stuff that isn't the *essential* problem at hand, but is part of
building a useful, automated solution to the problem.

The state in these problems is maintained by the OS. Application code
may -- or may not -- try to model that state.

When doing Blue/Green deployments, for example, the blueness and
greenness isn't part of the server farm, it's part of an internal
model of how the servers are being used. This seems to be stateful;
object-oriented programming might be helpful. When the information
can be gleaned from asset management tools, then perhaps a functional
processing stream is more important for gathering, deciding, and
taking action.

I'm leaning toward the second view-point, and suggesting that some of
the OO DevOps programming might be better looked at as functional
map-filter-reduce processing. Something like

::

      action_to_take = some_decision_pipeline(current state, new_deployment)

This reflects the questions of state change. It may not be the right
abstraction though, because carrying out the action is, itself, a
difficult problem that involves determining the state of the server
farm, and then applying some change to one or more servers.

We often think of server state change as imperative in nature. It
feels like object-oriented programming. There are steps, the object
models those steps. I'm not sure that's right. I think there's a
repeated "determine next action" cycle here. Sometimes it involves
waiting for an action to finish. Yes, it sounds like polling the
server farm. I'm not sure that's wrong. How else do you know a server
is crashed except by polling it?

I think we've moved a long way from "mindset."

I think it's about fitting language features to a problem in a way
that creates the right abstraction to capture (and eventually) solve
the problem.

I haven't mentioned Aspect-Oriented Programming because it seems to
cut across the functional/object state management boundary. It's a
distinctive approach to organizing reusable functionality. I don't
mean to dismiss it as uninteresting. I mean to set it aside as
orthogonal to the "mutable state" consideration that seems to to be
one of the central differences between OOP and FP.

In response to the request: "No. I won't map mindset to paradigm."





