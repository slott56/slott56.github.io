Legacy Preservation and "Code Modernization"
============================================

:date: 2013-05-30 08:00
:tags: preservation,test-driven reverse engineering,modernization
:slug: 2013_05_30-legacy_preservation_and_code_modernization
:category: Technologies
:status: published

| The correct marketing term is "Code Modernization".
| There are a large number of companies in the Code Modernization
  business.
| They appear to offer *automated* "modernization" of code.
| I would suggest going slowly toward automated modernization. I'm not
  easily convinced that any automated tool can preserve what's
  meaningful and ignore the parts which are quirks, bugs or legacy cruft
  that needs to be disposed of.
| Indeed, I'm rather sure that an automated modernization will actually
  be deleterious.
| Without some care, cruft from the legacy code could be canonized into
  an incomprehensible "feature" in the modern implementation. This will
  eventually become it's own weird legacy quirk.
| It's often best to rethink and rewrite the essential parts of the
  legacy. Why?
| Rule One: **Writing Software is Capturing Knowledge**.
| Consequence: **Converting Software is Preserving Knowledge**.
| Knowledge is something that **people** use. As with modern Agile
  software development, we need to focus on the connections among
  people. We need to use code as part of the channels of communication.
| Read the Agile
  Manifesto: `http://agilemanifesto.org <http://agilemanifesto.org/>`__
| There are four principles:

-  Individuals and interactions over processes and tools
-  Working software over comprehensive documentation
-  Customer collaboration over contract negotiation
-  Responding to change over following a plan

| 
| A detailed investigation into the use cases of legacy software, the
  unique knowledge encoded, and the quirks and cruft requires thinking
  about who uses the software and what they expect.
| Working software (i.e., readable code) is central. An automated
  modernization that doesn't properly handle quirks and cruft may create
  "working" software in the sense that it compiles. But software that
  people can't read and understand doesn't "work" in the more global
  sense of encoding captured knowledge.
| Collaboration is defeated by **automated** modernization. The users
  may have features they don't like or additional features they need.
  Doing the functionality improvements side-by-side with code
  modernization makes the most sense. Indeed, it often leads to a proper
  rewrite, which is the best strategy.
| It's difficult for users to envision new software that corrects
  long-standing quirks. When an Agile process makes software available
  incrementally (e.g., the release cycle of Scrum), then the users learn
  what they **should** have requested. An automated modernization cannot
  easily respond to the way that users learn through each release.



-----

your post is a good and your information easily un...
-----------------------------------------------------

olive<noreply@blogger.com>

2019-04-04 05:41:04.683000-04:00

your post is a good and your information easily understand every person
but you not mention that how to install this software if you want to
check the best rewrite and you want to `Save your time and energy by
using Article
Rewriter <https://thinkcomputers.org/save-your-time-and-energy-by-using-article-rewriter/>`__
then check my website
Thanks!





