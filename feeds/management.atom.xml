<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>S.Lott -- Software Architect - Management</title><link href="https://slott56.github.io/" rel="alternate"></link><link href="/feeds/management.atom.xml" rel="self"></link><id>https://slott56.github.io/</id><updated>2024-02-06T08:01:00-05:00</updated><entry><title>Rewrites are NOT hazardous</title><link href="https://slott56.github.io/2024-02-06-rewrites_are_not_hazardous.html" rel="alternate"></link><published>2024-02-06T08:01:00-05:00</published><updated>2024-02-06T08:01:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2024-02-06:/2024-02-06-rewrites_are_not_hazardous.html</id><summary type="html">&lt;p&gt;First, read this: &lt;a class="reference external" href="https://www.industriallogic.com/blog/rewrites-hazardous/"&gt;Hazards And Safeguards for Software Rewrites&lt;/a&gt;.
This is an infuriating article. The first part is nonsense. I wonder if it's intended to be read ironically?
Maybe it's a list of bad ideas?
Skip straight to the &lt;strong&gt;Safeguards for Rewrites&lt;/strong&gt; section. It's really good.&lt;/p&gt;
&lt;p&gt;Also, this &lt;a class="reference external" href="https://www.industriallogic.com/blog/characterization-testing-in-nuclear-power-and-software/"&gt;Characterization Testing …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;First, read this: &lt;a class="reference external" href="https://www.industriallogic.com/blog/rewrites-hazardous/"&gt;Hazards And Safeguards for Software Rewrites&lt;/a&gt;.
This is an infuriating article. The first part is nonsense. I wonder if it's intended to be read ironically?
Maybe it's a list of bad ideas?
Skip straight to the &lt;strong&gt;Safeguards for Rewrites&lt;/strong&gt; section. It's really good.&lt;/p&gt;
&lt;p&gt;Also, this &lt;a class="reference external" href="https://www.industriallogic.com/blog/characterization-testing-in-nuclear-power-and-software/"&gt;Characterization Testing in Nuclear Power and Software&lt;/a&gt;.
This is really good. I used to call it &amp;quot;Test-Driven Reverse Engineering.&amp;quot; It's how you manage a rewrite.
Can endorse as a risk mitigation strategy for everyone who has legacy code.&lt;/p&gt;
&lt;div class="section" id="bluf"&gt;
&lt;h2&gt;BLUF&lt;/h2&gt;
&lt;p&gt;Rewrites are not hazardous. Ignore the &amp;quot;hazards&amp;quot; part of the article.
This part is infuriatingly full of talking points that make precious little sense.&lt;/p&gt;
&lt;p&gt;It's &lt;strong&gt;managing&lt;/strong&gt; the rewrite that can become hazardous when managers utterly fail to acknowledge the accrued costs and risks of legacy software.&lt;/p&gt;
&lt;p&gt;Ignore the first part of the article. Skip to the &lt;strong&gt;Safeguards for Rewrites&lt;/strong&gt; section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hazards-really"&gt;
&lt;h2&gt;Hazards? Really?&lt;/h2&gt;
&lt;p&gt;The article leads with four issues.
It's not clear if this is intended as a list of bad arguments against a rewrite or simply ironically wrong statements.&lt;/p&gt;
&lt;p&gt;It says &amp;quot;Here are typical issues you’ll encounter:&amp;quot; as if these are real hazards.
I think these are nonsense things commonly stated as arguments to avoid or prevent a rewrite.
I think -- maybe -- these are issues people raise to avoid talking rationally about a rewrite.&lt;/p&gt;
&lt;p&gt;This is what's infuriating about the article. The second half is really good. The first half is hard to interpret.&lt;/p&gt;
&lt;p&gt;My working concept is the first half is &amp;quot;farcical hazard statements&amp;quot; not real hazards.&lt;/p&gt;
&lt;p&gt;If I read these are specious, bad rationale for &lt;strong&gt;Business as Usual&lt;/strong&gt; and &lt;strong&gt;Keep The Lights On&lt;/strong&gt;, then,
it makes a little sense.
I've added refutations here, because the original article doesn't directly refute them, it just states them as if they're real hazards.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;100% feature matching is difficult.&amp;quot; It's actually quite easy. Read the companion piece. Skip to the &lt;strong&gt;Safegaurds&lt;/strong&gt; section.
It's also undesirable. As noted later in the article, this should never have been a goal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;You risk building the new system as poorly as the old system.&amp;quot; This is only true if you have the same inept management and insane budgeting as the original.
You'd also need to have the same language, frameworks, and lack of knowledge.&lt;/p&gt;
&lt;p&gt;Let me emphasize this last point: &lt;strong&gt;lack of knowledge.&lt;/strong&gt;  The team writing the legacy code was feeling their way along in the
dark. That's emphatically no longer true. The legacy system lights the path.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;It’s easy to underestimate the effort.&amp;quot; This is always true. It's particularly true when management ignores
the dollars poured into maintenance and support. More than once, I've been told that some 10-year-old spaghetti-bowl
of legacy code was written by 4 people in 13 weeks. Somehow, the ensuing 10 years vanished.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;Tension may build between the rewrite team and the support team.&amp;quot;
I don't see much refutation, perhaps another article?
I've encountered this, and seen people resign rather than be involved in replacing code they've spent their entire career maintaining.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's go on. There's more to the hazards section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-hazards"&gt;
&lt;h2&gt;More Hazards&lt;/h2&gt;
&lt;p&gt;Again, the following hazards are mostly bunk. Let's assume they're actually bad arguments against a rewrite.
The article doesn't refute these in detail, instead it skips on to the &lt;strong&gt;Safeguards for Rewrites&lt;/strong&gt; section.
I feel the need to refute them in detail.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;If you miss an oft–used feature, you’ll injure your users.&amp;quot; Right. And? What if the legacy software lacks features?
The decision to invest in risky, buggy legacy code vs. a rewrite is nothing more than accepting high levels of risk.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;Ensuring you have duplicated all the features...&amp;quot; was never a goal.  Some legacy features are trash.
One of the reasons for a rewrite is to purge obsolete junk code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;No matter how difficult refactoring may appear, rewriting will be worse.&amp;quot; False. They're the same thing.
A rewrite &lt;strong&gt;is&lt;/strong&gt; refactoring. It's refactoring with fewer constraints. It's still bound by the lessons learned
creating the original software.  Remember. The &lt;strong&gt;knowledge&lt;/strong&gt; gained means a rewrite has a solid footing for designing software.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;I’ve seen over and over again, ..., developers copying and pasting code from the existing system...&amp;quot;
That's some poor management. What was the incentive that made this appealing to the developers?
Later, talking about a C++ to Java conversion, the author suggests the &amp;quot;code complete&amp;quot; was somehow a goal.
If so, that's bad management.&lt;/p&gt;
&lt;p&gt;Also. Most rewrites are not between two languages as similar as C++ and Java.
Rewriting COBOL to Python can't invoplve copy-and-paste.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;It is safest to estimate that the rewrite will take similar effort as the original.&amp;quot;
This doesn't make too much sense.
First, the original cost is both some original project &lt;strong&gt;plus&lt;/strong&gt; years and years of maintenance.
Further, the original project often had quite a bit of preliminary analytical work to refine the scope to something
that could be budgeted. This labor is almost &lt;strong&gt;never&lt;/strong&gt; accounted for.
The time users spent helping to understand user stories? Was that part of the development budget also?
The rewrite will be less than the total of development + maintenance.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;Any time saved during development will likely be lost to making sure the new system is feature complete.&amp;quot;
This doesn't make any sense at all. Development is development. It's all development until things are feature complete.
There's no &amp;quot;time saved&amp;quot; if it's not feature complete.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;The usual strategy is a big bang replacement...&amp;quot; Okay. So that's a bad idea.
The &lt;strong&gt;Safeguards for Rewrites&lt;/strong&gt; clearly serves to refute this.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This &amp;quot;Hazards&amp;quot; section is infuriating because the tone is opaque.&lt;/p&gt;
&lt;p&gt;Let's assume these are all bad arguments against a rewrite.
Let's call them &amp;quot;Farcical Non-Hazards&amp;quot; or &amp;quot;Things commonly cited as hazards&amp;quot; or something that clarifies
the tone.&lt;/p&gt;
&lt;p&gt;The next section is a &lt;strong&gt;much&lt;/strong&gt; more useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="safeguards-for-rewrites"&gt;
&lt;h2&gt;Safeguards for Rewrites&lt;/h2&gt;
&lt;p&gt;Instrumentation and collect usage statistics.&lt;/p&gt;
&lt;p&gt;A CI/CD pipeline to allow incremental delivery.&lt;/p&gt;
&lt;p&gt;Incremental conversion working down from the highest priority until the users stop demanding legacy features.&lt;/p&gt;
&lt;p&gt;This is good stuff.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Two of the three points in the summary are excellent.&lt;/p&gt;
&lt;p&gt;The first bugs me.&lt;/p&gt;
&lt;p&gt;&amp;quot;A complete rewrite of an existing application or system should be your last choice&amp;quot; is hardly worth repeating.
It's a simple cost-risk decision, and it's &lt;strong&gt;always&lt;/strong&gt; on the table.&lt;/p&gt;
&lt;p&gt;With extremely rich open-source ecosystems around languages like Python, the cost to rewrite
can be surprisingly low.&lt;/p&gt;
&lt;p&gt;A super-fancy &amp;quot;analytical app&amp;quot; in an old Visual Basic program may have been reduced to a tidy
Java Spring Boot application that did some flexible analytical computations.
This may reduce, yet again, to an extract and a Jupyter Notebook handed over to skilled users.
The volume of code went from thousands of lines of VB to hundreds of lines of Java to a data dictionary
and a training class.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="test-driven reverse engineering"></category><category term="refactoring"></category><category term="legacy-code"></category><category term="estimating"></category></entry><entry><title>Scrum, Agile, and Modern Tools</title><link href="https://slott56.github.io/2015_05_05-scrum_agile_and_modern_tools.html" rel="alternate"></link><published>2015-05-05T19:40:00-04:00</published><updated>2015-05-05T19:40:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2015-05-05:/2015_05_05-scrum_agile_and_modern_tools.html</id><summary type="html">&lt;p&gt;Required Reading: &lt;a class="reference external" href="https://www.pandastrike.com/posts/20150304-agile"&gt;https://www.pandastrike.com/posts/20150304-agile&lt;/a&gt;
My takeaway quote? &amp;quot;Scrum lags behind the modern toolchain enough that
there can be a Potemkin village vibe to the whole thing.&amp;quot;
I was clued into this from another takeaway quote someone seconded on
Twitter: &amp;quot;Waterfall used too much written communication, but …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Required Reading: &lt;a class="reference external" href="https://www.pandastrike.com/posts/20150304-agile"&gt;https://www.pandastrike.com/posts/20150304-agile&lt;/a&gt;
My takeaway quote? &amp;quot;Scrum lags behind the modern toolchain enough that
there can be a Potemkin village vibe to the whole thing.&amp;quot;
I was clued into this from another takeaway quote someone seconded on
Twitter: &amp;quot;Waterfall used too much written communication, but Agile
doesn't use enough.&amp;quot;
Also read this: &lt;a class="reference external" href="http://caines.ca/blog/2014/12/02/i-dont-miss-the-sprint/"&gt;http://caines.ca/blog/2014/12/02/i-dont-miss-the-sprint/&lt;/a&gt;
Is &amp;quot;sprint&amp;quot; misleading? What about &amp;quot;sprint commitment?&amp;quot;
I'm not sure I object to &amp;quot;sprint&amp;quot; &lt;em&gt;per se.&lt;/em&gt;
But I have seen &amp;quot;sprint commitment&amp;quot; turned into an organizational
problem, removing what could have been a helpful tool. Folks who start
harping on sprint commitments in the sense of &amp;quot;we committed to this,
will we meet the deadline?&amp;quot; tend to create a toxic environment. I think
the people who hype commitment the most really liked the non-Agile
environments: they try bend Agile to meet their Waterfall concepts.
The problem is the word. A &amp;quot;sprint commitment&amp;quot; shouldn't be used like a
legally binding &amp;quot;do it or pay penalties&amp;quot; commitment. It should be a
metric used to gauge progress. More like a &amp;quot;sprint outcome&amp;quot;.
The commitment hype can lead to stories, epics and detailed technical
tasks getting muddied up terribly. The story becomes an epic. Little
tiny technical tasks get inflated into big important stories. A proper
user story gets replaced with nonsense about prepping a database for
production rollout, or resolving defects found in QA, or things that --
obviously -- aren't &lt;strong&gt;user&lt;/strong&gt; stories, but are taking up a lot of time.
When it appears that a story is going nowhere, the scrum master breaks
it down into things that have status which changes frequently. The sense
of end-user meaning behind the actual story gets lost in a haze of
technical considerations and tasks that show activity more than
accomplishment more than value.
&amp;quot;As an actuary, I want to know that the developers have written
syntactically correct DML for my database, so that the product owner
don't have to wait as long for the DBA's to build the database.&amp;quot;
Really?&lt;/p&gt;
</content><category term="Management"></category><category term="waterfall"></category><category term="scrum"></category><category term="agile"></category></entry><entry><title>Agility and following a "Strictly Agile" approach</title><link href="https://slott56.github.io/2011_05_24-agility_and_following_a_strictly_agile_approach.html" rel="alternate"></link><published>2011-05-24T08:00:00-04:00</published><updated>2011-05-24T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2011-05-24:/2011_05_24-agility_and_following_a_strictly_agile_approach.html</id><summary type="html">&lt;p&gt;I've seen some discussion on Stack Overflow that is best characterized
by the question: &amp;quot;What is Strictly Agile?&amp;quot;, or &amp;quot;What's the Official
Agile Approach?&amp;quot;.&lt;/p&gt;
&lt;p&gt;Someone shared this with me recently: &amp;quot;&lt;a class="reference external" href="http://radar.oreilly.com/2011/05/process-kills-developer-passion.html"&gt;Process kills developer
passion&lt;/a&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;I have also heard some great complaints about organizations that
claim &amp;quot;Agile&amp;quot; and actually do nothing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've seen some discussion on Stack Overflow that is best characterized
by the question: &amp;quot;What is Strictly Agile?&amp;quot;, or &amp;quot;What's the Official
Agile Approach?&amp;quot;.&lt;/p&gt;
&lt;p&gt;Someone shared this with me recently: &amp;quot;&lt;a class="reference external" href="http://radar.oreilly.com/2011/05/process-kills-developer-passion.html"&gt;Process kills developer
passion&lt;/a&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;I have also heard some great complaints about organizations that
claim &amp;quot;Agile&amp;quot; and actually do nothing of the kind. In some cases it's
not a &amp;quot;crunchy agile shell&amp;quot; around a waterfall process; it's a simple
lie. Nothing about the process is Agile except a manager insisting
that all the status reporting, planning and unprioritized lists of
random requirements are Agile.&lt;/p&gt;
&lt;p&gt;Finally, I got this weird suggestion: &amp;quot;consider writing a blog about
how to test if you are agile or not&amp;quot;. It's weird because testing for
Agile is like testing for breathing; it's like testing for
flammability.&lt;/p&gt;
&lt;div class="section" id="the-agile-test"&gt;
&lt;h2&gt;The Agile Test&lt;/h2&gt;
&lt;p&gt;Testing if your project is Agile can be done two ways.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;Practical&lt;/strong&gt;. Make a change to the project. Any change.
Requirements, architecture, due dates, staff, &lt;em&gt;anything&lt;/em&gt;. Does it
derail? If so, it wasn't very Agile, was it?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Theoretical&lt;/strong&gt;. Reread the &lt;a class="reference external" href="http://agilemanifesto.org/"&gt;Agile
Manifesto&lt;/a&gt;. Make a score card that
evaluates the project on each of the eight basic criteria in the
Agile manifesto. Convene all the project stakeholders. Conduct
careful surveys and have structured walkthroughs to determine the
degree of Agility surrounding each person, deliverable,
collaborative relationship and issue.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An important point is that Agile is not absolute. Some practices
are more Agile than others. There's no &amp;quot;strictly&amp;quot; Agile. There are
ways to make a project more Agile; that is, it can effectively
cope with change. There are ways to make a project less Agile;
that is, change causes problems and can derail the project
completely.&lt;/p&gt;
&lt;p&gt;The canonical example is a missing, misstated or contradictory
requirement that gets uncovered after coding and during user
acceptance test. Clearly, that feature has been built and is
absolutely wrong. What happens next?&lt;/p&gt;
&lt;p&gt;Agile? The product can be released with with the broken feature
relegated to the next release. A hack is put in to remove the
buttons or menu items or links until they work.&lt;/p&gt;
&lt;p&gt;Not Agile? Everyone works around the clock to make that feature
work no matter what. Paraphrasing Admiral Farragut: &amp;quot;Technical
debt be damned. Development must proceedfull speed ahead.&amp;quot; All of
this irrespective of the relative value of what's being developed.
Schedule comes first; features second.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-much-process"&gt;
&lt;h2&gt;How Much Process?&lt;/h2&gt;
&lt;p&gt;The &amp;quot;Process Kills...&amp;quot; blog entry repeats observation that a lot of
carefully-defined process isn't really all that helpful. It
identifies a cause (&amp;quot;process kills passion&amp;quot;) that's can be true, but
it's largely irrelevant. Process is—essentially—work that's not
focused on delivering anything of real value. Complex processes are
&amp;quot;meta&amp;quot; work; it's work focused on IT internals; it's work that
creates no value for the users of the software; work that replaces
the more valuable elements of the Agile Manifesto.&lt;/p&gt;
&lt;p&gt;One can argue that processes, documentation, contracts and plans
&amp;quot;assure&amp;quot; success or demonstrate some level of quality. To an extent
all the process and meta-work creates trust that—eventually—the
resulting software product will solve the original problem.&lt;/p&gt;
&lt;p&gt;The mistake is that non-Agile methods use a series of
surrogates—processes, documentation, contracts and plans—instead of
actual software. The point of Agile methods it to release software
early and often and avoid using surrogates.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="key-points-of-agile"&gt;
&lt;h2&gt;Key Points of Agile&lt;/h2&gt;
&lt;p&gt;Here are the key points of the Agile Manifesto.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Individuals and interactions&lt;/strong&gt; over processes and tools. A more
Agile project will use the best people and encourage them to talk
amongst themselves. A less Agile project will write a lot of
things (which folks don't have time or reward for reading.) There
will be misunderstandings, leading to large, boring meetings where
someone reads powerpoint slides to other folks to try and clear up
misunderstandings.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Working software&lt;/strong&gt; over comprehensive documentation. A more
Agile project uses frequent release cycles of incremental
software. A less Agile project attempts to gather all
requirements, do all design and then try to do all the coding even
though the requirements have already been found to be less than
crystal clear.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Customer collaboration&lt;/strong&gt; over contract negotiation. A more Agile
project uses constant contact with customer and product owner to
refine and prioritize the requirements. A less Agile project uses
a complex change control process to notify everyone of a
requirements change, which leads to design and code changes, and
has cost and schedule impact that must be carefully planned and
documented.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Responding to change&lt;/strong&gt; over following a plan. A more Agile
project uses incremental releases, conversation and a modicum of
discipline to build things of value. Just because someone thought
it should be included in the requirements doesn't mean the feature
is really required.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="the-process-kills-passion-question"&gt;
&lt;h2&gt;The &amp;quot;Process Kills Passion?&amp;quot; Question&lt;/h2&gt;
&lt;p&gt;There Process Kills Passion blog lists a bunch of things that—it
appears—some folks find burdensome:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Doing full TDD, writing your tests before you wrote any implementing code.&lt;/li&gt;
&lt;li&gt;Requiring some arbitrary percentage of code coverage before check-in.&lt;/li&gt;
&lt;li&gt;Having full code reviews on all check-ins.&lt;/li&gt;
&lt;li&gt;Using tools like Coverity to generate code complexity numbers and requiring developers to refactor code that has too high a complexity rating.&lt;/li&gt;
&lt;li&gt;Generating headlines, stories and tasks.&lt;/li&gt;
&lt;li&gt;Grooming stories before each sprint.&lt;/li&gt;
&lt;li&gt;Sitting through planning sessions.&lt;/li&gt;
&lt;li&gt;Tracking your time to generate burn-down charts for management.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list has three different collections of practices.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Good&lt;/strong&gt;. TDD, code reviews, generating headlines, stories and
tasks, grooming stories before each sprint and doing some planning
for each sprint are all simply good ideas. They must be done.
&amp;quot;Pure Coding&amp;quot; is not a good way to invest time. Planning and then
coding is much smarter, no matter how boring planning appears.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Difficult&lt;/strong&gt;. Test code coverage can be helpful, but can also
devolve to empty numerosity. 20% more coverage doesn't not mean
20% fewer bugs. Nor does it mean 20% less chance of uncovering a
bug at run time. Code complexity ratings are also fussy because
they don't have a direct correlation with much. They &lt;strong&gt;must&lt;/strong&gt; be
done and used to prioritize work that will reduce technical debt.
But mindless thresholds are for cowards who don't want to mediate
deep technical discussions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Silly&lt;/strong&gt;. Creating burn-down charts for management shouldn't be
necessary. Everyone must read and understand the backlog. Everyone
should build the summary charts they want from the backlog. The
product owner or even the eventual customer should do this on
their own. They must be given a profound level of ownership of the
features and the process for creating software.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don't agree that process kills passion. I think there's a fine
line between playing with software development and building
software of value. I think that valuable software requires some
discipline and requires executing a few burdensome tasks (like
TDD) that create real value. Assuring 80% or 100% code coverage
doesn't always create real value. Spending time keeping the
backlog precise and complete is good; spending time making
pictures is less good.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="amazing"&gt;
&lt;h2&gt;amazing ....&lt;/h2&gt;
&lt;p&gt;Chris Shayan&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2011-05-26 13:21:57.130000-04:00&lt;/p&gt;
&lt;p&gt;amazing ....&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="software process improvement"></category><category term="waterfall"></category><category term="scrum"></category><category term="agile"></category></entry><entry><title>Open Source Business Opportunities</title><link href="https://slott56.github.io/2009_02_18-open_source_business_opportunities.html" rel="alternate"></link><published>2009-02-18T01:30:00-05:00</published><updated>2009-02-18T01:30:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2009-02-18:/2009_02_18-open_source_business_opportunities.html</id><summary type="html">&lt;p&gt;See the &lt;a class="reference external" href="http://www.cioinsight.com/c/a/IT-Management/10-Areas-Where-Open-Source-is-Open-for-Business/?kc=CIOMINEPNL01302009"&gt;10 Open Source Opportunities&lt;/a&gt;  entry in CIO Minute.&lt;/p&gt;
&lt;p&gt;The OS and Virtualization territory is already staked out.  Not sure this will be a real opportunity space.&lt;/p&gt;
&lt;p&gt;Enterprise applications (CRM, ERP, BI) are scary.  Scary because these are purchased by CIO's.  CIO's are herd animals and -- of course -- an …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See the &lt;a class="reference external" href="http://www.cioinsight.com/c/a/IT-Management/10-Areas-Where-Open-Source-is-Open-for-Business/?kc=CIOMINEPNL01302009"&gt;10 Open Source Opportunities&lt;/a&gt;  entry in CIO Minute.&lt;/p&gt;
&lt;p&gt;The OS and Virtualization territory is already staked out.  Not sure this will be a real opportunity space.&lt;/p&gt;
&lt;p&gt;Enterprise applications (CRM, ERP, BI) are scary.  Scary because these are purchased by CIO's.  CIO's are herd animals and -- of course -- an open source enterprise package will &lt;em&gt;never&lt;/em&gt;  be acceptable.&lt;/p&gt;
&lt;p&gt;Clearly, there's a lot of room to make money here by shoving SAP, Oracle and TriZetto Group aside.  I think that you can easy implement a simpler application than these legacy behemoths.&lt;/p&gt;
&lt;p&gt;Technology (Mobile, VOIP, Security) This has a lot of room for growth.  It's enabling or foundational technology.  Lots of space here.&lt;/p&gt;
&lt;p&gt;Tools and Browsers are totally crowded with freeware.  I'm not sure there's any money-making opportunity here.  ActiveState and WingWare are who you start competing against.  Then you've got to work against Oracle, IBM, the Eclipse Foundation, Sun's NetBeans.  Mozilla, Opera, etc.&lt;/p&gt;
</content><category term="Management"></category><category term="open-source"></category><category term="FOSS"></category></entry><entry><title>The Future of Windows -- And the Future WIthout WIndows</title><link href="https://slott56.github.io/2009_02_11-the_future_of_windows_and_the_future_without_windows.html" rel="alternate"></link><published>2009-02-11T02:49:00-05:00</published><updated>2009-02-11T02:49:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2009-02-11:/2009_02_11-the_future_of_windows_and_the_future_without_windows.html</id><summary type="html">&lt;p&gt;The disruption from Microsoft's failures are only starting to be felt.  Check out Frank Hayes' &amp;quot;&lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;taxonomyName=Management&amp;amp;articleId=332889"&gt;The Pain Begins&lt;/a&gt; &amp;quot; column in the January 26th Computer World.&lt;/p&gt;
&lt;p&gt;Corporate IT stubbed Vista.  What will it do with Windows 7?  And what's the fall-back plan if Windows 7 is bust and Microsoft does an …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The disruption from Microsoft's failures are only starting to be felt.  Check out Frank Hayes' &amp;quot;&lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;taxonomyName=Management&amp;amp;articleId=332889"&gt;The Pain Begins&lt;/a&gt; &amp;quot; column in the January 26th Computer World.&lt;/p&gt;
&lt;p&gt;Corporate IT stubbed Vista.  What will it do with Windows 7?  And what's the fall-back plan if Windows 7 is bust and Microsoft does an &amp;quot;end-of-life&amp;quot; in Windows XP to force upgrades and purchases?&lt;/p&gt;
&lt;p&gt;It won't be pretty.  Microsoft will start to lose even more ground.  And the open-source OS world will blossom into a dozen competing offerings with complex services, support, help-desk, SaaS add-ons.  It will be much more complex.&lt;/p&gt;
&lt;p&gt;It will be very disruptive to current ways of working.  With a single desktop OS, purchasing is easy.  Find a hardware vendor, pick a few items out of a catalog.  Buy the same OS for servers, and to claim to be an all-Microsoft shop.  People currently (with a straight face) claim they never use open source software (in spite of Apache, Java and Perl).&lt;/p&gt;
&lt;p&gt;When Windows is bust, what then?&lt;/p&gt;
&lt;p&gt;Every decision will require thinking.  That will hurt.&lt;/p&gt;
</content><category term="Management"></category><category term="windows"></category><category term="microsoft"></category></entry><entry><title>I didn't get the memo -- apparently, I'm not on the distribution list -- in fact, there may be no list</title><link href="https://slott56.github.io/2008_09_09-i_didnt_get_the_memo_apparently_im_not_on_the_distribution_list_in_fact_there_may_be_no_list.html" rel="alternate"></link><published>2008-09-09T09:50:00-04:00</published><updated>2008-09-09T09:50:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-09-09:/2008_09_09-i_didnt_get_the_memo_apparently_im_not_on_the_distribution_list_in_fact_there_may_be_no_list.html</id><summary type="html">&lt;p&gt;Recently, I started on an architecture for which &lt;a class="reference external" href="http://www.fastcgi.com/"&gt;Fast CGI&lt;/a&gt;  seemed like a good idea.  But then, I couldn't find a pre-built &lt;a class="reference external" href="http://fedoraproject.org/wiki/Tools/yum"&gt;YUM&lt;/a&gt;  distro for &lt;a class="reference external" href="http://fedoraproject.org/"&gt;Fedora Core 9&lt;/a&gt; .  Further, I couldn't really build my own, because I couldn't find the FC9 version of /usr/local/apache2.&lt;/p&gt;
&lt;p&gt;Stuff moved.  And no …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently, I started on an architecture for which &lt;a class="reference external" href="http://www.fastcgi.com/"&gt;Fast CGI&lt;/a&gt;  seemed like a good idea.  But then, I couldn't find a pre-built &lt;a class="reference external" href="http://fedoraproject.org/wiki/Tools/yum"&gt;YUM&lt;/a&gt;  distro for &lt;a class="reference external" href="http://fedoraproject.org/"&gt;Fedora Core 9&lt;/a&gt; .  Further, I couldn't really build my own, because I couldn't find the FC9 version of /usr/local/apache2.&lt;/p&gt;
&lt;p&gt;Stuff moved.  And no one told me.&lt;/p&gt;
&lt;div class="section" id="long-anecdote"&gt;
&lt;h2&gt;Long Anecdote&lt;/h2&gt;
&lt;p&gt;Years ago, I worked with someone who had either a knowledge management or a file system issue.  It wasn't clear.  They had a problem organizing information.  They couldn't -- somehow -- make the windows filesystem work and needed a new paradigm, something that would blow the classic hierarchical file system away.&lt;/p&gt;
&lt;p&gt;Seriously.  They said that.&lt;/p&gt;
&lt;p&gt;I tried to elicit use cases.  Nothing came of that.  Eventually, they sent me the example that had frustrated them.&lt;/p&gt;
&lt;p&gt;They were creating each paragraph as a separate file in a &lt;strong&gt;massive&lt;/strong&gt;  hierarchy.  The hierarchy was so deeply nested that they had reached the maximum path length and weren't through putting sub-(sub-)x9-sub levels in.&lt;/p&gt;
&lt;p&gt;There is lots of craziness here; and more that I haven't mentioned.  MS-Word has an outlining mode.  They were shocked that such a thing existed.  Shocked.  But it was &lt;strong&gt;Completely Useless&lt;/strong&gt;  -- it didn't allow more than 8 levels of indenting.&lt;/p&gt;
&lt;p&gt;There are lots of outline editors, Wikipedia calls them &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Outliner"&gt;Outliners&lt;/a&gt; .  I used &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;Leo&lt;/a&gt;  for a long time.  I use &lt;a class="reference external" href="http://www.xmlmind.com/xmleditor/"&gt;XXE&lt;/a&gt;  for really big projects like my &lt;a class="reference external" href="http://www.itmaybeahack.com/homepage/books/index.html"&gt;books&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;This person did not know that the &amp;quot;outliner&amp;quot; software category existed and was amazed that no one told them.&lt;/p&gt;
&lt;p&gt;It gets worse.  In the process of trying to elicit use cases, we had to spend 100 emails discussing -- essentially -- &amp;quot;hierarchy&amp;quot;.  Seriously.  The whole hierarchy == directed acyclic graph == simple node with list of subnodes was beyond their comprehension.  The idea that this trivial data structure could do so much was baffling.  Further, the fact that this data structure is recursive and doesn't map to SQL very well was also baffling.&lt;/p&gt;
&lt;p&gt;They were amazed that this was well-understood undergrad computer science.  It didn't require a dozen use cases and two dozen pages of detailed hand-wringing object design.  No one told them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="end-long-anecdote"&gt;
&lt;h2&gt;End Long Anecdote&lt;/h2&gt;
&lt;p&gt;I spent hours researching Apache2 and fastcgi on FC9.  Hours.  I found useful stuff, like &lt;a class="reference external" href="http://hacktux.com/compile/apache/fedora"&gt;Compile Apache on Fedora&lt;/a&gt; .  I was getting close to downloading source and beginning from scratch.&lt;/p&gt;
&lt;p&gt;Then, the following thought slowly began to trickle into my head.&lt;/p&gt;
&lt;blockquote&gt;
&lt;strong&gt;&amp;quot;If it's too hard, you're doing it wrong.&amp;quot;&lt;/strong&gt;&lt;/blockquote&gt;
&lt;p&gt;So, I went back to the basic FC9 software updater and did the search again.  What I gleaned from the listing this time was that they provide a pre-built &lt;a class="reference external" href="http://fastcgi.coremail.cn/"&gt;fcgid&lt;/a&gt;  instead of &lt;a class="reference external" href="http://www.fastcgi.com/"&gt;fastCGI&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Do I actually care?  If fcgid is binary-compatible with only a small algorithm change, I don't really care, do I?&lt;/p&gt;
&lt;p&gt;For a few minutes, I searched around to see if I could find any &amp;quot;notification&amp;quot; or &amp;quot;change log&amp;quot; for Fedora that indicated that mod_fastcgi was out and mod_fcgid was in.  Then I realized that it was fruitless.  There often aren't Big Announcements.  And even if there are, it may not be sensible to try and be a member of every open source project in my technology stack.&lt;/p&gt;
&lt;p&gt;The source is available.  There are always two choices.  (1) Keep all the legacy source and rebuild the legacy technology stack.  (2) Find the path of least resistance and do upgrades on a regular basis.&lt;/p&gt;
&lt;p&gt;It's the &amp;quot;find the path of least resistance&amp;quot; that's hard.  I was so focused on FastCGI that I almost forgot to look around and see what -- if any -- alternatives would meet my objectives.  The point is not a specific technology.  We can't stand around waving the hammer forcing all fasteners to be used like nails.  The point is to solve the problem.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="content"></category><category term="discovery"></category><category term="architecture"></category></entry><entry><title>Universal Truths</title><link href="https://slott56.github.io/2008_08_22-universal_truths.html" rel="alternate"></link><published>2008-08-22T00:29:00-04:00</published><updated>2008-08-22T00:29:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-08-22:/2008_08_22-universal_truths.html</id><summary type="html">&lt;p&gt;First, a standard &lt;a class="reference external" href="http://weblogs.sqlteam.com/mladenp/archive/2008/08/12/Software-Development-Cycle-truism.aspx"&gt;software development life cycle&lt;/a&gt; .  Simply multiply by your team's billable rate.&lt;/p&gt;
&lt;p&gt;Here's &lt;a class="reference external" href="http://www.urbaczewski.com/humor/softdevcycle.htm"&gt;another version&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Also, see &lt;a class="reference external" href="http://murali.weblogs.us/images/software_development1.jpg"&gt;Software Development&lt;/a&gt;  illustration.&lt;/p&gt;
&lt;p&gt;This lead me to &lt;a class="reference external" href="http://www.visitor-tracking.com/pm-jokes.php"&gt;Project Management&lt;/a&gt; .  Also pretty-well universally true.  Except -- of course -- the page has a bunch of odd bugs like a repeated joke and damaged HTML …&lt;/p&gt;</summary><content type="html">&lt;p&gt;First, a standard &lt;a class="reference external" href="http://weblogs.sqlteam.com/mladenp/archive/2008/08/12/Software-Development-Cycle-truism.aspx"&gt;software development life cycle&lt;/a&gt; .  Simply multiply by your team's billable rate.&lt;/p&gt;
&lt;p&gt;Here's &lt;a class="reference external" href="http://www.urbaczewski.com/humor/softdevcycle.htm"&gt;another version&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Also, see &lt;a class="reference external" href="http://murali.weblogs.us/images/software_development1.jpg"&gt;Software Development&lt;/a&gt;  illustration.&lt;/p&gt;
&lt;p&gt;This lead me to &lt;a class="reference external" href="http://www.visitor-tracking.com/pm-jokes.php"&gt;Project Management&lt;/a&gt; .  Also pretty-well universally true.  Except -- of course -- the page has a bunch of odd bugs like a repeated joke and damaged HTML.  How can you complain about project management without introducing quality issues?&lt;/p&gt;
</content><category term="Management"></category><category term="SDLC"></category><category term="life-cycle"></category><category term="softare development"></category><category term="project management"></category></entry><entry><title>Keeping the Customer Satisfied</title><link href="https://slott56.github.io/2008_05_14-keeping_the_customer_satisfied.html" rel="alternate"></link><published>2008-05-14T22:53:00-04:00</published><updated>2008-05-14T22:53:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-05-14:/2008_05_14-keeping_the_customer_satisfied.html</id><summary type="html">&lt;p&gt;Here's some reference information on the &amp;quot;Cone of Uncertainty&amp;quot;.  JB says that Steve McConnell popularized it.  There's an orphaned &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cone_of_Uncertainty"&gt;wikipedia article&lt;/a&gt; , a &lt;a class="reference external" href="http://www.construx.com/Page.aspx?hid=1648"&gt;note&lt;/a&gt;  on Construx.com's site, an &lt;a class="reference external" href="http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/mags/so/&amp;amp;toc=comp/mags/so/2006/03/s3toc.xml&amp;amp;DOI=10.1109/MS.2006.82"&gt;article&lt;/a&gt;  in the IEEE Digital Library, and an &lt;a class="reference external" href="http://www.microsoft.com/china/technet/images/itsolutions/techguide/innsol/images/msfpmd07.gif"&gt;image&lt;/a&gt;  on Microsoft's china site.&lt;/p&gt;
&lt;p&gt;It's crap.  Why do we use it?  Because it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Here's some reference information on the &amp;quot;Cone of Uncertainty&amp;quot;.  JB says that Steve McConnell popularized it.  There's an orphaned &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Cone_of_Uncertainty"&gt;wikipedia article&lt;/a&gt; , a &lt;a class="reference external" href="http://www.construx.com/Page.aspx?hid=1648"&gt;note&lt;/a&gt;  on Construx.com's site, an &lt;a class="reference external" href="http://csdl2.computer.org/persagen/DLAbsToc.jsp?resourcePath=/dl/mags/so/&amp;amp;toc=comp/mags/so/2006/03/s3toc.xml&amp;amp;DOI=10.1109/MS.2006.82"&gt;article&lt;/a&gt;  in the IEEE Digital Library, and an &lt;a class="reference external" href="http://www.microsoft.com/china/technet/images/itsolutions/techguide/innsol/images/msfpmd07.gif"&gt;image&lt;/a&gt;  on Microsoft's china site.&lt;/p&gt;
&lt;p&gt;It's crap.  Why do we use it?  Because it makes our customers happy.&lt;/p&gt;
&lt;div class="section" id="how-wrong-is-it"&gt;
&lt;h2&gt;How Wrong Is It?&lt;/h2&gt;
&lt;p&gt;It's crap for a number of reasons.  First, it's gloriously uncalibrated.  The horizontal axis appears like linear time, but it's just a bunch of project phases.  It isn't linear; indeed, it isn't smooth.  Estimates don't change smoothy, they change in jumps -- mostly when a manager asks you to jump.&lt;/p&gt;
&lt;p&gt;The vertical axis starts at .25x and 4x.  Random numbers, imbued with deep mystic significance, but no practical value at all.&lt;/p&gt;
&lt;p&gt;If I said it would cost anywhere from $25K to $400K I wouldn't finish the presentation.  That level of variability is unacceptable to all rational people.  The next phase (&amp;quot;Vision Approval&amp;quot;) suggests that I should have somehow reduced the &amp;quot;uncertainty&amp;quot;, and be pitching a plan that could cost anywhere from $50K to $200K.&lt;/p&gt;
&lt;p&gt;One, no one would sit still for that range.  As consultants, we're only allowed something in the neighborhood of ±33%.  From $66K to $133K.  Anything larger scares the client (and us).  &amp;quot;Too Risky&amp;quot;, everyone says.&lt;/p&gt;
&lt;p&gt;Two, who measured projects to determine these numbers?  Where's the raw data?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="non-linearity"&gt;
&lt;h2&gt;Non-Linearity&lt;/h2&gt;
&lt;p&gt;There is no smooth progression of growing &amp;quot;certainty&amp;quot;.  There are scope changes, and lots of them.  To reduce the cost, things are removed or replaced.  With a new scope, there's a new deliverable.  It isn't even sensible to call it the same project when the scope changes.&lt;/p&gt;
&lt;p&gt;Example.  I ask you to build a garage for my Bentley, you ask for $12.5 to $200K.  I don't say, &amp;quot;get to work and during the next phase of planning, reduce the range.&amp;quot;  I say &amp;quot;what runs the price up so high?&amp;quot;  You think about it and say that the heater and insulation run the price up.  I say &amp;quot;Build a car port, not a garage.&amp;quot;&lt;/p&gt;
&lt;p&gt;When I changed the scope, it didn't move you down the &amp;quot;cone of uncertainty&amp;quot;.  It started a new project, with new deliverables.  Yes, the client and the overall goal (&amp;quot;protect the Bentley&amp;quot;) remained the same.  But you can't compare the $200K for an insulated garage with $50K for a carport.  They're unrelated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="retrospective"&gt;
&lt;h2&gt;Retrospective&lt;/h2&gt;
&lt;p&gt;The final issue is that the cone of uncertainty is entirely retrospective.  At no point in the life of the project do you &lt;strong&gt;ever&lt;/strong&gt;  say &amp;quot;the remaining costs will be 1.0 &lt;em&gt;x&lt;/em&gt;.&amp;quot;  Instead, you wrap the prediction in the &amp;quot;barring further scope changes&amp;quot; qualifier.&lt;/p&gt;
&lt;p&gt;As a practical matter, almost all software projects proceed until cancelled.  I don't think it's possible for there to be (a) a definite scope that is (b) totally achieved and (c) no one can think of a single enhancement.  Since most projects involve negotiation over scope, the project ends when &amp;quot;enough&amp;quot; software has been installed to solve &amp;quot;enough&amp;quot; (sometimes all) of the business problem, and the enhancements don't seem to create &amp;quot;enough&amp;quot; value.&lt;/p&gt;
&lt;p&gt;The 1.0x business happens &lt;strong&gt;after&lt;/strong&gt;  the end.  After the project is over, and you've added up every line item, you know the final cost.  You'll be hard-pressed to find a definition of the final scope.  And no scope definition ever matches any of the initial scope statement(s).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-becomes-more-certain"&gt;
&lt;h2&gt;What Becomes More Certain?&lt;/h2&gt;
&lt;p&gt;What becomes &amp;quot;more certain&amp;quot; as the project progresses?  Almost nothing.  The staff skills improve, and our understanding gets better.  But scope changes are always a toss of the dice.  Every end-user brain fart randomizes the scope, which causes complete discontinuities in the basis of our estimation.&lt;/p&gt;
&lt;p&gt;The essential variability doesn't reduce at all.  Random errors, mistakes, confusion is a permanent feature of human behavior.  Measure everything you want, you'll find that each variable has a gigantic standard deviation.  Productivity, quality, everything varies widely.&lt;/p&gt;
&lt;p&gt;What can change is the number of degrees of freedom.  For the short periods in which the scope is absolutely fixed, each design decision removes some potential variability.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-decision-tree-of-uncertainty"&gt;
&lt;h2&gt;The Decision-Tree of Uncertainty&lt;/h2&gt;
&lt;p&gt;What we really have isn't a misleading linear-like &amp;quot;cone&amp;quot; of uncertainty.  What we really have is a big decision-tree of uncertainty.&lt;/p&gt;
&lt;p&gt;Let's work backwards.  Ideally, the final decisions will have little overall impact.  These will be deployment decisions that are trivially handled by the software's configuration files: port numbers, host names, authorized users, etc.&lt;/p&gt;
&lt;p&gt;Before these decisions are &amp;quot;simple&amp;quot; programming decisions to make speed/memory tradeoff decisions; LinkedList vs. ArrayList, for example.  These decisions are largely independent of the final deployment decisions, by the way, leading to a complex parallel set of trees.&lt;/p&gt;
&lt;p&gt;In front of the &amp;quot;simple&amp;quot; programming decisions are design decisions for how to approach loops and decisions.  In front of that are responsibility allocation decisions for how to determine class attributes and operations.&lt;/p&gt;
&lt;p&gt;Before we can make the class design decisions, we have a number of deeply intertwingled architectural decisions.  At this point, a single architectural decision (e.g., REST vs. SOAP) has a profound impact on cost, schedule, and the ensuing tree of decisions.&lt;/p&gt;
&lt;p&gt;None of these involve &amp;quot;uncertainty&amp;quot;.  What they involve is an inability to work through all alternative moves in the game.  As with chess, we have openings and gambits, but we can't create a complete decision tree from beginning to end of a game.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-may-be-a-hack-but-customers-like-it"&gt;
&lt;h2&gt;It May Be A Hack, But Customers Like It&lt;/h2&gt;
&lt;p&gt;Here's the scenario we run into.  The customer has a very poorly-defined problem.  It's hard to determine what the essential business problem really is because everyone's talking about a &amp;quot;project&amp;quot; and &amp;quot;systems&amp;quot; and &amp;quot;applications&amp;quot; and &amp;quot;data mapping&amp;quot; and &amp;quot;conversion&amp;quot; and &amp;quot;loading&amp;quot;.  Everyone's thrashing through the technical details, so our estimate is based on the technical unknowns.&lt;/p&gt;
&lt;p&gt;We provide a range.  The customer doesn't like the high end.  The presence of a low end focused them on the low end.  If you say $25K to $400K, everyone wants the $400K feature set at the $25K price.&lt;/p&gt;
&lt;p&gt;So we start negotiating.  The customer takes stuff off the table, we reduce the price.  Then, when there's no longer any business value left in the project, they start putting things back on, and complain every time we try to raise the price.&lt;/p&gt;
&lt;p&gt;At some point, they either fail to see what's going on and throw us out, or we pull out the Cone of Uncertainty picture.  This makes it look like there's a way to get $400K of features for $25K.  They're both within the &amp;quot;cone of uncertainty&amp;quot;.&lt;/p&gt;
&lt;p&gt;This is bad, but &lt;strong&gt;everyone&lt;/strong&gt;  wants a Bentley at Hyundai prices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="agility"&gt;
&lt;h2&gt;Agility&lt;/h2&gt;
&lt;p&gt;The solution is to take an Agile approach.  Rather than define a mystical cone, define a spend rate.  The team of 6 costs $500K per year.  They produce something 4 to 6 times each year -- about $100K per &amp;quot;something&amp;quot;.  Rather than plan it to death, do the following.&lt;/p&gt;
&lt;p&gt;Pick the one thing that will create some value.  Build and deploy that one thing.  Iterate.  It will cost an average of $100K per iteration.  At the end of the year, you'll have spend $500K.  Since each sprint is a stand-alone work effort, feel free to cancel the project at any time.&lt;/p&gt;
&lt;p&gt;Since the first thing delivered will be of value, you'll always be ahead of the game.&lt;/p&gt;
&lt;p&gt;&amp;quot;But what's the total cost?&amp;quot; some folks ask.  The question is stupid.  Look at legacy software.  It's been in production for decades.  A team of 2 or 3 has been supporting it for all those years.  What's the total cost of all that maintenance?  The same analysis holds true for new software -- after the first big spending sprints, you'll spend less, but never zero.&lt;/p&gt;
&lt;p&gt;There is no &amp;quot;total&amp;quot; cost until you retire the software from service.  And there's uncertainty involved in every change; the variability of human efforts never goes away.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="enterprise"></category><category term="IT"></category><category term="project planning"></category></entry><entry><title>Innovation Pushed to Vendors</title><link href="https://slott56.github.io/2008_04_16-innovation_pushed_to_vendors.html" rel="alternate"></link><published>2008-04-16T10:37:00-04:00</published><updated>2008-04-16T10:37:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-04-16:/2008_04_16-innovation_pushed_to_vendors.html</id><summary type="html">&lt;p&gt;Here's the analysis.&lt;/p&gt;
&lt;p&gt;&amp;quot;60 cents of every IT dollar goes to maintaining existing systems&amp;quot;.  &amp;quot;This increased 'run the business' spending has consumed budget resources that were originally earmarked for more strategic and transformational investment,&amp;quot; writes Gartner analyst Jed Rubin.&lt;/p&gt;
&lt;p&gt;So, what happens with the &amp;quot;innovation&amp;quot; portion of the budget?&lt;/p&gt;
&lt;p&gt;In …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Here's the analysis.&lt;/p&gt;
&lt;p&gt;&amp;quot;60 cents of every IT dollar goes to maintaining existing systems&amp;quot;.  &amp;quot;This increased 'run the business' spending has consumed budget resources that were originally earmarked for more strategic and transformational investment,&amp;quot; writes Gartner analyst Jed Rubin.&lt;/p&gt;
&lt;p&gt;So, what happens with the &amp;quot;innovation&amp;quot; portion of the budget?&lt;/p&gt;
&lt;p&gt;In effect, it's outsourced.  Since the CIO can't invest much in innovation, the vendors will be offering innovation as part of products or services.&lt;/p&gt;
&lt;p&gt;We wind up in a three-way tug-of-war.  On the one hand, some vendors offer proprietary innovation; think Microsoft and Oracle.  On the other hand, some vendors offer supported open source innovation; think Red Hat.  On the third hand, we have any in-house initiatives.  To stick with the &amp;quot;no investment&amp;quot; strategy of modern IT, the in-house folks can only use open source solutions.&lt;/p&gt;
&lt;p&gt;With two of the three poles being open source, I can see where this is headed.  Firms like IBM and Sun have a mixed bag of open source and proprietary offerings.&lt;/p&gt;
&lt;p&gt;With the third pole being Microsoft, I can see how Fear, Uncertainty and Doubt will slow movement to a glacial pace.&lt;/p&gt;
&lt;p&gt;And -- bonus -- end users are forced to suffer through this glacial pace of change.  The users can buy all the iPhones and build all the unsupported applications they want.  IT remains doggedly attached to yesterday's technology until a vendor provides the solution or it drops out of the open-source sky.&lt;/p&gt;
&lt;p&gt;I thought I read an opinion piece that pointed this out recently.  I can't find the piece anywhere, however, so perhaps I just made it up.&lt;/p&gt;
&lt;p&gt;Here's some related material: Information Week's &lt;a class="reference external" href="http://www.informationweek.com/news/services/showArticle.jhtml?articleID=198500332&amp;amp;pgno=1&amp;amp;queryText=&amp;amp;isPrev="&gt;The CIO Dilemma&lt;/a&gt; , from March '07, and this blog posting from the Long Tail: &lt;a class="reference external" href="http://www.longtail.com/the_long_tail/2007/02/who_needs_a_cio.html"&gt;Who Needs a CIO?&lt;/a&gt;&lt;/p&gt;
</content><category term="Management"></category><category term="innovation"></category><category term="supply chain"></category></entry><entry><title>Innovation includes Failure (some organizations call it "Learning", however)</title><link href="https://slott56.github.io/2008_04_09-innovation_includes_failure_some_organizations_call_it_learning_however.html" rel="alternate"></link><published>2008-04-09T13:20:00-04:00</published><updated>2008-04-09T13:20:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-04-09:/2008_04_09-innovation_includes_failure_some_organizations_call_it_learning_however.html</id><summary type="html">&lt;p&gt;Some reading:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.itworld.com/AppDev/flexible-software-application-design-nlstipsm-080408/index.html"&gt;Flexible Software is Error-Enabling Software&lt;/a&gt; , by Sean McGrath.  If users can make changes, they can make mistakes.  Why would you allow users to make changes?  It's their process, it's their data.  But, everyone in IT is absolutely sure that end users a lying gypsies.  After all, if you …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;Some reading:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.itworld.com/AppDev/flexible-software-application-design-nlstipsm-080408/index.html"&gt;Flexible Software is Error-Enabling Software&lt;/a&gt; , by Sean McGrath.  If users can make changes, they can make mistakes.  Why would you allow users to make changes?  It's their process, it's their data.  But, everyone in IT is absolutely sure that end users a lying gypsies.  After all, if you give them something like MS-Access, they just go build stuff.  There has to be a middle ground between big, slow, unresponsive corporate IT and end-user hack-arounds.&lt;/li&gt;
&lt;li&gt;An excellent book, &lt;a class="reference external" href="http://www.amazon.com/Engineer-Human-Failure-Successful-Design/dp/0679734163"&gt;To Engineer is Human: The Role of Failure in Successful Design&lt;/a&gt; , by Henry Petroski.  Yes, it dates from 1992.  However, the basic advice on what happens when you push the envelope is timeless.&lt;/li&gt;
&lt;li&gt;ComputerWorld's April 7th edition has two interviews of note.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;First, &lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;taxonomyId=17&amp;amp;articleId=314935"&gt;The End of the Internet As We Know It&lt;/a&gt; , an interview with Jonathan L. Zittrain.  The term &amp;quot;generativity&amp;quot; is used to describe the way in which we use the internet to build new things.  See &lt;a class="reference external" href="http://www.harvardlawreview.org/issues/119/may06/zittrain.shtml"&gt;The Generative Internet&lt;/a&gt;  in the Harvard Law Review.  The point is that the Internet empowers people to make new things.  It describes an open view of the world, not a closed one.&lt;/p&gt;
&lt;p&gt;Second, A Q&amp;amp;amp;A with Bala Iyer, &lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;articleId=315448"&gt;Google 'stalker' Deconstructs the Secrets to Its Success&lt;/a&gt; .  This emphasizes that some organizations make an effort to learn; they do this in part by not labeling it failure.&lt;/p&gt;
&lt;div class="section" id="insight"&gt;
&lt;h2&gt;Insight&lt;/h2&gt;
&lt;p&gt;The &amp;quot;Good ideas are Generative&amp;quot;, &amp;quot;Generative means creating New Things&amp;quot; and &amp;quot;New things may include Errors&amp;quot; was a new set of connections for me.&lt;/p&gt;
&lt;p&gt;All programming languages are generative and allow people to create bad software.  Period.&lt;/p&gt;
&lt;p&gt;Let's look at end-user computing.  When I was a kid there was this &amp;quot;Fourth Generation Language&amp;quot; idea: a better programming language would empower end-users.  Of course, they created errors and IT took those tools away from them. Now we have Business Rule engines and BPEL and BPEL editing tools.  Which IT generally keeps locked in the hands of developers and business analysts.  If you let users touch that, they'll create errors.&lt;/p&gt;
&lt;p&gt;The users, left to their own devices, invent hellish spread sheets and MS-Access databases.  When someone tackles a business problem with a spreadsheet, they create two problems.&lt;/p&gt;
&lt;p&gt;So, all innovation is controlled by big, low IT or it's utterly uncontrollable by IT.  There must be a middle ground.&lt;/p&gt;
&lt;p&gt;Generative Tools Manifesto&lt;/p&gt;
&lt;p&gt;The middle way -- between stodgy, slow IT and no IT seems to be defined by Agile techniques.  The &lt;a class="reference external" href="http://agilemanifesto.org/"&gt;Agile Manifesto&lt;/a&gt;  is helpful, but incomplete.  I think that there's another manifesto lurking in this idea of &amp;quot;generativity&amp;quot;.&lt;/p&gt;
&lt;p&gt;I think this Generative Tools manifesto may capture the innovative strengths in Java, Python, Ruby, PHP and Perl -- as languages.  But it goes beyond mere language, and into tools and the open source ecosystem.&lt;/p&gt;
&lt;p&gt;And it goes beyond developer generativity into the &amp;quot;user&amp;quot; realm.  Users are smart and sophisticated.  They will either work with corporate IT or they're work around it.  Corporate IT shouldn't be a barrier to innovation, they should enable it by passing on tools and best practices.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Transparency&lt;/strong&gt;.  For Developers, open source gives us transparency.  So does simplicity, focus, and conceptual integrity.  A good set of tools does one thing well and simply.  For Users, transparency means direct access to data, with minimal interference by &amp;quot;application&amp;quot; software.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Adaptability&lt;/strong&gt;.  For Developers, open standards allow us to build and rebuild in simple, obvious ways.  One big lesson learned is the way that Ant task definitions have a simple interface that permits endless composition without resorting to a shell script or non-Java tool.  Python's &lt;a class="reference external" href="http://docs.python.org/lib/module-main.html"&gt;top-level script environment&lt;/a&gt;  encourages simple, obvious reuse techniques.  For Users, solutions must be scriptable with an easy-to-use language.&lt;/p&gt;
&lt;p&gt;Python's easy-on-the-eyes syntax makes it the ideal substrate for building a useful Domain-Specific Language.  I've just finished studying &lt;a class="reference external" href="http://www.scons.org/"&gt;SCONS&lt;/a&gt; , and see how an elegant DSL can built on &lt;strong&gt;Gold Old Python Syntax&lt;/strong&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;strong&gt;Cost&lt;/strong&gt;.  The cost of doing things well should not be higher than stupid hacks.  Stupidity is a tax that is collected after the fact.  We can omit &amp;quot;expensive&amp;quot; configuration control now, but we'll pay for that later when we can't recover the last good release after ill-advised changes.&lt;/p&gt;
&lt;p&gt;Security, testability, configuration management, data management and the like should not involve tools any more complex than what appears to be a shared directory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, consider testing.  developers often give themselves numerous sandboxes, development, unit test, integration test and quality assurance structures.  But we collect all user-owned data into one bucket: &amp;quot;production&amp;quot;.  End users deserve to have data with multiple owners (user QA, user sandbox, training, etc.) similar to the way IT works.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="enterprise"></category><category term="IT"></category><category term="innovation"></category><category term="organization"></category></entry><entry><title>Technology and New Business Models</title><link href="https://slott56.github.io/2008_04_02-technology_and_new_business_models.html" rel="alternate"></link><published>2008-04-02T19:02:00-04:00</published><updated>2008-04-02T19:02:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-04-02:/2008_04_02-technology_and_new_business_models.html</id><summary type="html">&lt;p&gt;Let's look at one failing business model: record sales.  See Ars Technica for one summary: &lt;a class="reference external" href="http://arstechnica.com/news.ars/post/20051003-5381.html"&gt;Legal music downloads soar as CD sales fall&lt;/a&gt; .  That's news from 3 years ago.  Look at Digital Media Wire's report from this year &amp;quot;&lt;a class="reference external" href="http://www.dmwmedia.com/news/2008/02/19/report:-digital-music-download-sales-pass-cd-sales-2012"&gt;Digital Music Download Sales to Pass CD Sales by 2012&lt;/a&gt; &amp;quot;.&lt;/p&gt;
&lt;p&gt;What does …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Let's look at one failing business model: record sales.  See Ars Technica for one summary: &lt;a class="reference external" href="http://arstechnica.com/news.ars/post/20051003-5381.html"&gt;Legal music downloads soar as CD sales fall&lt;/a&gt; .  That's news from 3 years ago.  Look at Digital Media Wire's report from this year &amp;quot;&lt;a class="reference external" href="http://www.dmwmedia.com/news/2008/02/19/report:-digital-music-download-sales-pass-cd-sales-2012"&gt;Digital Music Download Sales to Pass CD Sales by 2012&lt;/a&gt; &amp;quot;.&lt;/p&gt;
&lt;p&gt;What does this mean?&lt;/p&gt;
&lt;p&gt;It means the business model is blown.&lt;/p&gt;
&lt;p&gt;Here's the order of events:  (1) New Technology, (2) Dumb Reactionary Stuff (RIAA lawsuits, etc.), (3) Business Failure.  [Look at the &lt;a class="reference external" href="http://gizmodo.com/358648/"&gt;Leaked RIAA Training Video&lt;/a&gt;  for fun.]&lt;/p&gt;
&lt;p&gt;Currently, this is the way all failed projects are characterized.  I think it's wrong.&lt;/p&gt;
&lt;div class="section" id="the-standard-scapegoat"&gt;
&lt;h2&gt;The Standard Scapegoat&lt;/h2&gt;
&lt;p&gt;Many IT projects are labeled &amp;quot;failures&amp;quot; because the technology choice didn't match the business model.  The expectation is that business provides the leadership, and IT follows along behind, dutifully providing the implementation.  Read Reforming Project Management &amp;quot;&lt;a class="reference external" href="http://www.reformingprojectmanagement.com/2006/10/01/667/"&gt;Pay Attention to the Business when Doing Projects&lt;/a&gt; &amp;quot; for another version of the party line.&lt;/p&gt;
&lt;p&gt;If IT ever gets out in front, then it's &amp;quot;disruptive&amp;quot; and a &amp;quot;failure&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-same-old-story"&gt;
&lt;h2&gt;The Same Old Story&lt;/h2&gt;
&lt;p&gt;The business owner wants a way to sell product.  Someone it IT builds a system for downloading the product instead of pressing it onto plastic disks.  Business rejects this technology and cancels the project, labeling it a complete failure.  To explain the money wasted, the business says that IT failed to understand the central role of the plastic disks.  Disks are in the contract terms and conditions, it's part of the measurement of performance, it's how executives get their bonuses.&lt;/p&gt;
&lt;p&gt;The retrospective on the project failure says that if only we'd put the Business First, we wouldn't have wasted all that money.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="technology-push"&gt;
&lt;h2&gt;Technology Push&lt;/h2&gt;
&lt;p&gt;What has recently occurred to me is the idea that technology can lead the business.  The problem is that the business will adopt one of the following postures:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Push Back.  Declare the IT effort a failure as well as a waste of money.&lt;/li&gt;
&lt;li&gt;Drag Feet.   Take years to figure out how to use the new technology.&lt;/li&gt;
&lt;li&gt;Embrace the technology.  This is the hoped-for response, and doesn't need further analysis.&lt;/li&gt;
&lt;/ol&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;&lt;strong&gt;Push Back&lt;/strong&gt;.&lt;/dt&gt;
&lt;dd&gt;If the business utterly rejects the technology, responding with strong, negative criticism, then there are fairly serious organizational issues.  Lessons learned from the music business:  executives are trying to preserve a business model they don't really understand.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;In the case of the music business, the artist produces New Works.  Not plastic disks of works frozen in time, but new stuff.  When records were rare, complex and expensive, you sweated every nuance of every minute of music.  Now that music is cheaper to produce, we want our artists to produce more, and more quickly.  The record company executive oversight is of almost no value.&lt;/p&gt;
&lt;p&gt;How do you apply this lesson learned?  Get out before the ship sinks while you're still on it.  Or, if you have enough influence, try to make some changes.  Or, if you're patient, wait for everyone else to fail around you and be the last person standing.  (This is actually pretty easy to do; you merely have avoid failure long enough for &amp;quot;not failing&amp;quot; to look like &amp;quot;succeeding&amp;quot;.)&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;&lt;strong&gt;Drag Feet&lt;/strong&gt;.&lt;/dt&gt;
&lt;dd&gt;I encounter this fairly often in big IT projects.  Everyone wants some fancy data warehousing or some fancy SOA solution.  The first project opens the door, but no one else wants to pursue the second or third project.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;The Executive &lt;strong&gt;Attention Deficit Disorder&lt;/strong&gt;  kicks in; usually midway through the next calendar year.  Once the first project is in production, we wallow in the false assumptions and lies told at the beginning and decide that the technology &amp;quot;is overrated&amp;quot;.  [Love the passive voice construction.  No one says &amp;quot;I overrated the technology&amp;quot;; they say &amp;quot;it's overrated&amp;quot;.]&lt;/p&gt;
&lt;p&gt;After mid-year, we drop the approach, the technology and the architecture, relegating it to become the next legacy.&lt;/p&gt;
&lt;p&gt;It's not that the technology is bad.  It's not that it won't work.  It's just that it takes a LONG time for the business to realize what's happening and what the possibilities are.  If record sales were declining and downloads increasing in 2005, why does it take three years for &lt;a class="reference external" href="http://news.yahoo.com/s/ap/20080325/ap_on_hi_te/germany_sony_bmg_online_music"&gt;Sony BMG to develop a music download business&lt;/a&gt; ?  And that's just the announcement that they're going to start development.&lt;/p&gt;
&lt;p&gt;IT Investment&lt;/p&gt;
&lt;p&gt;IT technology investment has to have a long-term view.  But, IT is a cost center, and the scapegoat when technology gets ahead of the business.  So a long term investment has no return to IT.&lt;/p&gt;
&lt;p&gt;Worse, as the technology gets better, investment in new business models shrinks.  See &lt;a class="reference external" href="http://hbswk.hbs.edu/item/4651.html"&gt;The VC Quandry: Too Much Money&lt;/a&gt; .  And &lt;a class="reference external" href="http://www.wired.com/techbiz/it/magazine/16-04/bz_lonelyvc"&gt;VCs Adjust to Facing More Competitors for Fewer Companies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The only way around this is to find a way to have IT make investments in the business that have a return to the IT budget.  I have no idea how to manage &amp;quot;share of the business&amp;quot; approach.&lt;/p&gt;
&lt;p&gt;Here's an insane notion.  IT needs to own shares of each line of business.  The business needs to pay dividends back with IT.  If IT has an idea and creates technology, IT should be able to &amp;quot;sell&amp;quot; it to the business for shares in the business.  If the technology grows the business, IT makes money for future investments.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="enterprise"></category><category term="IT"></category><category term="business model"></category></entry><entry><title>Technical Debt, the Cost of Cheap and "Get This Done ACAP"</title><link href="https://slott56.github.io/2008_03_08-technical_debt_the_cost_of_cheap_and_get_this_done_acap.html" rel="alternate"></link><published>2008-03-08T15:30:00-05:00</published><updated>2008-03-08T15:30:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-03-08:/2008_03_08-technical_debt_the_cost_of_cheap_and_get_this_done_acap.html</id><summary type="html">&lt;p&gt;See Martin Fowler's essay on &lt;a class="reference external" href="http://www.martinfowler.com/bliki/TechnicalDebt.html"&gt;Technical Debt&lt;/a&gt; .  Also see Steve McConnell's thoughts &amp;lt;&lt;a class="reference external" href="http://blogs.construx.com/blogs/stevemcc/archive/2007/11/01/technical-debt-2.aspx"&gt;http://blogs.construx.com/blogs/stevemcc/archive/2007/11/01/technical-debt-2.aspx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can use Agile techniques to get things done ASAP and ACAP (As Soon As Possible and As Cheap As Possible).  However, we still need to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See Martin Fowler's essay on &lt;a class="reference external" href="http://www.martinfowler.com/bliki/TechnicalDebt.html"&gt;Technical Debt&lt;/a&gt; .  Also see Steve McConnell's thoughts &amp;lt;&lt;a class="reference external" href="http://blogs.construx.com/blogs/stevemcc/archive/2007/11/01/technical-debt-2.aspx"&gt;http://blogs.construx.com/blogs/stevemcc/archive/2007/11/01/technical-debt-2.aspx&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can use Agile techniques to get things done ASAP and ACAP (As Soon As Possible and As Cheap As Possible).  However, we still need to make clear the volume of work we're likely to encounter before we have a usable product.  And we have to clarify the &lt;strong&gt;Cost of Cheap™&lt;/strong&gt;  -- better known as Technical Debt.&lt;/p&gt;
&lt;p&gt;We inherited some software from a client that we're going to maintain and enhance.  Further, we're considering ways to distribute it to some other prospective customers  The Use Cases are spot on a big, clear business problem.  The opportunities for solving this problem are huge.&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="first admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;Aside&lt;/p&gt;
&lt;p&gt;[Every time my company and a client have this kind of &amp;quot;support us, please; sell additional customers if it helps&amp;quot; conversation in the past, it always falls apart on the licensing and sale of the intellectual property.  In this instance, we've finally moved off the &amp;quot;who gets revenue from the sale&amp;quot; question by adopting what we call the &amp;quot;GPL Business Model&amp;quot; (&lt;a class="reference external" href="http://www.gnu.org/copyleft/gpl.html#section4"&gt;GPL V3 Section 4&lt;/a&gt; ).  Source is free, support is where we make the money.&lt;/p&gt;
&lt;p class="last"&gt;Services are where the money is.  It's the 21st century, there will always be free software that does more-or-less the same thing.  You can't compete on price of the initial sale.  You can only compete on the thing which is not a commodity -- skills.]&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="change-to-the-architecture"&gt;
&lt;h2&gt;Change to the Architecture&lt;/h2&gt;
&lt;p&gt;The problem we're going to have is the distribution and support of a VB app that was designed only for in-house deployment.  It isn't designed for debugging, support, configuration or even testing.  It doesn't have any unit test cases of any kind.  Indeed, there are bugs that can be spotted through simple inspection.&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="first admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;Another Aside&lt;/p&gt;
&lt;p class="last"&gt;[&lt;tt class="docutils literal"&gt;A is not NULL AndAlso A != &amp;quot; &amp;quot;&lt;/tt&gt; is the problem.  The inverse is &lt;tt class="docutils literal"&gt;A is NULL OrElse A = &amp;quot; &amp;quot;&lt;/tt&gt;.  Any other variation on these two is a common logic error.  For example, &lt;tt class="docutils literal"&gt;A is not NULL OrElse A != &amp;quot; &amp;quot;&lt;/tt&gt; doesn't do anything useful.]&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;I'd rather not mess around with remote desktop support for widely distributed communities of users.  It's really hard to do that, and it isn't a skill we have a lot of.  I'd rather provide this in a SaaS model.  We run a central sever farm, if you must have a desktop deployment, we build desktop apps that use our SaaS web services.&lt;/p&gt;
&lt;p&gt;One of the reasons the customer is handing it over to us is because they'd rather have a web-based deployment.  They can't easily convert it from desktop to web, so they're asking us to do that as part of our taking control of the application.  There's that technical debt piling up and preventing progress.&lt;/p&gt;
&lt;p&gt;However, almost every part of VB program is intimately tied to the VB desktop GUI processing.  Even the essential algorithms are full of bonus code to update the display or change the highlights on buttons or check boxes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-technical-debt-question"&gt;
&lt;h2&gt;The Technical Debt Question&lt;/h2&gt;
&lt;p&gt;The software we inherited &lt;em&gt;can&lt;/em&gt;  be deployed to another customer's desktop.  We have to rewrite significant pieces, however.&lt;/p&gt;
&lt;p&gt;&amp;quot;What's the least we can do to generate a revenue stream?&amp;quot; a manager asked.&lt;/p&gt;
&lt;p&gt;I can, of course, lie about it and say we can deploy it &amp;quot;as-is&amp;quot;.  It won't work, even a little bit, but it will be deployed.  Everything after that can be called &amp;quot;configuration&amp;quot; or &amp;quot;tuning&amp;quot;.  It will take months of this fooling around, but it will be deployed.  We can charge for the software; eventually, we'll have to give some of the revenue back because it won't be usable for months, but that's a management call, right?&lt;/p&gt;
&lt;p&gt;Management knows that the code has database and configuration dependencies that are tightly bound to the customer who's transferring the source to us.  We know about the missing pieces the customer haven't been able to transfer because &amp;quot;someone else controls that.&amp;quot;  These are things we really have to fix before trying to deploy this to another customer as if it's a ready-to-use product.  That's possibly what the manager wanted to know.  But it isn't the whole story.&lt;/p&gt;
&lt;p&gt;Once we start looking at the taking these configuration features apart, we're looking at creating regression tests for those changes.  And there are no test cases.  So, there's a hidden cost of making changes: we also need to develop tests for those changes.  And in the process of trying to define those tests, we find bugs, missing components, bad design, conflicting comments, all the usual detritus of years of doing support ACAP.  In short, we have to pay back the accumulated technical debt.&lt;/p&gt;
&lt;p&gt;If we deploy a minimally modified app, and fly people out to some new client to support and configure that software, what will our revenue stream be?  Probably a net loss, when you figure in the various costs we're going to endure.  And then, when we do offer SaaS, what do we do for those early adopters?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-dollar-value-of-technical-debt"&gt;
&lt;h2&gt;The Dollar Value Of Technical Debt&lt;/h2&gt;
&lt;p&gt;It's difficult to put a dollar value on the Technical Debt of this particular product.  It's difficult because it's hard to say how much of the original application software we're preserving.  Ideally, the technical debt is just the stuff we're fixing.  But, if we're fixing everything, what exactly was transferred to us?&lt;/p&gt;
&lt;p&gt;The architecture -- desktop VB -- goes.  The DB table structure -- with a set of FK's that the current developers say was a mistake imposed by an argumentative DBA -- will have to be discarded.  The VB code for the user interface has to be discarded.  The core algorithms are intimately tied to the GUI and have to be discarded and reimplemented disentangled from the GUI.  What's left are about eight lower-level class definitions that -- technically -- are the &amp;quot;model&amp;quot; of the MVC design pattern.  Even this has a lame X12 parser built into it -- a parser I'd like to discard in favor of something simpler.&lt;/p&gt;
&lt;p&gt;Since we're discarding almost everything but the use cases and some design elements, the current cost of the software is almost entirely of the &amp;quot;debt servicing&amp;quot; kind.  Indeed, the customer hates maintaining this program for that exact reason: all of the maintenance is debt servicing.  It's too expensive for them to try to add new features.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-to-do"&gt;
&lt;h2&gt;What To Do?&lt;/h2&gt;
&lt;p&gt;The debt has many different sources, each of which requires an investment to create something useful.  The architecture -- web -- requires that the whole UI is rebuilt from scratch.  The existing GUI and use cases can be used as the template, simplifying the effort for analysis and design.  Renovation is easy when you have a working application as a baseline: create test cases, and implement.&lt;/p&gt;
&lt;p&gt;The data model requires that most of the existing SQL implementation is rebuilt from scratch.  And, since we're moving to SaaS, we're going to expand and refine the data model.  This is almost new work. The existing model provides the conceptual framework for understanding the use cases.&lt;/p&gt;
&lt;p&gt;My approach is to apply Test Driven Reverse Engineering.  We'll concoct the missing unit tests and build an application that seems to do what the original application did.  It's easy to do this in Python.  Harder in Java.  Since we're discarding almost all of the VB, there's no compelling reason for messing with the .Net framework.&lt;/p&gt;
&lt;p&gt;Since Python is such a high-productivity environment, it's easiest to rewrite tis in Python.  Easier than it is to write specifications for Java programmers to work from.  The bulk of the reverse engineering time is spent writing and arguing over the unit test cases.  The actual application programming time is much less.&lt;/p&gt;
&lt;p&gt;Once we have something web-enabled, with a proper data model and a proper object model we can begin the maintenance cycle again.  Of course, future managers will make short-sighted, &lt;strong&gt;As Cheap As Possible™&lt;/strong&gt;  (ACAP) decisions and we'll accrue technical debt until we are overwhelmed by the &lt;strong&gt;Cost of Cheap&lt;/strong&gt; .&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="planning"></category><category term="open source"></category><category term="enterprise"></category><category term="cost"></category></entry><entry><title>Open Source and Corporate IT (again)</title><link href="https://slott56.github.io/2008_02_15-open_source_and_corporate_it_again.html" rel="alternate"></link><published>2008-02-15T21:26:00-05:00</published><updated>2008-02-15T21:26:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2008-02-15:/2008_02_15-open_source_and_corporate_it_again.html</id><summary type="html">&lt;p&gt;Someone sent this question to their manager and included me on the CC: list.&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;Would you consider tools like Django to quickly build web apps ?&amp;quot;&lt;/blockquote&gt;
&lt;p&gt;My suggestion is that a bald query like this can only get on of two possible answers: &amp;quot;No&amp;quot; (and a large number of unsubtle variations …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Someone sent this question to their manager and included me on the CC: list.&lt;/p&gt;
&lt;blockquote&gt;
&amp;quot;Would you consider tools like Django to quickly build web apps ?&amp;quot;&lt;/blockquote&gt;
&lt;p&gt;My suggestion is that a bald query like this can only get on of two possible answers: &amp;quot;No&amp;quot; (and a large number of unsubtle variations like &amp;quot;hell no&amp;quot;) and the ego-salving &amp;quot;If it makes business sense, we'll consider it.&amp;quot;  Which is code for &amp;quot;no&amp;quot;.&lt;/p&gt;
&lt;p&gt;The &amp;quot;No&amp;quot; card is easy to play.  The manager simply trumps it with the &amp;quot;risk&amp;quot; card and the hand is over.  Manager wins by saying &amp;quot;open source&amp;quot; == &amp;quot;risk&amp;quot; enough times that everyone up down the food chain can repeat the unsubstantiated claim.&lt;/p&gt;
&lt;p&gt;The &amp;quot;If it makes business sense&amp;quot; card is equally easy.  The burden of proof is delightfully vague and the resulting action (&amp;quot;consider it&amp;quot;) allows an easy toss of the &amp;quot;No&amp;quot; card.  Neither requires thought or any action other than the &amp;quot;prevent change&amp;quot; defense.&lt;/p&gt;
&lt;div class="section" id="permission-vs-forgiveness"&gt;
&lt;h2&gt;Permission vs. Forgiveness&lt;/h2&gt;
&lt;p&gt;In short, asking permission gets you nowhere.  I said as much.  I got this reply.&lt;/p&gt;
&lt;p&gt;&amp;quot;I planted the seed via the email and lets see what happens.&amp;quot;&lt;/p&gt;
&lt;p&gt;Sorry, but, here's what will happen:  Nothing.  You have to actually &lt;strong&gt;Do&lt;/strong&gt;  something.  About the only thing that will turns heads is to build a proof-of-concept.  And you'll &lt;em&gt;never&lt;/em&gt;  get permission to do that; you have to do it surreptitiously.  Once you've actually done something, the horse is out of the barn.  The bell cannot be un-rung.  Now the relationship is one of damage control and forgiveness -- battles where there is no clear Maginot line.&lt;/p&gt;
&lt;p&gt;It doesn't matter how good new technology is, it takes an epic problem to lead IT to consider changing course and actually taking action on those considerations.  The email didn't characterize or reflect any  company-threatening problem.  It didn't reflect any problem at all except the usually boo-hooing of software development being slow and expensive.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="course-corrections"&gt;
&lt;h2&gt;Course Corrections&lt;/h2&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;If someone has decided to change course and is asking which new course they should pursue, you can, sometimes, influence them.  To actually change tack, they must see the rocks ahead: they must be desperate, in fear of being fired, and have already decided to fire everyone and start in a new direction.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Remember: &lt;strong&gt;change is bad&lt;/strong&gt; . It's bad because it's disruptive and disruption is risky and risk == cost. (Note, risk does not actually == cost, risk is only &amp;quot;potential cost&amp;quot;. Every manager on the planet will &lt;strong&gt;act&lt;/strong&gt;   based on the claim that risk == actual cost.)&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;[BTW, most managers who decline to consider open source software are, of course, liars and/or schizophrenics because they already have oodles of open source software. That's not the issue. Really, that's just the usual background level of schizophrenia and mendacity.]&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;The only time when anyone will actually consider open source software is when they are in a &amp;quot;go out of business or get fired&amp;quot; situation.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;The solution more likely to be accepted is one which dovetails with existing technology. If they are using Java, they want to hear more of the same. If they are using VB/C#, they want to hear more of the same. Unless they're already a Python shop, Django doesn't fill the &amp;quot;more of the same&amp;quot; criteria.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;That's why a POC is so powerful.  Once the horse is out of the barn, we're no longer seeking permission, we're now into negotiation how much more of this can be permitted.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="playing-to-their-strong-suit"&gt;
&lt;h2&gt;Playing to Their Strong Suit&lt;/h2&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Here's the suggestion they made.  This, too, is fraught with peril.  &amp;quot;Suggestion: Make some assumptions and give the client an ROI number&amp;quot;.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Sorry, I'm not a fan of ROI for these kinds of projects.  ROI rarely makes sense with tooling questions, since we're talking about IT's internal ROI.  IT is a cost center:  the whole ROI thing is on it's ear because there isn't a positive &amp;quot;return&amp;quot;, just the potential of reduced costs at some time in the future.  Boring.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Further, software-related ROI requires a lot of supporting opinion.  It's rarely fact-based because we are usually unable to do nifty side-by-side comparisons of team A using toolset #1 and team B using toolset #2 to build the Same Application.  Software development isn't manufacturing; very little of it is trivially repeatable like this.  Who would buy the same software twice in order to do a head-to-head comparison between toolsets?&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;The closest you can come to ROI is a pilot project.  Wait!  Isn't that just a proof of concept?&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;ROI is a lot of assumptions in a big report that gets you the inevitable &amp;quot;No.&amp;quot;  Realistic, fact-based ROI looks too small.  Assumptions that serve to bump up the ROI get challenged.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="your-competitors-don-t-do-this"&gt;
&lt;h2&gt;Your Competitors Don't Do This&lt;/h2&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;No one asked Microsoft for an ROI on Visual Studio 8.  No one asked Oracle for an ROI on using PL/SQL for every piece of custom code.  No one asked Sun to provide detailed ROI numbers for introduction of J2EE web servers.  Nope.  Not a single ROI number was used for these decisions.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Why should you play the ROI game when none of your competitors are asked to play?&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;Tooling requires POC.  You can't induce anything without tangible proof that the proposed tool beats the pants off the incumbent tool.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;p&gt;I don't see how a &amp;quot;you should change course&amp;quot; suggestion can ever work.   (A) It begins &amp;quot;you should&amp;quot;, which is like beginning with &amp;quot;you people&amp;quot;:  listening stops almost immediately.  And, (B) it includes &amp;quot;change course&amp;quot; which is always unwelcome: it reflects badly on the previous course.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="planning"></category><category term="open source"></category><category term="enterprise"></category></entry><entry><title>Database Design and UML - What was the question again?</title><link href="https://slott56.github.io/2007_12_15-database_design_and_uml_what_was_the_question_again.html" rel="alternate"></link><published>2007-12-15T13:08:00-05:00</published><updated>2007-12-15T13:08:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-12-15:/2007_12_15-database_design_and_uml_what_was_the_question_again.html</id><summary type="html">&lt;p&gt;One issue in creating a database design is working around the limitations inherent in the SQL data model.  I'm going to call it the SQL model because you can make the case that the entity-relationship (ER) model is an abstraction and could have a far more expressive implementation.  I'm going …&lt;/p&gt;</summary><content type="html">&lt;p&gt;One issue in creating a database design is working around the limitations inherent in the SQL data model.  I'm going to call it the SQL model because you can make the case that the entity-relationship (ER) model is an abstraction and could have a far more expressive implementation.  I'm going to claim that the SQL implementation introduces some limitations.  Ironically, the issue is getting database designers to recognize this.&lt;/p&gt;
&lt;p&gt;Here's the lead-off question: &amp;quot;What do you think of Scott Ambler's approach to using UML to do ERD's?&amp;quot;&lt;/p&gt;
&lt;p&gt;This is a reference to the
&lt;a class="reference external" href="http://www.agiledata.org/essays/impedanceMismatch.html"&gt;Object-Relational Impedance Mismatch&lt;/a&gt;
article.  The question is a little out-of-phase because the article isn't about UML
&lt;em&gt;per se&lt;/em&gt; .  It's about ORM, it just happens to use UML.  But, I guess the question is really &amp;quot;Is Ambler showing a good example of using UML for doing E-R design?&amp;quot;&lt;/p&gt;
&lt;p&gt;My response was pretty rude.  The trivial answer is &amp;quot;Yes&amp;quot;.  But there had to be something else going on.  I also asked how you could justify NOT using a standard like UML?&lt;/p&gt;
&lt;p&gt;Regarding context, it's important to note that the query comes from an All-Singing-All-Dancing-All-Oracle kind of person.  So the ERD question is focused on producing relational database SQL.&lt;/p&gt;
&lt;p&gt;See
&lt;a class="reference external" href="https://slott56.github.io/2006_06_20-over_solving_the_problem_or_when_your_architect_is_a_dba.html"&gt;Over-Solving the Problem&lt;/a&gt;
and
&lt;a class="reference external" href="https://slott56.github.io/2007_11_03-lenses_that_distort_our_software_flat_files_relational_databases_batch_processing.html"&gt;Lenses that Distort our Software&lt;/a&gt; .  Architecture should be larger than answering the &amp;quot;how do we use the database?&amp;quot; question.  But some DBA's reduce everything to database and SQL.&lt;/p&gt;
&lt;p&gt;The question is unlikely to be this silly and trivial.  The answer is &amp;quot;Yes,&amp;quot; but the follow up is &amp;quot;What did you really mean?&amp;quot;&lt;/p&gt;
&lt;div class="section" id="richness-of-notation"&gt;
&lt;h2&gt;Richness of Notation&lt;/h2&gt;
&lt;p&gt;Using UML -- for anything -- presents two problems.&lt;/p&gt;
&lt;p&gt;First, UML is very rich; it can depict things you have a hard time implementing.&lt;/p&gt;
&lt;p&gt;Second, UML is very rich, and it isn't obvious what subset of the notational alternatives are appropriate to what you're trying to depict.&lt;/p&gt;
&lt;p&gt;A UML class diagram can show a lot of things.  Specifically, UML is biased toward showing object-oriented class definitions, with attributes as well as methods.  You can, of course, try and limit yourself to just enough notation to define a SQL database.  However, you're missing a lot of opportunities for clarifying the problem and bracketing alternative solutions.&lt;/p&gt;
&lt;p&gt;In summary, rich notation gives you a way of visualizing the real problem.  The real world is complex and messy.  Rich notation is essential for describing the world as we find it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-politics-question"&gt;
&lt;h2&gt;The Politics Question&lt;/h2&gt;
&lt;p&gt;In many organizations, UML is unusable.  First, it's not the classic James Martin Crow's Feet Notation.  For some reason, this notation came out in the early days and has stuck.  Permanently.  ERWin, for example, uses this notation and everyone loves it.  Switching to UML requires leaving the crow's feet behind.  What's the ROI on that kind of change?&lt;/p&gt;
&lt;p&gt;A second reason that UML can be unusable is that organizations suffer from some fundamental concept problems.  A database separates a &amp;quot;logical view&amp;quot; from a &amp;quot;physical view&amp;quot;.  Most people forget what the physical view is, and do some bizarre things.  UML clarifies the views, but can introduce new terminology.  And who wants their terminology changed?&lt;/p&gt;
&lt;p&gt;ERWin creates the confusion by claiming that the &amp;quot;physical&amp;quot; view is the logical model with vendor-specific names.  This is flat-out wrong.  The physical model is the physical on-disk structures.  In Oracle parlance, the physical model includes the tablespaces and underlying files.  ERWin doesn't even depict this.  UML can show this, however, making this level of design visible.&lt;/p&gt;
&lt;p&gt;ERWin's &amp;quot;logical&amp;quot; and &amp;quot;physical&amp;quot; models are really just a Logical View of data: it maps entities to SQL tables and columns.  ERWin's &amp;quot;logical&amp;quot; model is more accurately termed &amp;quot;Platform Independent Model&amp;quot;; their &amp;quot;physical&amp;quot; model is an &amp;quot;Platform Specific Model&amp;quot;.  Some UML tools don't show the PIM vs. PSM comparison well because they aren't as handy at flipping back and forth between models.&lt;/p&gt;
&lt;p&gt;ERWin, as an incumbent, gives us one political viewpoint.  The introduction of new notation and terminology will face a struggle.  Standardization doesn't enter into dislodging the incumbent terminology.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reality-objects-and-relations"&gt;
&lt;h2&gt;Reality, Objects and Relations&lt;/h2&gt;
&lt;p&gt;The biggest problem -- the one that Ambler was addressing -- was the mismatch between object classes and SQL tables.  The object model is very rich with numerous features for depicting the real world.  The SQL relational model, on the other hand, is rather poor.  A great deal of clever things can be done in the relational world.  In the object world, we don't have to be nearly so clever.&lt;/p&gt;
&lt;p&gt;We have a number of mapping steps here, and I think this is the crux of the question.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;We have users and the real entities they deal with.  Documents or Notices or    Claims or Balances or whatever is the subject of the problem domain.&lt;/li&gt;
&lt;li&gt;We can have an object model.  This is rich with features, and generally has a high fidelity match with the real world.  Some object implementations impose some constraints (like single inheritance) but the UML diagram should capture the problem domain's entities precisely.&lt;/li&gt;
&lt;li&gt;We have a SQL-based model.  This is relatively poor in features, being limited to a few data types and foreign key relationships.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;By using UML, we can depict either model of reality with a great deal of useful precision.   The initial question -- &amp;quot;What do you think&amp;quot; -- doesn't have an interesting answer.  Yes, UML works.  It's hard.  You won't like it for dumb political reasons.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-real-question"&gt;
&lt;h2&gt;The Real Question&lt;/h2&gt;
&lt;p&gt;A little digging lead to this follow-up question statement:  &amp;quot;Goal: Generate DDL (create table, create FK) from the UML model for various target databases.&amp;quot;&lt;/p&gt;
&lt;p&gt;So the initial question wasn't &amp;quot;what do you think?&amp;quot; but &amp;quot;Can I engineer my SQL using UML?&amp;quot;&lt;/p&gt;
&lt;p&gt;The answer to this, also, is &amp;quot;Sure&amp;quot; and &amp;quot;What do you really mean by that?&amp;quot;  There are any number of UML design tools with DDL creation features.  A quick Google reveals
&lt;a class="reference external" href="http://www.magicdraw.com/"&gt;Magic Draw&lt;/a&gt;
UML and ` &amp;lt;&lt;a class="reference external" href="http://www.sparxsystems.com.au/products/index.html"&gt;http://www.sparxsystems.com.au/products/index.html&lt;/a&gt;&amp;gt;`_ &lt;a class="reference external" href="http://www.sparxsystems.com.au/"&gt;Sparx&lt;/a&gt;
Enterprise Architect,
&lt;a class="reference external" href="http://www.ibm.com/developerworks/rational/library/07/1002_vasudevamurthy/index.html"&gt;IBM-Rational&lt;/a&gt;
Business Developer, and &lt;a class="reference external" href="http://www.visual-paradigm.com/"&gt;Visual Paradigm&lt;/a&gt;
for UML.  Clearly, they do precisely what is needed.  Why ask me?&lt;/p&gt;
&lt;p&gt;Here's the follow up:&lt;/p&gt;
&lt;p&gt;&amp;quot;Bigger goal: Keep the UML, Java code, and DDL all in sync&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="in-synch-with-what"&gt;
&lt;h2&gt;In Synch with What?&lt;/h2&gt;
&lt;p&gt;While keeping various models &amp;quot;in synch&amp;quot; is a noble aspiration, it's delightfully vague.  Vague enough that problems inevitably ensue.&lt;/p&gt;
&lt;p&gt;A fundamental problem is that a database design is really a kind of knowledge capture.  We do different kinds of knowledge capture for different purposes.  It's difficult to synchronize all of the knowledge that comprises working software.&lt;/p&gt;
&lt;p&gt;First, we have problem domain knowledge, often called &amp;quot;analysis&amp;quot;.  There may be any number of views (logical, process, use case, component) of the problem.&lt;/p&gt;
&lt;p&gt;Second we have solution knowledge, often called &amp;quot;design&amp;quot;.  There may be any number of views of the solution, also.  If you search for four plus one views, or Philippe Kruchten, you can find excellent coverage like
&lt;a class="reference external" href="http://www.surfscranton.com/Architecture/ApplicationArchitecture.htm"&gt;http://www.surfscranton.com/Architecture/ApplicationArchitecture.htm&lt;/a&gt;
and &lt;a class="reference external" href="http://www.ibm.com/developerworks/wireless/library/wi-arch11/"&gt;http://www.ibm.com/developerworks/wireless/library/wi-arch11/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There's a mapping between the two, but they are never isomorphic.  We rarely solve all of the problem.  We may have a solution which is somewhat more general than the original problem, and has bonus features.&lt;/p&gt;
&lt;p&gt;Clearly, to keep all the models in synch, we have to focus on design only or analysis only.  If we pick design only, we have layers of meaning from an abstract solution, a concrete platform independent solution, and a concrete platform-specific solution (i.e., &amp;quot;code&amp;quot;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-was-the-question"&gt;
&lt;h2&gt;What Was The Question?&lt;/h2&gt;
&lt;p&gt;Can we keep the various design elements in synch?  The answer is almost &amp;quot;Yes&amp;quot;.  If it weren't for the shortcomings of the SQL Relational model, it would be easy.&lt;/p&gt;
&lt;p&gt;Sadly, we have this essential problem -- the Object-Relational Impedance Mismatch problem.  The problem stems directly from the limited nature of the SQL relational model.  We have to make intelligent choices in how we are going to work around the limitations of the SQL world.  These choices will clutter up our object model with details that are relevant to the SQL world, but not the Object world.&lt;/p&gt;
&lt;p&gt;Just one example: containment.  In the object world, an object can be a collection and contain other objects.  The container and containees can have mutual references.  The container can have a variety of semantics: list, set or mapping.  (Python people further subdivide list into mutable and immutable variants.)&lt;/p&gt;
&lt;p&gt;The relational world only has a foreign key relationship from containee to the overall container.  The container is -- utterly -- unconscious of the role as container.  The only exception might be the presence of a cascade delete rule.&lt;/p&gt;
&lt;p&gt;I've got a huge conceptual gap between objects and SQL.  To bridge that gap, I have to write code, queries and object-relational maps.  While my Java has one view, my SQL has a considerably restricted view.  My queries might be limited to the SQL view.  Or, depending on the design, they might depend on the more liberal Java view.  In Java, navigation is a simple &amp;quot;.&amp;quot; operator or a getter method.  In SQL, navigation is a full-scale SELECT statement or a SELECT statement with JOINS.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-irony"&gt;
&lt;h2&gt;The Irony&lt;/h2&gt;
&lt;p&gt;So here's the irony in this long sad story.  The DBA reads Ambler's article about Object-Relational Impedance.  The DBA asks a tangential question about UML.  I press the DBA for details to find that they want some kind of automated maintenance that will eliminate Object-Relational Impedance.  Apparently, they didn't actually read the article that stimulated the question in the first place.  At the end was a reference to
&lt;a class="reference external" href="http://www.agiledata.org/essays/mappingObjects.html"&gt;O/R Mapping in Detail&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;This reference lays out the issues in glorious detail.  It should be clear that there are so many SQL shortcomings that it can't be automated.  The Object and SQL worlds aren't simply two implementations of a model in slightly different syntax.  They're two different designs aimed at solving the same problem; they can't easily be reconciled.  UML has nothing to do with this essential problem.  I'm guessing that my DBA only looked at the pictures.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="Design"></category><category term="Database"></category><category term="UML"></category><category term="ERD"></category></entry><entry><title>Estimating, and the Unknown Unknowns</title><link href="https://slott56.github.io/2007_11_11-estimating_and_the_unknown_unknowns.html" rel="alternate"></link><published>2007-11-11T20:17:00-05:00</published><updated>2007-11-11T20:17:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-11-11:/2007_11_11-estimating_and_the_unknown_unknowns.html</id><summary type="html">&lt;p&gt;Back in the olden days (ca. 1981) Barry Boehm's Software Engineering Economics provided a detailed and definitive guide to estimating.  It did one really important thing: it provided a conceptual model of software development that had a (relatively) focused set of degrees of freedom, an input driver and a couple …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Back in the olden days (ca. 1981) Barry Boehm's Software Engineering Economics provided a detailed and definitive guide to estimating.  It did one really important thing: it provided a conceptual model of software development that had a (relatively) focused set of degrees of freedom, an input driver and a couple of outputs.  This model, the Constructive Cost Model (COCOMO) had the advantage of formality and a solid basis in repeatable metrics.&lt;/p&gt;
&lt;p&gt;The problem is that the model is circular.  Ideally, we want a model that's like the Function Point model: &lt;strong&gt;Requirements In → Software Out&lt;/strong&gt; .  The function point folks evaluate five aspects of the requirements and from those aspects determine the effort, schedule and cost.  The FP aspects are Internal Logical Files, External Logical Files, External Inputs, External Outputs and External Inquiries.  Note the emphasis on externally visible features, and the emphasis on the essential ingredients of software.&lt;/p&gt;
&lt;p&gt;COCOMO, unfortunately, gives us a model that is &lt;strong&gt;Lines of Code In → Software Out&lt;/strong&gt; .  Wait, how can we know the lines of code going in?  We can't, but we can estimate the lines of code going in, and from that, deduce the effort, schedule and cost.&lt;/p&gt;
&lt;p&gt;You could deprecate this by saying that we've merely replaced estimating everything with estimating lines of code.  The problem hasn't gone away, it's only shifted.  The good news is that we've replaced a vague estimation of everything, with a fact-based estimate of lines of code.  From that, the model gives us effort, schedule, staffing and cost.&lt;/p&gt;
&lt;p&gt;Joel's technique isn't really modeling software development, per se.  Joel's technique is to model the estimating process and show how well people adhere to their estimates.  In short,**Estimate In → Estimate Out** .  This is clearly indirect stuff, since we're modeling our ability to manage estimating, not the work itself.&lt;/p&gt;
&lt;div class="section" id="accuracy-issues"&gt;
&lt;h2&gt;Accuracy Issues&lt;/h2&gt;
&lt;p&gt;Of course, COCOMO (or Function Points) or even Joel's &amp;quot;Evidence Based Scheduling&amp;quot; have no basis in reality.  More precisely, they have no basis in the reality in which you are currently working.  Clearly, all of the COCOMO numbers are true; but only for those projects, that technology, those managers and customers.&lt;/p&gt;
&lt;p&gt;Joel suggests (just like Boehm before him) that it's all about repeatability.  He says that small steps, clear measurements (elapsed time in Joel's case, effort in Boehm's case), a model and active management are essential.  He also says what Boehm says in chapter 32: gather data to fine-tune your estimating.&lt;/p&gt;
&lt;p&gt;The modeling can't be emphasized enough.  The original idea was that duration (or effort) are defined by a function that varies with the scope of work.  Joel's indirect model refines this by saying that actual duration is defined by a function that varies with the person and their original estimate.&lt;/p&gt;
&lt;p&gt;With enough history, the estimates will tend to get very accurate.  As long as everything else is held constant.  Sadly, nothing else is ever held constant.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="into-the-fog"&gt;
&lt;h2&gt;Into the Fog&lt;/h2&gt;
&lt;p&gt;If we're doing anything of value, it almost always involves some novelty.  As I said in &amp;quot;&lt;a class="reference external" href="https://slott56.github.io/2006_08_22-a_new_architecture_involves_ignorance.html"&gt;A New Architecture Involves Ignorance&lt;/a&gt; ,&amp;quot; we don't start software development unless there's something we don't know.  If the solution is perfectly well understood, we're very likely to be talking about something we can just download and use.  If the problem is well understood, it's likely that we already have some software in place, and we can measure that software.  Many times, the technology involves something new or untried.&lt;/p&gt;
&lt;p&gt;The alternative -- where everything is known -- is little more than a classroom exercise.  The only way to know everything is to have working software that we're essentially re-implementing.  What's the value in that?&lt;/p&gt;
&lt;p&gt;Once we're tackling a new problem, creating a new solution or using a new technology, our previous estimating history database is of limited value.  Our new technology projects can't be compared to our old technology.  My personal database of C programming measurements just don't apply to Java programming.&lt;/p&gt;
&lt;p&gt;While it's important to gather data, it's also important to recognize the limitations of gathering data when there are few constants.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="design-first"&gt;
&lt;h2&gt;Design First&lt;/h2&gt;
&lt;p&gt;A colleague pointed out Joel's article.  They said that this was a way to show that estimating requires a design first.  I think that the points from my colleague were the following:&lt;/p&gt;
&lt;p&gt;There's a management fantasy that initial estimates actually mean something.  We have limited knowledge, but managers ask for estimates anyway.&lt;/p&gt;
&lt;p&gt;Once we start designing, we're chided for changing the estimates.  As we gain knowledge, everything we learn is treated as a problem.  Trying to adjust scope is called &amp;quot;scope creep&amp;quot;.  Trying to adjust estimates upward is called &amp;quot;out of control&amp;quot;.  Trying to adjust estimates downward is called &amp;quot;sandbagging&amp;quot;.  We can't win.&lt;/p&gt;
&lt;p&gt;My colleague wanted the article to somehow help clarify the relationship between estimates and knowledge.  I don't think it can.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-unknowns-have-it"&gt;
&lt;h2&gt;The Unknowns Have It&lt;/h2&gt;
&lt;p&gt;I think that our human tendency to be deeply risk-averse makes it nearly impossible to produce an estimate of software development effort.  We have to guess about something (unless we're just doing a classroom exercise.)&lt;/p&gt;
&lt;p&gt;If we guess, we stand a chance of being wrong.  Each mistake -- each course correction -- is a potential failure.  Ask anyone who has budgetary responsibility for software development: change is magnified to include &amp;quot;loss&amp;quot;, &amp;quot;devastation&amp;quot;, &amp;quot;waste&amp;quot;, &amp;quot;mistakes&amp;quot;, &amp;quot;errors&amp;quot;, and every other kind of negative connotation.&lt;/p&gt;
&lt;p&gt;We all know that software developers are hobos, tramps and thieves.  We're not to be trusted.  We're lazy sandbaggers.  We estimate low so we can win the bid and then charge more through change control.  We estimate high so that can slack off.  We expand scope to build an empire.  We contract scope to make the project worthless.&lt;/p&gt;
&lt;p&gt;There's no good outcome.  Joel's advice might be helpful, but you're in a battle you can't win.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="Risk"></category><category term="Unknowns"></category><category term="Estimating"></category><category term="Planning"></category><category term="Project Management"></category></entry><entry><title>ROI, NPV and Shermer's column in the July Scientific American , on Homo economicus (revised)</title><link href="https://slott56.github.io/2007_09_08-roi_npv_and_shermers_column_in_the_july_scientific_american_on_homo_economicus_revised.html" rel="alternate"></link><published>2007-09-08T19:11:00-04:00</published><updated>2007-09-08T19:11:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-09-08:/2007_09_08-roi_npv_and_shermers_column_in_the_july_scientific_american_on_homo_economicus_revised.html</id><summary type="html">&lt;p&gt;Michael Shermer's column, in the July 2007 &lt;em&gt;Scientific American&lt;/em&gt; , &amp;quot;&lt;a class="reference external" href="http://sciam.com/print_version.cfm?articleID=27333871-E7F2-99DF-3A66FD19F6C2AF91"&gt;The
Prospects for Homo economicus&lt;/a&gt; &amp;quot;, notes that we all impaired when it comes to
making economic decisions.&lt;/p&gt;
&lt;p&gt;Also, see Kathleen Melymuka's article in
the July 23, 2007 &lt;em&gt;Computerworld&lt;/em&gt; , &amp;quot;&lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;taxonomyName=project_management&amp;amp;articleId=297575&amp;amp;taxonomyId=73&amp;amp;intsrc=kc_feat"&gt;Boiling the IT Frog&lt;/a&gt; &amp;quot;.   Harwell Thrasher
suggests that simple ROI calculations don't work …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Michael Shermer's column, in the July 2007 &lt;em&gt;Scientific American&lt;/em&gt; , &amp;quot;&lt;a class="reference external" href="http://sciam.com/print_version.cfm?articleID=27333871-E7F2-99DF-3A66FD19F6C2AF91"&gt;The
Prospects for Homo economicus&lt;/a&gt; &amp;quot;, notes that we all impaired when it comes to
making economic decisions.&lt;/p&gt;
&lt;p&gt;Also, see Kathleen Melymuka's article in
the July 23, 2007 &lt;em&gt;Computerworld&lt;/em&gt; , &amp;quot;&lt;a class="reference external" href="http://www.computerworld.com/action/article.do?command=viewArticleBasic&amp;amp;taxonomyName=project_management&amp;amp;articleId=297575&amp;amp;taxonomyId=73&amp;amp;intsrc=kc_feat"&gt;Boiling the IT Frog&lt;/a&gt; &amp;quot;.   Harwell Thrasher
suggests that simple ROI calculations don't work.  The fact that we are all
impaired in making economic judgements puts this observation into sharp
perspective.&lt;/p&gt;
&lt;p&gt;Also, see Jena McGregor's article in the June 15, 2007, &lt;em&gt;Business Week&lt;/em&gt; , &amp;quot;&lt;a class="reference external" href="http://www.businessweek.com/innovate/content/jun2007/id20070615_198176.htm"&gt;Clayton Christensen's Innovation Brain&lt;/a&gt; &amp;quot;.   &amp;quot;...the mathematics have an implicit assumption within them that if we don't do this innovation, the way things are today will maintain themselves in the future.&amp;quot;  In short, we assume we won't lose anything; which biases the analysis based on our biggest fear: loss.&lt;/p&gt;
&lt;p&gt;Here's &lt;strong&gt;The Big Issue&lt;/strong&gt; ™: We can't compare wins against losses. Our
brain is wired for &amp;quot;Prevent Loss Decision-Making&amp;quot;. We magnify losses (and
potential losses) by a factor of 2.&lt;/p&gt;
&lt;p&gt;Why?  Clearly, we want to keep what
we have.  Future gains are just wishful thinking, worth only half of what people
claim.  Future losses are a serious kick in the pants, the impact will be twice
as bad as the consultants predict&lt;/p&gt;
&lt;p&gt;We can't inflate the future wins -- that's
insanity.  We can't easily diminish the potential for loss.  Or can
we?&lt;/p&gt;
&lt;div class="section" id="the-roi-trap"&gt;
&lt;h2&gt;The ROI Trap&lt;/h2&gt;
&lt;p&gt;Thrasher (and others) note that simple ROI calculations aren't
always appropriate.  First, ROI is usually based on a pack of lies.  More
important, however, is that ROI doesn't include &amp;quot;possibilities&amp;quot; like
reusability, adaptability, flexibility, interoperability.  It's hard to compute
an expected value (probability times dollar value) for adaptation of software to
an as-yet-undefined new business model.&lt;/p&gt;
&lt;p&gt;ROI of potentialities
is too rarefied for even an MBA in finance.  What's the discount rate on an
executive cutting a deal with a partner company that has a devastating impact on
the current data model?  We can't know.  So we shouldn't try.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cya"&gt;
&lt;h2&gt;CYA&lt;/h2&gt;
&lt;p&gt;Because decision-making is irrationally
loss-averse, it explains at lot of what passes for management.  It explains, for
example, why the possibility of risk is so central to IT decision-making.  If
there's risk, and if every manager on the food-chain has not identified the
down-sides of a project, they will be excoriated by their
superiors&lt;/p&gt;
&lt;p&gt;` &amp;lt;&lt;a class="reference external" href="http://www.sciam.com/article.cfm?articleIDThe"&gt;http://www.sciam.com/article.cfm?articleIDThe&lt;/a&gt;
Prospects for homo economicus&amp;lt;/a&amp;gt;, notes that we all impaired when it comes to
making economic decisions. &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Also, see Kathleen Melymuka's article in
the July 23, 2007 &amp;lt;i&amp;gt;Computerworld&amp;lt;/i&amp;gt;, &amp;lt;a href=&amp;gt;`_ , notes that we all impaired when it comes to
making economic decisions.&lt;/p&gt;
&lt;p&gt;Also, see Kathleen Melymuka's article in
the July 23, 2007 &lt;em&gt;Computerworld&lt;/em&gt; , &lt;a class="reference external" href="../C412398194/E20070628152000/index.html"&gt;This puts a lot of project rejection squarely in the prevent-loss
mode.  It also explains  `Keep The Lights On
Management&lt;/a&gt; .  It supports KTLO decisions as replacing the risk of making a
mistake with the non-loss strategy of Keep The Lights On.  Any attempt to invest
outside the KTLO minimum exposes the enterprise to the possibility of loss,
which is unacceptable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="making-progress"&gt;
&lt;h2&gt;Making Progress&lt;/h2&gt;
&lt;p&gt;The deal seems to be
the following:  &lt;strong&gt;Don't Mix Wins and Losses.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If a manager wants to know what the &amp;quot;impact&amp;quot; of
a software change is, don't give the full spectrum of
answers.&lt;/p&gt;
&lt;p&gt;The possibility of a screw-up (or other kind of loss) is one
thing.&lt;/p&gt;
&lt;p&gt;The potential win from getting the right software in place is
another thing -- treat it as if it had different units.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="further-notions"&gt;
&lt;h2&gt;Further Notions&lt;/h2&gt;
&lt;p&gt;Also, we know that software isn't really &amp;quot;done.&amp;quot;  If it's
home-brewed, and has any value at all, people will mess with it forever.  The
pace of change may fall from initial development team to maintenance team.  But
there's no &amp;quot;done&amp;quot; until the day to turn the software off because it was
replaced.&lt;/p&gt;
&lt;p&gt;This means there's no price.  At least, there's no final, single,
big, ugly number.  Software acquisition is about the rate of expenditure over
future years.  $1M this year, $900K next year, $150K per year after that, &lt;em&gt;until the end of time&lt;/em&gt; .&lt;/p&gt;
&lt;p&gt;With an infinite stream of payments, what does ROI mean?  You have
to do ROI on a year-by-year, or release-by-release basis.  That's much more
rational than asking your vendors like me to make up an &amp;quot;overall&amp;quot;
price.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-it-might-play-out"&gt;
&lt;h2&gt;How It Might Play Out&lt;/h2&gt;
&lt;p&gt;If there's a 10% chance that you won't get
things converted by July of next year, then there's a possibility of loss.  You
could assign an expected value to this.  $1.5M spent, 10% of nothing to show for
it.  This is $150,000 loss.  But that puts you squarely into ROI-world, where
you don't want to be.&lt;/p&gt;
&lt;p&gt;If there's a 90% chance of success and better
software, you could try and put a dollar value on this.  Except, of course, you
will probably deliver incrementally, and you'll have some return very early,
with accelerating returns after each release.  And the &amp;quot;potential&amp;quot; returns are
imponderable.  What to do?&lt;/p&gt;
&lt;p&gt;The only thing you can do, is avoid talking
about loss and anything that looks like loss.  Don't lie, but don't dwell.  Yes,
there's a chance of failure, but it's small and it isn't random -- it's bad
management.  Yes, we'll be discarding some old software, but the new software
will allow [X], [Y] and [Z] which the old software didn't
allow.&lt;/p&gt;
&lt;p&gt;Note the discarding of &amp;quot;some&amp;quot; old software.  In many cases, you will
discard &lt;em&gt;all&lt;/em&gt;
old software.  However, because of our hard-wired economic bias, discarding old
software is a loss, and we cannot tolerate loss.  Generally, when you are
reworking old software, you will preserve the data, and many of the concepts.
That's what's important, and that's what you can dwell on.&lt;/p&gt;
&lt;p&gt;Say:  &amp;quot;We're not
reinventing the wheel.&amp;quot; Even when you are going to delete the old
code.&lt;/p&gt;
&lt;p&gt;Say:  &amp;quot;We're preserving all the old data.&amp;quot; Even when you have to
completely restructure it from the non-relational to the relational
database.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It isn't IT managers (or managers in general)
who can't make rational technology decisions.  The natural human tendency is to
inflate losses and discount gains.  The only way to avoid the comparison problem
is to keep the losses (and possibilities of losses) widely separated from the
anticipated gains.&lt;/p&gt;
&lt;p&gt;All of the project failures that I've ever seen
in 30 years of IT have been management problems.  Most are related to a
fundamental unwillingness recognize that early phases of analysis (and
architecture) are done in discovery mode.  Learning something new during
analysis should not be labeled as scope creep, and is not cause for cancelling
the project.&lt;/p&gt;
&lt;p&gt;Additionally, managers who want to grandfather in old
software because it looks &amp;quot;cheaper&amp;quot; or &amp;quot;simpler&amp;quot; are usually wrong.  They are
also unaware of their own human bias toward preventing loss.  They think their
being rational, even-handed and skillful.  Actually, they're just wrong about
the cost (and benefit) of moving forward.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="ROI"></category><category term="Preventing Loss"></category><category term="CYA"></category><category term="Risk"></category></entry><entry><title>Maintenance and New Development</title><link href="https://slott56.github.io/2007_06_14-maintenance_and_new_development.html" rel="alternate"></link><published>2007-06-14T13:23:00-04:00</published><updated>2007-06-14T13:23:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-06-14:/2007_06_14-maintenance_and_new_development.html</id><summary type="html">&lt;p&gt;I read recently a quick note on a &lt;a class="reference external" href="http://blog.vrplumber.com/1870"&gt;Very productive day&lt;/a&gt; .  New development feels more productive than maintenance because it's more &amp;quot;linear&amp;quot;; it sounds like that means fewer dead-ends, less exploration.&lt;/p&gt;
&lt;p&gt;I also read recently &amp;quot;&lt;a class="reference external" href="http://www.scottberkun.com/blog/2007/how-to-innovate-on-time/"&gt;How to innovate on time&lt;/a&gt; &amp;quot; where the trick is to increase your failure rate.  In …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I read recently a quick note on a &lt;a class="reference external" href="http://blog.vrplumber.com/1870"&gt;Very productive day&lt;/a&gt; .  New development feels more productive than maintenance because it's more &amp;quot;linear&amp;quot;; it sounds like that means fewer dead-ends, less exploration.&lt;/p&gt;
&lt;p&gt;I also read recently &amp;quot;&lt;a class="reference external" href="http://www.scottberkun.com/blog/2007/how-to-innovate-on-time/"&gt;How to innovate on time&lt;/a&gt; &amp;quot; where the trick is to increase your failure rate.  In short, explore more dead-ends to find an innovation in a bounded time period.&lt;/p&gt;
&lt;p&gt;So encountering fewer dead-ends feels more productive, but encountering more dead-ends is more innovative?  This superficial contradiction of dead-ends bad/good means that I've missed something.&lt;/p&gt;
&lt;p&gt;I think that it isn't the simplistic linearity of work that makes for a productive day.  I think it's the internal vs. external drivers that make for a more productive-feeling day.&lt;/p&gt;
&lt;p&gt;I think that a productive day is a day that includes a great deal of innovation, some failures and rework.  But the failures are ones we could anticipate, and feel good about exploring alternatives.  The failures aren't actual dead-ends where we don't know what to do next.&lt;/p&gt;
&lt;p&gt;An unproductive day is where we find blockages that we didn't anticipate and can't easily see any way around.  An unproductive day is where we find that external events have piled up to create obstacles.&lt;/p&gt;
&lt;div class="section" id="spectrum"&gt;
&lt;h2&gt;Spectrum&lt;/h2&gt;
&lt;p&gt;So this is the spectrum that I think I see.&lt;/p&gt;
&lt;p&gt;Innovation.  Time to explore alternatives through failure and rework.  Boundaries that can be seen, challenges that can be anticipated.  Characterized by &amp;quot;OK, keep trying.&amp;quot;&lt;/p&gt;
&lt;p&gt;Productivity.  Boundaries that can be seen, challenges that can be anticipated.  Time is constrained, so there isn't so much failure and rework of alternative solutions.  Characterized by &amp;quot;That worked, what's next?&amp;quot;&lt;/p&gt;
&lt;p&gt;Low-Productivity.  Vague boundaries that must be discovered; challenges that can't be anticipated.  Failures turn into dead-ends where there aren't any obvious alternatives.  Characterized by &amp;quot;That didn't work either, let me think about this for a while.&amp;quot;&lt;/p&gt;
&lt;p&gt;Soul-Crushing Evil.  Boundaries are announced dynamically and change with the political climate.  Failures and rework appear random.  Characterized by &amp;quot;You should have known they wouldn't accept that solution; it doesn't matter how well it works.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="consequences"&gt;
&lt;h2&gt;Consequences&lt;/h2&gt;
&lt;p&gt;We'd all like to innovate.  How do we get there?&lt;/p&gt;
&lt;p&gt;Stepping up from productive to innovative looks like a matter of self-direction.  It's innovative if you explore more alternatives and endure more failure and rework.  If you're already in a productive environment, you can take the next step without too many obstacles.&lt;/p&gt;
&lt;p&gt;If we're in a low-productivity environment, how do we increase our pace of exploration?  I think the ticket is to more firmly characterize the boundaries and constraints.  I also think that some maintenance isn't worth the time and effort.&lt;/p&gt;
&lt;p&gt;If we're in soul-crushing evil, we have to prevent dead-ends from appearing out of thin air.  It might help to document the boundaries and constraints.  Sometimes this is a personality issue, and the dead-ends are appearing because someone needs to exercise control by creating dead-ends and obstacles.  This isn't technical, so I can't do much more than recognize the situation and hope it will go away.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-value-of-maintenance"&gt;
&lt;h2&gt;The Value of Maintenance&lt;/h2&gt;
&lt;p&gt;If maintenance feels low productivity, perhaps it is.  Perhaps doing maintenance on software doesn't really create enough value.&lt;/p&gt;
&lt;p&gt;Some maintenance is bug-fixing.  And some bug-fixing is necessary.  We didn't construct the right suite of unit tests, so we don't really have a proper design, and we need to fix it.&lt;/p&gt;
&lt;p&gt;Some maintenance, however, is really adaptation to new requirements.  This is where the line needs to get drawn.  In some cases, we can probably write new software more quickly and with higher quality than we can adapt or adjust existing software.&lt;/p&gt;
&lt;p&gt;Let's say we have an application that needs expansion in some area.  We need to understand the interface to that area.  This may include coming to grips with file formats, RDBMS structures, API calls, object definitions, packages of classes, XML messages: all kinds of software architectural features.  Once we've got the interface, we've literally only scratched the surface.  We then need to explore all of the internals to make the enhancement.&lt;/p&gt;
&lt;p&gt;But, if the internals need to be enhanced, how valuable are they?  Are a component's internals ever worth preserving?&lt;/p&gt;
&lt;p&gt;Clearly, there's a enhance-vs.-replace decision to be made.  Just as clearly, many managers are uncomfortable with replace.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="why-not-replace"&gt;
&lt;h2&gt;Why Not Replace?&lt;/h2&gt;
&lt;p&gt;Replacing software is scary for the standard pair of reasons: it appears to introduce cost and risk.&lt;/p&gt;
&lt;p&gt;Replacing software appears costly because it's new development, and we all know that new development is more expensive than enhancement.  Anyway, that's the standard management response.&lt;/p&gt;
&lt;p&gt;Replacing software appears risky because there are so many unknowns.  Except -- of course -- in this case where the interface is essentially fixed, the technology is fixed, and the requirements are easy to define based on existing functionality and the desired enhancements.&lt;/p&gt;
&lt;p&gt;I think we can all be more productive if we can just convince managers that we can build a replacement before we've even finished the analysis required to do maintenance.  Certainly, there's no risk in a replacement.&lt;/p&gt;
&lt;p&gt;It's hard to get permission for this kind of thing.  What it takes is forgiveness.  Each maintenance task needs to be examined critically.  Eventually, you'll find t situation where it's clear to you that new development is obviously cheaper.  Make the business case, get shot down, then do it anyway.  Choose your battles wisely and it becomes &amp;quot;out of the box thinking&amp;quot; not &amp;quot;insubordination.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="maintenance"></category><category term="planning"></category><category term="innovation"></category><category term="productivity"></category></entry><entry><title>Python and Reverse Engineering, Part 5</title><link href="https://slott56.github.io/2007_04_30-python_and_reverse_engineering_part_5.html" rel="alternate"></link><published>2007-04-30T13:25:00-04:00</published><updated>2007-04-30T13:25:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-04-30:/2007_04_30-python_and_reverse_engineering_part_5.html</id><summary type="html">&lt;p&gt;Python is a top-shelf toolset for creating sample
data to do performance testing.&lt;/p&gt;
&lt;p&gt;Let's
say that you need to validate a data warehouse design, and you need a million
facts that join with thousands of dimension entities across a half-dozen
dimensions.  You'll be generating data for seven different tables, and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Python is a top-shelf toolset for creating sample
data to do performance testing.&lt;/p&gt;
&lt;p&gt;Let's
say that you need to validate a data warehouse design, and you need a million
facts that join with thousands of dimension entities across a half-dozen
dimensions.  You'll be generating data for seven different tables, and the data
must have all of the relational integrity in
place.&lt;/p&gt;
&lt;p&gt;This technique applies to
transactional applications, also.  In the case of transactional data, the volume
is lower, and the referential integrity issues are more complex.  The underlying
architecture for doing the necessary testing, however, doesn't
change.&lt;/p&gt;
&lt;p&gt;What we wind up creating is the
following kind of architecture:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The Data Model.  This is one or more
Python modules which embody the various tables.  The &lt;a class="reference external" href="http://www.djangoproject.com/"&gt;Django&lt;/a&gt;  or
&lt;a class="reference external" href="http://www.sqlalchemy.org/"&gt;SQLAlchemy&lt;/a&gt;   object-relational mapping (ORM) are
big helps here.  We'll return to the value of ORM below.&lt;/li&gt;
&lt;li&gt;An ETL-like data loader.  This will
generate &amp;quot;random&amp;quot; data that has the appropriate volume and relationships.  This
is your Mock Data generator.&lt;/li&gt;
&lt;li&gt;Reporting.  This will do SQL queries to
retrieve the target reports from the warehouse.  This is your Mock Application.
If you are doing transactional applications, this will be more than simple SQL
queries:  it will be representative
transactions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;The Data Model.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An ORM-supported data model
is essential to successfully creating mock data.  Here's
why.&lt;/p&gt;
&lt;p&gt;First, if we design in SQL (using
CREATE TABLE statements) or their equivalent Entity-Relationship Diagram (ERD)
constructs, we often miss essential features of the problem.  It helps to design
in objects, with proper relationships, independent of the limitations of the
relational model.  Too often, the foreign-key relationship restrictions lead us
to create a design that reflects the technology, not the
requirements.&lt;/p&gt;
&lt;p&gt;Yes, the final
implementation will have to live with these limitations.  No, don't start with
those limitations in mind.  Start with the real problem in mind, and adjust the
implementation as needed.&lt;/p&gt;
&lt;p&gt;Second, if we
have a tool that maps objects to SQL-based RDBMS, we can prototype the solution
quickly and simply.  It is very freeing to make changes to a data model, loader
and queries in one language, like Python, which is tied to the business
problem.&lt;/p&gt;
&lt;p&gt;Yes, the final implementation
will be in vendor-specific SQL.  No, don't start with Oracle or DB2 or MySQL.
Start with a Python object model that reflects the real problem, and get the
model correct.  Not good enough to hack together some software, but reasonably
complete, consistent and clear.  This takes about as long to do in Python as it
does to draw endless E-R diagrams.  And, the Python actually works, where the
diagrams are merely the starting point for conversations with
programmers.&lt;/p&gt;
&lt;p&gt;Third, we can use our ORM
tool to -- trivially -- build loads, reports (and transactions.)  These model
(or prototype or proof-of-concept) applications can be thrown together very
quickly.  We can tweak this model by adding or changing indexes, doing
statistics gathering, etc.  We can also explore the numerous design alternatives
before we invest large piles of money based on paper diagrams with no real
quantitative science to back them
up.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock ETL.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given a data model, defined in
SQLAlchemy's notation or Django's model, we can work up loads relatively simply.
There are a few considerations that make load programs easier to
write.&lt;/p&gt;
&lt;p&gt;First, it is simpler to create
in-memory dimensional entities, and then persist these to the database.  We can
create simple Python collections (lists or dictionaries) of the independent
entities.  These are saved to the database, but also used to create the
dependent entities and the facts.&lt;/p&gt;
&lt;p&gt;In
the case of a data warehouse, the dimensions are independent of each other.  In
many cases, a dimension will be an exhaustive enumeration of combinations of
attribute values, meaning that the test data dimension will likely
&lt;strong&gt;be&lt;/strong&gt;  the
production set of values.  All of the dimension entities (except for
&amp;quot;snowflaked&amp;quot; dimensions like Customers) can be fit into simple in-memory
collections (like dictionaries) with few
problems.&lt;/p&gt;
&lt;p&gt;Here are a few tables from a
sample dimensional model.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
from django.db import models

class StudentPopulation(models.Model):
    ethnicity = models.CharField(maxlength=30)
    disability = models.CharField(maxlength=30)
    gender = models.CharField(maxlength=8)
    giftedAndTalented = models.CharField(maxlength=30)
    class Admin:
        pass
    def __str__( self ):
        return &amp;quot;%s %s %s %s&amp;quot; % (
            self.ethnicity, self.disability, self.gender,
            self.giftedAndTalented, )

class Date(models.Model):
    year = models.PositiveIntegerField()
    month = models.PositiveSmallIntegerField()
    day= models.PositiveSmallIntegerField()
    class Admin:
        pass
    def __str__( self ):
        return &amp;quot;%s/%s/%d&amp;quot; % ( self.year, self.month, self.day )

class Student( models.Model ):
    studentId = models.CharField(maxlength=10)
    ssn= models.CharField(maxlength=10)
    lastName = models.CharField(maxlength=30)
    firstName = models.CharField(maxlength=30)
    middleName = models.CharField(maxlength=30,null=True)
    suffix = models.CharField(maxlength=30,null=True)
    birthDate = models.ForeignKey(Date,null=True)
    demographic= models.ForeignKey(StudentPopulation,null=True)
    class Admin:
        pass
    def __str__( self ):
        return &amp;quot;%s, %s %s (%s)&amp;quot; % ( self.lastName, self.firstName,
            self.middleName, self.studentId )
&lt;/pre&gt;
&lt;p&gt;Here is a sample load script which
shows how these dimensions can be populated.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
from dimension.models import *
from loadstar import *

def loadStudentPopulations():
    for eth in ('white', 'asian', 'black', 'other', ):
        for dis in ( '', 'mental', 'physical', ):
            for gen in ( 'male', 'female', ):
                for gat in ( '', 'G&amp;amp;T;', ):
                    pop= StudentPopulation.objects.get_or_create(
                        ethnicity= eth, disability= dis, gender= gen,
                        giftedAndTalented= gat )

def loadDates():
    loadDate= Date.objects.get_or_create( year=2006, month=7, day=14 )[0]

&amp;#64;requires(loadStudentPopulations)
def loadStudents():
    populations= StudentPopulation.objects.all()
    for i in range( 50 ):
        pop= random.choice( populations )
        bd= Date.objects.get_or_create( year= 1990, month= i%12+1, day= i%30+1 )[0]
        try:
            stu= Student.objects.get( stateStudentId= str(i) )
        except:
            stu= Student( stateStudentId= str(i),
                ssn= (str(i)*9)[:9],
                lastName= 'Student%d' % ( i, ),
                firstName= 'First%d' % ( i, ),
                birthDate= bd,
                demographic= pop,
                )
            stu.save()
&lt;/pre&gt;
&lt;p&gt;This load uses a mixture of
techniques.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;For the StudentPopulation dimension, it
enumerates all possible combinations of attribute vales.&lt;/li&gt;
&lt;li&gt;For Date, we only load a single date;
other dates will be built during fact loading.&lt;/li&gt;
&lt;li&gt;For Student, we create a Date, which is
conformed to the Date dimension.  We also select a StudentPopulation from the
in-memory list of population
objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;More Complex Loading.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Once we have the
independent entities populated, we can create dependent entities.  These include
bridge tables and facts.  Bridge tables often fit into memory, since they are
typically of the same cardinality as a given dimension.  However, a fact table
may be quite large, and may not conveniently reside in memory during data
generation.&lt;/p&gt;
&lt;p&gt;In the case of snowflaked
dimensions, we have to generate these large dimensions before generating the
relevant facts.  Often, there is a relatively simple relationship between a
large dimension (e.g. Customer) and the fact (e.g. Account Balance).  We can
often generate these in parallel, producing a Customer dimension row and a dozen
Fact rows which are then persisted in the
database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fact Loading.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a sample fact table
that we'd like to load.  This depends on the dimensions shown above, plus
several others.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
from django.db import models
from dwdemo.dimension.models import *

class TestScore( models.Model ):
    student= models.ForeignKey( Student )
    demographic= models.ForeignKey( StudentPopulation )
    date= models.ForeignKey( Date )
    school= models.ForeignKey( School )
    grade= models.ForeignKey( GradeLevel )
    subject= models.ForeignKey( Subject )
    test= models.ForeignKey( Test )
    scoreType= models.CharField(maxlength=30)
    scoreRaw= models.FloatField(max_digits=5, decimal_places=2)
    scoreNorm= models.FloatField(max_digits=5, decimal_places=2)
    profLevel= models.FloatField(max_digits=5, decimal_places=2)
    ranking= models.CharField(maxlength=30)
    class Admin:
        pass
    def __str__( self ):
        return &amp;quot;%s = %s %f&amp;quot; % ( self.student, self.scoreType, self.scoreRaw )
&lt;/pre&gt;
&lt;p&gt;Here's a load procedure to populate
facts based on the dimensional model in place.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import random

from dimension.models import *
from testscore.models import *

for score in TestScore.objects.all():
    score.delete()

loadDate= Date.objects.get_or_create( year=2006, month=7, day=14 )[0]

# Generate TestScore facts, conform and load
schools= School.objects.all()
grades= GradeLevel.objects.all()
tests= Test.objects.all()
subjects= Subject.objects.all()
for stu in Student.objects.all():
    # StudentPopulation derived from Student
    stuPop= stu.demographic
    # School, GradeLevel, Subject and Test
    sch= random.choice( schools )
    gr= random.choice( grades )
    sub= random.choice( subjects )
    test= random.choice( tests )
    # random entry events for all students
    fact= TestScore(
        student= stu, demographic= stuPop, condition= stuCond,
        date= loadDate, school= sch, grade=gr, subject= sub,
        test= test,
        scoreType= &amp;quot;1-100&amp;quot;, scoreRaw= random.randint( 50,100 ),
        scoreNorm= random.random(),
        profLevel= 70,
        ranking= (&amp;quot;Top&amp;quot;, &amp;quot;Third&amp;quot;, &amp;quot;Second&amp;quot;, &amp;quot;Bottom&amp;quot;)[stu.id%4],
    )
    print fact
    fact.save()
&lt;/pre&gt;
&lt;p&gt;Once we have the model, and the mock
data, we can now determine how well we can produce the required reports.
Additionally, we can experiment with ETL processing in the cases where our
source data don't fit the dimensional model very well.  Since we have sample
data, and a database, we can do meaningful comparisons between
designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mock Application.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For data warehousing,
the Mock Applications are simple: they are the queries that comprise the
warehouse.  Here's an example.  In this case, we bypass the ORM part of Django,
and execute SQL directly to better reflect the final implementation via a
SQL-centric reporting package.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
from django.db import connection
tests= connection.cursor()
tests.execute( &amp;quot;&amp;quot;&amp;quot;SELECT testName FROM dimension_test&amp;quot;&amp;quot;&amp;quot; )
for test in tests.fetchall():
    print test
    subjects= connection.cursor()
    subjects.execute( &amp;quot;&amp;quot;&amp;quot;SELECT subjectName FROM dimension_subject&amp;quot;&amp;quot;&amp;quot; )
    for sub in subjects.fetchall():
        print ' subject:', sub
        grades= connection.cursor()
        grades.execute( &amp;quot;&amp;quot;&amp;quot;SELECT grade FROM dimension_gradelevel&amp;quot;&amp;quot;&amp;quot; )
        for gr in grades.fetchall():
            print '  grade:', gr
            ranks= connection.cursor()
            ranks.execute( &amp;quot;&amp;quot;&amp;quot;SELECT DISTINCT ranking, count(*)
            FROM testscore_testscore tst, dimension_date dt,
            dimension_gradelevel gr, dimension_subject sub, dimension_test test
            WHERE tst.date_id=dt.id AND dt.year='2006'
            AND tst.grade_id=gr.id AND gr.grade=%s
            AND tst.subject_id=sub.id AND sub.subjectName=%s
            AND tst.test_id=test.id AND test.testName=%s
            GROUP BY tst.ranking
            &amp;quot;&amp;quot;&amp;quot;, [gr[0], sub[0], test[0]] )
            for name,count in ranks.fetchall():
                print '   ', name, count
        print
        grades.close()
    subjects.close()
tests.close()
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Consequences.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The
most important consequence is a concrete performance model with a full-sized set
of data.  This can be used on a desktop to explore design alternatives.  The
generated data sets can be used to populate a development database and explore
implementation alternatives (bit-mapped index vs. tree index, statistics
gathering, etc.)&lt;/p&gt;
&lt;p&gt;Since the experiments
are concrete and specific, the design will be more robust than a paper model
drawn out as an ERD.  Any programming discussions can be resolved by looking at
the Mock Objects to see what the intent was behind a particular construct or
technique.&lt;/p&gt;
&lt;p&gt;Finally, alternatives can
explored rapidly and inexpensively.  Once a design performs well with this mock
environment, we have reason for confidence in the final production
implementation.&lt;/p&gt;
</content><category term="Management"></category><category term="reverse engineering"></category><category term="database"></category><category term="ETL"></category></entry><entry><title>Python and Reverse Engineering, Part 4</title><link href="https://slott56.github.io/2007_04_18-python_and_reverse_engineering_part_4.html" rel="alternate"></link><published>2007-04-18T15:47:00-04:00</published><updated>2007-04-18T15:47:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-04-18:/2007_04_18-python_and_reverse_engineering_part_4.html</id><summary type="html">&lt;p&gt;At this point, we have
clex.py, which
uses
sqlpreproc.py
to create a proper lexer for C source code.  We use &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;  's ANSI C
parser
(cparse.py) as
the backbone of our own analysis of
C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The C Language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Separate from the lexical
structure of C (the spelling …&lt;/p&gt;</summary><content type="html">&lt;p&gt;At this point, we have
clex.py, which
uses
sqlpreproc.py
to create a proper lexer for C source code.  We use &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;  's ANSI C
parser
(cparse.py) as
the backbone of our own analysis of
C.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The C Language.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Separate from the lexical
structure of C (the spelling and punctuation part) and separate from the
semantic structure of C (what it does at run-time), there's a syntactic
structure of C.  These are the constructs we &amp;quot;mean&amp;quot; when we write C source;
these constructs have a structure at compile time, which generates behavior at
run time.&lt;/p&gt;
&lt;p&gt;Principally, a C source file
is a series of declarations.  We declare variables and functions.  One of those
functions,
main, is
special.&lt;/p&gt;
&lt;p&gt;To model this, we'll define a
module,
language, which
has class definitions for various syntax structures.  We'll use this language
module in our ANSI C parser
(cparse) to
build useful objects that we can use for reporting and
analysis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Declaration.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a simplistic
superclass for the family tree of C declarations.  This covers just enough
structure to capture the essence of the declaration.  We're not compiling,
merely analyzing.&lt;/p&gt;
&lt;p&gt;Since PLY makes it so
easy to simply use tuples, many of the syntax rules will create normalized
tuples with
None filling in
for missing or optional elements of the language.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class Declaration( object ):
    &amp;quot;&amp;quot;&amp;quot;Built from a 3-tuple: ( 'decl', type, declList )&amp;quot;&amp;quot;&amp;quot;
    def __init__( self, typeSpec, declList ):
        self.typeSpec= typeSpec
        self.declList= declList
        self.body= [] # Empty = not a function declaration
        if self.declList == None: return
        for d in self.declList:
            if d[0] == '=':
                # 3-tuple: ( '=', decl, init )
                # analyze this declaration to get the variable name
                # analyze the initializer to locate function calls
                _, decl, init = d
                # Dig into the initializer and build an Expression.instance
                _, initBody= init
            elif d[0] == 'decl':
                # analyze this declaration to get the variable name
                decl= d
                init= None
            else:
                raise Exception( decl )
            # decl is 3-tuple( 'decl', pointer, directDecl )
            # init is 2-tuple( 'init', expr )
    def __str__( self ):
        return &amp;quot;%s %s&amp;quot; % ( self.typeSpec, self.declList )
    def symbol( self ):
        return None
    def references( self ):
        # TODO: initializers can involve function calls!
        # However, in C they have to be &amp;quot;constant&amp;quot; expressions which can be evaluated
        # at compile time, so the cross-references are rarely very interesting.
        # In C++ (and Java) they aren't restricted in this way.
        return []
&lt;/pre&gt;
&lt;p&gt;Within
cparse, we use
this as follows.  We'll extend the
p_external_declaration_2
rule with a call to build a Declaration from the
syntax accumulated in the parser state tuple,
t.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import language as C

def p_external_declaration_2(t):
    'external_declaration : declaration'
    #print 'declaration', t[1]
    t[0]= C.Declaration( *t[1] )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The Function Declaration.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Really, we're
interested in function declarations more than variables or references.  A
function declaration is a subclass of declaration that introduces some
additional details, like a body, and some analysis
methods.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class Function( Declaration ):
    &amp;quot;&amp;quot;&amp;quot;built from 5-tuple: ( 'def', specifiers, declarator, declaration_list, statement )&amp;quot;&amp;quot;&amp;quot;
    def __init__( self, defStr, declaration_specifiers, declarator, declaration_list, compound_statement ):
        self.spec= declaration_specifiers
        _, self.ptr, direct_declarator = declarator
        if direct_declarator[0] == 'ddecl()':
            # New-style function declaration
            _, direct_declarator, self.args = direct_declarator
            _, self.name= direct_declarator
        else:
            self.name= declarator # actually a TUPLE of stuff
            self.args= declaration_list
        self.defs= compound_statement.decl
        self.body= compound_statement.body
    def __str__( self ):
        if self.defs:
            defsTxt=&amp;quot;;\n&amp;quot;.join( map( str, self.defs ) )
        else:
            defsTxt=&amp;quot;&amp;quot;
        bodyTxt= &amp;quot;;\n&amp;quot;.join( map( str, self.body ) )
        return &amp;quot;def %s %s (%s) {\n%s\n%s\n}&amp;quot; % (
            self.spec, self.name, self.args, defsTxt, bodyTxt )
    def symbol( self ):
        return self.name
    def references( self ):
        # TODO: The declarations in self.defs could involve function calls!
        refs= set()
        for stmt in self.body:
            #print &amp;quot; &amp;quot;, stmt
            refNames= [ r[1] for r in stmt.references() ]
            refs |= set(refNames)
        return refs
&lt;/pre&gt;
&lt;p&gt;Within
cparse, we use
this as follows.  We'll extend the
p_external_declaration_1
rule with a call to build a Function from the
syntax accumulated in the parser state tuple,
t.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import language as C

def p_external_declaration_1(t):
    'external_declaration : function_definition'
    t[0]= C.Function( *t[1] )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Expressions.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The
body of a function declaration is a sequence of statements.  A statement either
is an expression, or contains expressions.  The expression is the lowest-level
unit of grammar that we're interested in.  Here's a declaration for an
Expression class to support analysis of expressions in
C.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class Expression( object ):
    def __init__( self, tree ):
        self.tree= tree
    def __str__( self ):
        return str( self.tree )
    def refsList( self ):
        # any calls? must dig recursively into the expression's syntax tree
        return self.walkTree( self.tree )
    def walkTree( self, aTree ):
        refs= []
        if isinstance(aTree,tuple) and aTree[0] == 'call':
            # AHA! - a function call
            refs.append( aTree )
        # Even if we found a call, descend into the arguments, also.
        if isinstance(aTree,tuple):
            for subExpr in aTree[1:]:
                if subExpr and isinstance(subExpr,tuple):
                    sub= self.walkTree( subExpr )
                    if sub: refs.extend( sub )
        return refs
&lt;/pre&gt;
&lt;p&gt;While this could be used in
cparse as each
expression is parsed, we're too lazy to do that properly.  Instead, we'll build
expressions as part of assembling each Statement.  The idea is to build a small
syntax tree with only the parts we're going to analyze, ignoring numerous other
details of the C
language.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Statements&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;C
has a large number of statement types.  We won't dig into each type, but will
show a few representative types and how they are built by our
parser.&lt;/p&gt;
&lt;p&gt;The Statement superclass has
the following definition.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class Statement( object ):
    def __init__( self, tree ):
        self.tree= tree
    def __str__( self ):
        return str( self.tree )
    def references( self ):
        # any calls? must dig recursively into the statement's syntax tree
        raise NotImplementedError( repr(self.tree) )
&lt;/pre&gt;
&lt;p&gt;When we recognize a statement in the
parser, we use the following factory function to map the syntax into a useful
subclass of Statement.  The global
stmtFactory
dictionary isn't complete, but it handles the statements in the 10,000 lines of
source we're analyzing.  Whenever we fail to find an appropriate subclass of
Statement, we use the superclass, which (eventually) throws a
NotImplementedError,
and we can then define the needed Statement
subclass.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
stmtFactory = {
'{': CompoundStatement,
'return': Return,
'for': For,
'while': While,
'do': While, # Same structure, different semantics
'if': If,
'switch': Switch,
'case': Case,
'default': Default,
'break': Empty,
'continue': Empty,
'goto': Empty,
'cast': Cast,
'call': Call,
'+=': Assignment,
'-=': Assignment,
'=': Assignment,
'--': IncDec,
'++': IncDec,
'expr': ExprStmt,
}

def makeStatement( *args ):
    # Factory for subclasses of Statement
    try:
        cn= stmtFactory.setdefault( args[0], Statement )
        return cn( args )
    except TypeError, e:
        import sys, traceback
        print &amp;quot;***&amp;quot;
        print e
        print repr(tree)
        raise
&lt;/pre&gt;
&lt;p&gt;Here's are two typical
cparse rules
for recognizing statements and using
makeStatement
to create a Statement
instance.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# iteration_statement:
def p_iteration_statement_2(t):
    'iteration_statement : FOR LPAREN expression_opt SEMI expression_opt SEMI expression_opt RPAREN statement '
    t[0]= C.makeStatement( 'for', (t[3], t[5], t[7]), t[9] )

# expression-statement:
def p_expression_statement(t):
    'expression_statement : expression_opt SEMI'
    t[0]= C.makeStatement( 'expr', t[1] )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Statement Subclasses.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Rather than present all
of the subclasses of Statement, here are two that match the
iteration_statement
and
expression_statement
syntax categories.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class For( Statement ):
    def __init__( self, tree ):
        super( For, self ).__init__( tree )
        _, exprTuple, self.body = self.tree
        ex1, ex2, ex3 = exprTuple
        self.ex1= Expression( ex1 )
        self.ex2= Expression( ex2 )
        self.ex3= Expression( ex3 )
    def references( self ):
        refs= self.ex1.refsList() + self.ex2.refsList() + self.ex3.refsList()
        refs.extend( self.body.references() )
        return refs

class ExprStmt( Statement ):
    def __init__( self, tree ):
        super( ExprStmt, self ).__init__( tree )
        _, expr= self.tree
        self.expr= Expression( expr )
    def references( self ):
        return self.expr.refsList()
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;How It Fits.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a quick review of how
the whole process fits together.  Essentially, the main function is the parser,
inside
cparse.py.  The
parser is called
yacc.parse, and
is built secretly when
cparse is
imported.  The parser consumes a sequence of tokens, produced by the lexer.
When the parser recognizes a specific syntax construct, it executes the body of
a function which is tied to that syntax rule.  This function may create a
Declaration, a Function or a call c.makeStatement to create an appropriate
subclass of Statement.  Some parser functions accumulate tuples of other syntax
elements, saving them until the higher-level constructs get
created.&lt;/p&gt;
&lt;p&gt;The lexer,
clex, is used
by the parser to break C language source into individual tokens: keywords,
identifiers, punctuation marks.  The lexer, in turn, relies on
sqlpreproc to
handle the embedded SQL and CPP constructs mashed into the C source
code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Analytical Programs.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's an analytical
program which examines the C source files the client gave us.  Note the
extension to the typedef handling described in &lt;a class="reference external" href="https://slott56.github.io/2007_04_17-python_and_reverse_engineering_part_3.html"&gt;Part 3&lt;/a&gt; .  As the parser trips over typedefs, we
accumulate the list manually, rather than correctly hand new type names from
parser to lexer.  The
parse function
parses a single file, and returns the sequence of declarations (the syntax tree)
in that file.   The
analyzeDefCall
function examines each declaration looking for function definitions and function
calls.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;&amp;quot;&amp;quot;Parse and Analyze the legacy source.&amp;quot;&amp;quot;&amp;quot;

import clex
import cparse
import sqlpreproc
import language

import pprint, os.path

# HACK: rather than examine typedef statements, we simply force the type names
# into the lexical scanner.
clex.typedefs.extend( [ 'AccountType', 'PaymentType', 'SettleType',
    'LogLevel', 'Condition', 'MethodType', 'ConditionPtr',
    'VISIT',
    'Parameter', # subtle issue here--- this is a typedef in the .c file :-(
    'DocCombo',
    'InvoiceType', 'ModeType', 'StatusType', 'FlagType'
] )

def parse(fileName,debug=0):
    source= file(fileName,&amp;quot;r&amp;quot;).read()
    makeFlags=['DYNAMICSQL','REREAD','SUB_COMMIT','MACRO_LOCK','MATCH_PATH']
    headerDefs=['USE_HIGHEST','PARAMETER_FILE']
    sqlText, statements = sqlpreproc.sqlpreproc(source)
    cppText, definitions = sqlpreproc.cpp(sqlText,set(headerDefs+makeFlags))
    print &amp;quot;SQL: &amp;quot;, len(statements)
    pprint.pprint( statements )
    tree= cparse.yacc.parse(cppText, debug=debug )
    return tree

def analyzeDefCall( tree ):
    print &amp;quot;----Analysis----&amp;quot;
    symbols= {}
    for decl in tree:
        if decl.symbol():
            symbols[decl.symbol()]= decl
    pprint.pprint( symbols )
    print &amp;quot;XREF&amp;quot;
    for decl in tree:
        if decl.body:
            print &amp;quot;%s\t%s&amp;quot; % ( decl.name, &amp;quot;\t&amp;quot;.join(decl.references()) )
        else:
            print &amp;quot;Calls in&amp;quot;, decl

def analyzeSource( dir, debug=0 ):
    import glob
    files= glob.glob(os.path.join(dir,'*.c'))
    for f in files:
        print
        print f
        tree= parse( f, debug )
        analyzeDefCall( tree )
&lt;/pre&gt;
&lt;p&gt;The
analyzeSource
function is the top-level main analysis function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Results.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We
know that there are 162 distinct functions defined.  We can, based on source
file and other hints, narrow this to about 93 functions that are truly relevant.
Within these functions, we can extract cross reference information that serves
as a checklist to be sure that each function is completely
analyzed.&lt;/p&gt;
&lt;p&gt;Additionally, we can
partition the function definitions into &amp;quot;primitive&amp;quot; and &amp;quot;moderate&amp;quot; and
&amp;quot;complex&amp;quot;.  About one third of the definitions appear to be primitive functions
that call two or fewer other functions, and seem to have a simple, clear
purpose.  Another third are complex functions that reference seven or more other
functions, and are difficult to characterize.  The remaining third of the
functions call between three and six other functions, and are of moderate
complexity.&lt;/p&gt;
&lt;p&gt;This analysis helps us
narrow our focus to about 20% of the function definitions (31 out of 162) which
seem to do all the work.  This is not a subjective evaluation, but is based on
simple scanning of the syntax using extremely powerful analytical tools.  Python
allows us to rapidly modify, extend and adapt these tools, producing useful,
relevant outputs with minimal effort.&lt;/p&gt;
</content><category term="Management"></category><category term="reverse engineering"></category><category term="C"></category><category term="compiler"></category></entry><entry><title>Python and Reverse Engineering, Part 3</title><link href="https://slott56.github.io/2007_04_17-python_and_reverse_engineering_part_3.html" rel="alternate"></link><published>2007-04-17T14:26:00-04:00</published><updated>2007-04-17T14:26:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-04-17:/2007_04_17-python_and_reverse_engineering_part_3.html</id><summary type="html">&lt;p&gt;The client said, &amp;quot;We have this program, largely
in C, which we can no longer support.  It doesn't really meet our business needs
and it doesn't fit our technology skill set.&amp;quot;  As part of rewriting the
requirements, the question of what it
&lt;em&gt;really&lt;/em&gt;
did came up.&lt;/p&gt;
&lt;p&gt;Actually, they had more …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The client said, &amp;quot;We have this program, largely
in C, which we can no longer support.  It doesn't really meet our business needs
and it doesn't fit our technology skill set.&amp;quot;  As part of rewriting the
requirements, the question of what it
&lt;em&gt;really&lt;/em&gt;
did came up.&lt;/p&gt;
&lt;p&gt;Actually, they had more to
say about the author's tendency toward &amp;quot;clever for the sake of being clever&amp;quot;,
and &amp;quot;intentionally obscure.&amp;quot;  Leaving the invective aside, they had a pile of C
and SQL.  What does it
&lt;em&gt;really&lt;/em&gt;
do?  How big is the conversion
effort?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What To Do?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Time to break out the Python
tools to see what we really had.  The good news is that C is relatively easy to
parse.  The &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;   package, for example, contains a basic ANSI
C lexical scanner and parser than can be adapted to the code base at
hand.&lt;/p&gt;
&lt;p&gt;The bad news is that the PLY
package doesn't help much with the C pre-processor (CPP) syntax.  We can,
clearly, just run the CPP on the code to get &amp;quot;pure&amp;quot; C, but we lose a little bit
of semantic richness when we do this.  Our alternative is to implement a quick
and dirty CPP-like processor to handle the
#ifdef
constructs.   Since we have the Makefile, we know which options are used and
which #ifdefs
are relevant.&lt;/p&gt;
&lt;p&gt;The other bad news is
that embedded SQL in C has yet another pre-processor.  The SQL precompiler runs
first; it creates SQL-free C code that is handled by the CPP and finally the C
compiler, itself.  This means that we are really dealing with 3 different
languages in a single source file: the embedded SQL language, the CPP language
and the C language.&lt;/p&gt;
&lt;p&gt;First, we'll look
at a simple side-issue in lexical scanning, the processing of new type names.
Then we can peer into the pre-processor problem and close the loop on lexical
scanning.  We'll look at parsing in another posting.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lexical Scanning.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We need to extend PLY's
lexical scanner to recognize
typedef names.
There are a number of alternatives here.  One choice is to relax the grammar
slightly, removing the distinction between type ID's and plain old ID's.
Another choice is to have the parser update the lexical scanner's list of type
ID's as
typedefs are
seen.&lt;/p&gt;
&lt;p&gt;Instead of these two choices,
which are appropriate for the more general problem, we can simply hard-code a
list of known typedef names, and hack this list into shape as we parse the
source.  This is limiting in some respects, but it is really quick and
appropriate for a one-time use tool.  It also saves us from having to dwell on
correctly parsing the
.h
files.&lt;/p&gt;
&lt;p&gt;There is a short list of
standard C typedefs
(size_t,
time_t,
sem_t,
ushort,
FILE,
va_list) which
are in common use.   Similarly, the SQL precompiler only introduces
varchar and
asciz.&lt;/p&gt;
&lt;p&gt;Here's
the revision to the
t_ID function
in
clex.py.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
typedefs = [
    'va_list', 'time_t', 'sem_t', 'FILE', 'size_t', 'ushort', # Standard C type names
    'varchar', 'asciz', # SQL precompiler type names
    ]

def t_ID(t):
    r'[A-Za-z_][\w_]*'
    if t.value in typedefs:
        t.type = &amp;quot;TYPEID&amp;quot;
    else:
        t.type = reserved_map.get(t.value,&amp;quot;ID&amp;quot;)
    return t
&lt;/pre&gt;
&lt;p&gt;Before we can talk about the rest of
clex, we need to digress on the precompiler issues.  We'll tackle the SQLPC
issues first.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL Precompiler.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;First, embedded SQL is
a foreign syntax mashed into our C program.  It has distinct lexical rules,
which apply only to the SQL blocks, not to the rest of the C program.  In
essence, we have to break the source text into two kinds of regions: SQL
regions, to which SQL syntax rules apply and host language regions (C, in this
case).&lt;/p&gt;
&lt;p&gt;Once we've identified a SQL
statement, we don't care about most of the SQL syntax.  Indeed, we only want to
identify &amp;quot;declarative&amp;quot; SQL statements, which leave no residue in the resulting
C.  The remaining SQL statements are imperative, and will typically include a
SQL statement that is central to the processing of the program, usually a DML
statement of some kind.&lt;/p&gt;
&lt;p&gt;To be specific,
a declarative statement like EXEC SQL INCLUDE
SQLCA; creates some well-known definitions, but
has no real impact on the resulting C program.  Similarly
EXEC SQL WHENEVER NOTFOUND
CONTINUE; adjusts the way C code is generated; it
declares some semantics, but doesn't change what we are measuring about the
resulting source text.&lt;/p&gt;
&lt;p&gt;On the other
hand, an imperative statement like EXEC SQL
UPDATE sometable SET...; is significant.  We need
to capture this statement, and also replace the embedded SQL text with valid C
source text.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Embedded SQL Patterns.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here are some regular
expressions for tracking down Embedded SQL in C.  These aren't actually
complete, but they work well enough to analyze a large pile of source.&lt;/p&gt;
&lt;p&gt;Note that we define the patterns as
sequences of ( token-name, pattern-text ) tuples.  Borrowing a technique from
PLY, we flatten this list of tuples into a single composite regular expression.
The list of tuples has pleasant, easy-to-read syntax.  The resulting RE isn't
too difficult to read, but is long-winded and
repetitive.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
top_level_REs = (
    ( 'p_comment', r'/\*(.|\n)*?\*/' ),
    ( 'p_exec1', r'EXEC\s+SQL\s+EXECUTE\s+BEGIN\s(.|\n)*?\sEND\s*;\s+END\-EXEC;[ \t]*' ),
    ( 'p_exec2', r'EXEC\s[^;]*?;[ \t]*' ),
    ( 'p_host', r'.|\n' ),
)
compositeRE= '|'.join( [ '(?P&amp;lt;%s&amp;gt;%s)' % pair for pair in top_level_REs ] )
patterns= re.compile( compositeRE, re.M|re.I )

sql_REs = (
    ( 'p_sqlInclude',r'^\s*EXEC\sSQL\s+INCLUDE' ),
    ( 'p_oracleOption', r'^^\s*EXEC\sORACLE\s+OPTION' ),
    ( 'p_sqlBegin', r'^\s*EXEC\sSQL\s+BEGIN' ),
    ( 'p_sqlEnd', r'^\s*EXEC\sSQL\s+END' ),
    ( 'p_sqlDeclare', r'^\s*EXEC\sSQL\s+DECLARE' ),
    ( 'p_sqlWhenever', r'^\s*EXEC\sSQL\s+WHENEVER' ),
    ( 'p_sqlType', r'^\s*EXEC\sSQL\s+TYPE' ),
)
compositeRE= '|'.join( [ '(?P&amp;lt;%s&amp;gt;%s)' % pair for pair in sql_REs ] )
sqlPatterns= re.compile( compositeRE, re.M|re.I )
&lt;/pre&gt;
&lt;p&gt;The
patterns
variable contains a compiled RE which will break the source into two kinds of
regions: SQL regions, which we can examine more closely, and host-language
regions which we pass on without making any changes.&lt;/p&gt;
&lt;p&gt;To bound the SQL regions, we have to
recognize two kinds of SQL statements.  In the source we were given, all
procedure calls are wrapped in formal
BEGIN-END
blocks, and have
END-EXEC
markers.  All other statements are in simple
EXEC SQL
statements, with no
END-EXEC
marker.&lt;/p&gt;
&lt;p&gt;The
sqlPatterns
variable contains a compiled RE which will make a
good guess at the kind of SQL statement.  In principle, we could include the
complete SQL language here, and actually parse the SQL.  Parsing the SQL is far
too complex for a quick overview of the code.  Instead, we treat the SQL as pure
text and hope it doesn't confuse our regular expression
patterns.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulating the SQL Precompiler.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a function
which simulate a few features of the SQL Precompiler.  This will return two
things: the host language text and a list of the embedded SQL
statements.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def quoteC( aString ):
    return aString.replace( '&amp;quot;', r'\&amp;quot;' ).replace( '\n', '' )

def sqlpreproc( text ):
    &amp;quot;&amp;quot;&amp;quot;Simulate a few features of the SQL pre-processor.&amp;quot;&amp;quot;&amp;quot;

    output= StringIO.StringIO(&amp;quot;&amp;quot;)
    sqlStatements= []
    match1= patterns.match(text)
    lineno= 1
    while match1:
        groups= match1.groupdict()
        #print groups
        if groups['p_comment']:
            # Comment is all host text, and may contain SQL, which is ignored.
            token= match1.group('p_comment')
            output.write( token )
        elif groups['p_host']:
            hostText= match1.group( 'p_host' )
            output.write( hostText )
        elif groups['p_exec1'] or groups['p_exec2']:
            # SQL statements interrupt host text
            sqlText= match1.group( 'p_exec1' ) or match1.group( 'p_exec2' )
            sqlTextStrip= sqlText.strip()
            sqlStatements.append( sqlTextStrip )
            if sqlPatterns.match( sqlTextStrip ):
                # comment only
                output.write( &amp;quot;/** %d: %r **/\n&amp;quot; % ( lineno, sqlTextStrip, ) )
            else:
                # place-holder function for syntactic completeness
                output.write( 'sql(%d, &amp;quot;%s&amp;quot;);\n' % ( lineno, quoteC(sqlTextStrip) ) )
        else:
            raise Exception(&amp;quot;whoops&amp;quot;)
        lineno += match1.group(0).count('\n')
        match1= patterns.search(text, match1.end())

    result= output.getvalue()
    output.close()
    return result, sqlStatements
&lt;/pre&gt;
&lt;p&gt;We replace imperative SQL statements
with a sql()
function call, just to preserve the original SQL text for further processing.
The declarative SQL statements are replaced with
comments.&lt;/p&gt;
&lt;p&gt;There are two potential gaps
with this technique.  Since we replace cursor declarations with a simple
comment, not a
sql() function call, the SQL source for the
SELECT
statement will tend to get lost.  Further, when SQL statements are built
dynamically and analyzed with EXEC SQL
PREPARE or EXEC
SQL DESCRIBE, we don't have any clear way of
analyzing source to determine the statement which gets
built.&lt;/p&gt;
&lt;p&gt;And yes, we do raise the
&lt;strong&gt;Whoops Exception&lt;/strong&gt; ™ in case we've done something
brain-dead like add a pattern without adding a clause to the if-statement to
handle that pattern.  This is an example of a design error that cannot be
detected until run-time; an interesting subject in it's own
right.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulating the C Preprocessor.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The C preprocessor
has it's own unique language which has two elements:  the preprocessor
statements, which begin with #, and the host-language statements, which are
everything else.  Similar to the SQL preprocessor, we can break the source into
two kinds of regions: #-statements and everything else.&lt;/p&gt;
&lt;p&gt;Generally, we only care about the
#ifdef and
#ifndef
statements, since these determine the subset of C source text which is actually
compiled.  This is not universally true, since an included file could contain --
well -- anything.   However, in the case of the source presented, the author was
very well-disciplined, and the
#include files
are purely declarative; we don't need expand them in their source
context.&lt;/p&gt;
&lt;p&gt;Here are some regular
expressions for tracking down CPP statements.  These aren't actually complete,
but they work well enough to analyze a large pile of source.  Specifically, we
recognize just enough of the
#define syntax
to get past some rather complex macro definitions.&lt;/p&gt;
&lt;p&gt;Note that we define the patterns as
sequences of ( token-name, pattern-text ) tuples.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cpp_REs = (
    ( 'ifdef', r'\#ifdef[ \t]+(?P\w+)\n' ),
    ( 'ifndef', r'\#ifndef[ \t]+(?P\w+)\n' ),
    ( 'else', r'\#else\n'),
    ( 'endif', r'\#endif[ \t]*(?P\w*)\n' ),
    ( 'define', r'\#define\s+(?P\w+)[ \t]*(?P((?:\\\n)|.)+)?\n' ),
)
compositeRE= '|'.join( [ '(?P&amp;lt;%s&amp;gt;%s)' % pair for pair in cpp_REs ] )
cppPatterns= re.compile( compositeRE, re.M )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Condition Evaluation.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each line of
host-language code, then, is surrounded by zero or more
#ifdef or
#ifndef
conditions.  We can assume an outer-most
#ifdef
condition which is always true.  As we encounter
#ifdef and
#ifndef
statements, we push additional conditions onto a
stack.  As we encounter
#endif blocks
we pop conditions from the stack.  An
#else block
pops the inner-most condition and pushes the inverse of that
condition.&lt;/p&gt;
&lt;p&gt;The essential rule is
simple:  if all of the conditions are true, then the host language code segment
is present in the output; if any condition is false, the code segment is not
included in the output.  Here is our function for simulating the
CPP.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def allTrue( context ):
    x= True
    for c in context:
        x = x and c
    return x

def cpp( text, defs=set() ):
    &amp;quot;&amp;quot;&amp;quot;Simulate a few features of the CPP.
    This will leave a pre-processor-like marker in the code
    to provide a hint about removed source.
    &amp;quot;&amp;quot;&amp;quot;
    output= StringIO.StringIO(&amp;quot;&amp;quot;)
    definitions= []
    context= [ True ]
    match1= cppPatterns.search( text )
    while match1:
        groups= match1.groupdict()
        hostText= text[:match1.start()]
        # Check the context stack to see if we emit this or suppress it
        # if all of stack is True, emit
        if allTrue(context):
            output.write( hostText )
        else:
            output.write( &amp;quot;# %d lines removed by cpp\n&amp;quot; % ( hostText.count('\n'), ) )
        if groups['ifdef']:
            # push context stack condition
            context.append( groups['ifdefname'] in defs )
        elif groups['ifndef']:
            # push context stack condition
            context.append( groups['ifndefname'] not in defs )
        elif groups['else']:
            cond= context.pop() # pop context stack condition
            # push reversed context stack condition
            context.append( not cond )
        elif groups['endif']:
            cond= context.pop() # pop context stack condition
        elif groups['define']:
            # just soak these up
            definitions.append( (groups['defname'],groups['defbody']) )
            #print groups
        else:
            raise Exception('Unknown preprocessor directive')
        text= text[match1.end():]
        match1= cppPatterns.search( text )
    output.write( text )

    result= output.getvalue()
    output.close()
    return result, dict(definitions)
&lt;/pre&gt;
&lt;p&gt;As with the SQL Precompiler, we return
the resulting source, and some additional information gathered during
processing.  In this case, we return a dictionary of
#define
statements encountered.&lt;/p&gt;
&lt;p&gt;Note that we
emit little #
&lt;em&gt;n&lt;/em&gt;
lines removed... messages in the C source.  The
PLY lexical scanner will remove these silently.  They are helpful for debugging,
however.  Generally, the CPP preserves all newline characters, so the line
numbers are preserved between input and output.  We don't take great pains with
this, since the SQL precompiler has already made a hash of our line
numbers.&lt;/p&gt;
&lt;p&gt;The CPP does have #line
command, which many SQL precompilers use to keep the original source line
numbers consistent through every step of processing.  While important for real
compilation, we're only gathering information about the source, and can omit
this detail.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Preprocessing Pipeline.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's what the two-part
SQL and CPP processing looks like.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def demonstration():
    text= file(r&amp;quot;legacySource\x\y.c&amp;quot;,'r').read()
    sqlPPText, stmts = sqlpreproc(text)
    # print sqlPPText
    flags=['DYNAMICSQL','REREAD','SUB_COMMIT','MACRO_LOCK','MATCH_PATH']
    general=['USE_HIGHEST','PARAMETER_FILE']
    cppText, definitions = cpp( sqlPPText, set(general+flags) )
    print cppText
&lt;/pre&gt;
&lt;p&gt;The list of flags comes from the
Makefile.  The list of &amp;quot;general&amp;quot; definitions comes from a
general.h file
which is included everywhere.  Consequently, the output from this demonstration
function is the complete source that is being compiled in production
today.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Building the Lexer.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The PLY approach allows us
to define a number of patterns and functions.  These are then built into a
single lexer object.  To cope with CPP and SQLPC, we need to define a
sqlpreproc
module which contains the
sqlpreproc and
cpp functions
outlined above.   Once we have that module, we can call those functions to
prepare input to the lexer.&lt;/p&gt;
&lt;p&gt;The
following to demonstrates how our lexer is used.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
lexer = lex.lex()

if __name__ == &amp;quot;__main__&amp;quot;:
    #lex.runmain(lexer)
    makeFlags=['DYNAMICSQL','REREAD','SUB_COMMIT','MACRO_LOCK','MATCH_PATH']
    headerDefs=['USE_HIGHEST','PARAMETER_FILE']
    source= file(r&amp;quot;..\legacySource\x\y.c&amp;quot;,&amp;quot;r&amp;quot;).read()
    sqlPP, statements = sqlpreproc.sqlpreproc(source)
    cpp, definitions = sqlpreproc.cpp(sqlPP,set(headerDefs+makeFlags))
    lexer.input(cpp)
    while 1:
        tok = lexer.token()
        if not tok: break      # No more input
        print tok
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Preliminary Analysis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;From this, we can start
to gather some preliminary data on our customer's program.  We can locate about
10,000 lines of source.  This has about 150 SQL statements scattered around.
Really, the program is not terribly big.  However, there is dynamic SQL being
built, so some care must be taken to reverse engineer this
correctly.&lt;/p&gt;
&lt;p&gt;C programs are just a big
collection of functions.  We'll need to know about those function definitions,
so we can get a cross-reference of function use.  Further, well-written C
programs are object-like and make extensive use of structure definitions that
stand in for proper class definitions.  We'll need to analyze these structures,
and where they are used in the program.&lt;/p&gt;
</content><category term="Management"></category><category term="reverse engineering"></category><category term="C"></category><category term="compiler"></category></entry><entry><title>Python and Reverse Engineering, Part 2</title><link href="https://slott56.github.io/2007_04_05-python_and_reverse_engineering_part_2.html" rel="alternate"></link><published>2007-04-05T14:25:00-04:00</published><updated>2007-04-05T14:25:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-04-05:/2007_04_05-python_and_reverse_engineering_part_2.html</id><summary type="html">&lt;p&gt;A stored procedure isn't really very easy to
understand.  There's a profound fascination with triggers and stored procedures,
and they're both really bad ideas.  I can't say enough bad things about stored
procedures.  See &lt;a class="reference external" href="https://slott56.github.io/2007_03_23-plsql_vs_java_which_is_really_faster.html"&gt;PL/SQL vs. Java - Which is REALLY faster?&lt;/a&gt;  and
&lt;a class="reference external" href="https://slott56.github.io/2006_06_20-over_solving_the_problem_or_when_your_architect_is_a_dba.html"&gt;Over-Solving the Problem or When your architect …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;A stored procedure isn't really very easy to
understand.  There's a profound fascination with triggers and stored procedures,
and they're both really bad ideas.  I can't say enough bad things about stored
procedures.  See &lt;a class="reference external" href="https://slott56.github.io/2007_03_23-plsql_vs_java_which_is_really_faster.html"&gt;PL/SQL vs. Java - Which is REALLY faster?&lt;/a&gt;  and
&lt;a class="reference external" href="https://slott56.github.io/2006_06_20-over_solving_the_problem_or_when_your_architect_is_a_dba.html"&gt;Over-Solving the Problem or When your architect is a
DBA...&lt;/a&gt;  for related
ranting.&lt;/p&gt;
&lt;p&gt;The customer gave us a
300-line stored procedure, and said that it was broken.  After looking at it for
a while, I realized that it was uselessly incomplete.  We saw a demo of the
transaction.  I asked for the code which actually implemented the web page we
saw, and got a VB module of about 100 lines of code.&lt;/p&gt;
&lt;p&gt;When I got back to the office, I found
that the VB procedure they gave me called three other VB modules before calling
the stored procedure.  So, I had to ask for the additional code.  I now had more
code than I could comfortably read and process in my
head.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What To Do?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Time to break out the Python
tools to see what we really had.  The good news is that VB is relatively easy to
parse.  The better news is that we aren't interested in a lot of details, just
the SQL statements.  The best news is that they consistently put SQL statements
into a variable named
SqlStr, making
the SQL statements easy to find.&lt;/p&gt;
&lt;p&gt;Here's
some code for analyzing VB modules to try and locate some nuggets of useful
information.  We'll start out with a simplistic lexical analyzer to cope with
the _ statement continuation markers.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
import re, string

def srcLine( text ):
    lineNo= 0
    line= &amp;quot;&amp;quot;
    firstLine= None
    for i in text.split('\n'):
        lineNo += 1
        i= i.rstrip()
        if not i: continue
        if i[0] == &amp;quot;'&amp;quot;:
            continue
        elif i[-1] == '_':
            if line:
                line += i[:-1].lstrip()
            else:
                line= i[:-1]
            firstLine= firstLine or lineNo
            continue
        else:
            yield firstLine or lineNo, line + i
            line= &amp;quot;&amp;quot;
            firstLine= None

def lex( text ):
    &amp;quot;&amp;quot;&amp;quot;Ultra-simple: whitespace or quotes strings or keyword/variable/number
    or punctuation.  This tends to break up floating-point numbers into two tokens.&amp;quot;&amp;quot;&amp;quot;
    token= re.compile( '(\s+)|((?:&amp;quot;[^&amp;quot;]*&amp;quot;)|(?:\w[\w%#]*)|(?:.))' )
    for num, s in srcLine( text ):
        m= token.match(s)
        while m:
            if m.group(2):
                # Discards whitespace gracefully
                yield num, m.group(2)
            s= s[m.end():]
            m= token.match(s)
        yield num, None # Visible end-of-statement
&lt;/pre&gt;
&lt;p&gt;The
lex() function
will yield a stream of line numbers and tokenized statements, followed by a
None to
indicate that we've run out of statements (including continued
statements.)&lt;/p&gt;
&lt;p&gt;Here's a simple token
aggregator that iterates through all of the VB statements, handling
continuations and multiple statements per line
gracefully.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def vbstmt( text ):
    stmt= []
    firstLine= None
    for lineNo, token in lex( text ):
        if token:
            stmt.append( token )
            firstLine= firstLine or lineNo
        else:
            yield (firstLine or lineNo), stmt
            stmt= []
            firstLine= None
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Starting to Explore.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a quick function
that demonstrates that we really can find SQL statements based on the variable
to which a string is assigned.  The output from this function proves that this
variable has only one purpose in the application.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def sqlStr( text ):
    for num, line in srcLine( text ):
        pos= line.find(&amp;quot;SqlStr&amp;quot;)
        if pos != -1:
            print num, line[pos:].lstrip()
&lt;/pre&gt;
&lt;p&gt;Here's a higher-level function that
uses an analytical function as an &amp;quot;analyzer&amp;quot;, which it applies to the text of
several source files.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def getSQL( analyzer=sqlStr ):
    import glob, os.path
    for nm in glob.glob(&amp;quot;*.vb&amp;quot;):
        print nm
        f= file( os.path.join( &amp;quot;src&amp;quot;, nm ), &amp;quot;r&amp;quot; )
        analyzer( f.read() )
        f.close()
        print

getSQL( sqlStr )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Moving Further Into the Unknown.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We need some complexity
metrics.  Here's a quick estimator that counts tokens in each source file.
Given the frequency histogram of tokens, we can see which variables and
statement types are used.  We can locate the variables, modules and functions,
also.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def tokenCount( text ):
    total= 0
    count= 0
    tokenFreq= {}
    for num, stmt in vbstmt( text ):
        #print num, len(stmt)
        for t in stmt:
            tokenFreq.setdefault( t, 0 )
            tokenFreq[t] += 1
        count += 1
        total += len(stmt)
    print &amp;quot;total&amp;quot;, total
    print &amp;quot;count&amp;quot;, count
    print &amp;quot;tokens/line&amp;quot;, total/float(count)
    tList= tokenFreq.items()
    tList.sort(lambda a,b:-cmp(a[1],b[1]))
    cumulative= 0
    for t,f in tList:
        cumulative += f
        print t,f,cumulative

getSQL( tokenCount )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The Curse of Dynamic SQL.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Since the SQL is assembled as
a large character string, we need to derive what the effective SQL statement is.
This means interpreting the VB assignment statement (to the extent possible.)
This gives us a clearer picture of what the SQL is, and where the dynamic
elements are inserted.&lt;/p&gt;
&lt;p&gt;This function
evaluates the assignment statement, returning the assembled SQL text, and the
variables which were inserted into the SQL text.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def qdEval( stmt ):
    &amp;quot;&amp;quot;&amp;quot;Quick and dirty eval of a dynamic SQL statement.&amp;quot;&amp;quot;&amp;quot;
    buffer= &amp;quot;&amp;quot;
    variables= []
    stmt.pop(0)
    stmt.pop(0)
    while len(stmt) &amp;gt;= 1:
        t= stmt.pop(0)
        if t == '+':
            pass
        elif t[0] == '&amp;quot;':
            # literal
            buffer += t[1:-1]+&amp;quot;\n&amp;quot;
        elif t[0] in string.ascii_letters:
            # Look ahead one token.
            if stmt and stmt[0] == '(':
                # This is a function call, which ends with ')'.
                funcall= stmt.pop(0)
                while funcall != ')':
                    t += funcall
                    funcall= stmt.pop(0)
                t += funcall
            elif stmt and stmt[0] == '!':
                # This is an object reference
                t += stmt.pop(0) # the &amp;quot;!&amp;quot;
                t += stmt.pop(0) # the attribute name
            else:
                # This is a simple identifier
                pass
            buffer += &amp;quot;{%s}&amp;quot; % ( t, )
            variables.append( t )
        else:
            raise Exception( &amp;quot;Can't parse %r&amp;quot; % ( t, ) )
    return buffer, variables
&lt;/pre&gt;
&lt;p&gt;This analyzer locate the SQL
statements, and uses
qdEval to
produce a summary of the overall SQL work done by a given
module.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def sqlDetl( text ):
    def assignment( stmt ):
        global sqlCount, variables
        sqlCount += 1
        print num
        try:
            buffer, varList = qdEval( stmt )
            print buffer
            for v in varList:
                variables[v]= True
        except Exception, e:
            print &amp;quot;##&amp;quot;, e
            print &amp;quot;##&amp;quot;, stmt
    def statement( stmt ):
        if len(stmt) &amp;gt; 2 and stmt[1] == '=':
            if stmt[0] == 'SqlStr':
                assignment( stmt )
        elif stmt[0] == 'If':
            # Is there a Then _ continuation?
            while stmt and stmt[0] != 'Then':
                stmt.pop(0)
            if stmt:
                assert stmt[0] == 'Then'
                stmt.pop(0)
            if stmt:
                statement( stmt )
        else:
            #print num, stmt[0]
            pass
    global variables, sqlCount
    variables= {}
    sqlCount= 0
    for num, stmt in vbstmt( text ):
        statement( stmt )
    print &amp;quot;Bind Variables:&amp;quot;, variables.keys()
    print &amp;quot;SQL Statements:&amp;quot;, sqlCount

getSQL( sqlStr )
&lt;/pre&gt;
&lt;p&gt;While we don't know everything, we now
know quite a bit more.  We've got 3,000 lines of code, 157 distinct SQL
statements, amounting to about half the code volume.  We can identify 20
distinct tables involved in the entire
process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Discovery with Python.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;With Python, I was able to
analyze 3,000 lines of VB in a day or two, and provide metrics in which we were
completely confident.  We could show precisely how the 300 line problem they
started with was really a 3,000 line problem.  And, we could also show that this
still wasn't really in the ballpark for what was
needed.&lt;/p&gt;
&lt;p&gt;Best of all, I have reused this
code to analyze other VB programs to gather similar statistics.  Universally,
the &amp;quot;simple&amp;quot; application that needs to be rewritten is at least an order of
magnitude more complex than the glib assertions of our
customers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bottom Line.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We had to given them a price
which was unacceptably large.  The legacy program, while 10x as large as the
originally claimed, isn't all that big.  However, those VB modules fit into a
larger business process.&lt;/p&gt;
&lt;p&gt;Looking
outside the narrow VB and SQL world, they described 15 use cases for at least
three kinds of actors.  Without doing detailed domain analysis, we have to
assume that each relational table is (approximately) one object class.  [Yes,
relational tables can be only a portion of a composite class, or a &amp;quot;pre-join&amp;quot; of
multiple classes.  However, we don't know otherwise, so we have to assume
something.]&lt;/p&gt;
&lt;p&gt;Building the 15 use case
application, coupled with reverse engineering, will take close to a person-year
of effort.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Customer Value.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Of course, no one is happy
with this kind of result.  They thought that they had 300 lines of code, and it
would take a few months.  We found 3,000 lines of code.  We also found that
there were 14 other use cases in addition to the one they claimed was
relevant.&lt;/p&gt;
&lt;p&gt;Were we wrong to expand the
scope?  Yes, because it wasn't what the customer expected.  No, because we
couldn't have accomplished what the customer demanded.&lt;/p&gt;
</content><category term="Management"></category><category term="reverse engineering"></category><category term="PL/SQL"></category><category term="SQL"></category><category term="database"></category></entry><entry><title>Python and Reverse Engineering, Part 1</title><link href="https://slott56.github.io/2007_04_02-python_and_reverse_engineering_part_1.html" rel="alternate"></link><published>2007-04-02T17:38:00-04:00</published><updated>2007-04-02T17:38:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-04-02:/2007_04_02-python_and_reverse_engineering_part_1.html</id><summary type="html">&lt;p&gt;Python is
&lt;strong&gt;Batteries Included&lt;/strong&gt; ™ programming.  These analysis
tools are either Python &lt;strong&gt;Out Of the Box&lt;/strong&gt; , or they are straight-forward downloads of
other open-source components.&lt;/p&gt;
&lt;p&gt;Here are
some analytical situations where Python has saved my bacon.  I'll present some
code for several of these.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Legacy Data Domains.  There are legacy (in …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;Python is
&lt;strong&gt;Batteries Included&lt;/strong&gt; ™ programming.  These analysis
tools are either Python &lt;strong&gt;Out Of the Box&lt;/strong&gt; , or they are straight-forward downloads of
other open-source components.&lt;/p&gt;
&lt;p&gt;Here are
some analytical situations where Python has saved my bacon.  I'll present some
code for several of these.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Legacy Data Domains.  There are legacy (in
this case Z/OS COBOL) files which are source data for the data warehouse.  What
are the domains of various attributes?  The &amp;quot;data dictionary&amp;quot; doesn't say, and
reading the code is hard to do because there's no easy way to determine all of
the programs which read or write the given files.  Remember, there's not GREP on
the mainframe.&lt;/li&gt;
&lt;li&gt;Source Code Analysis for C, VB, SQL, etc.
This varies from simple String operations to moderate use of the
&lt;strong&gt;re&lt;/strong&gt;
package to using PLY or similar high-end parsing tools.&lt;/li&gt;
&lt;li&gt;Test Data Generation.&lt;/li&gt;
&lt;li&gt;Proof of Concept for SOAP adaptations and
extensions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Legacy Data Domain Analysis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Analyzing legacy data
files involves some pleasant features of Python.  It is an easy job, and easy to
extend and refine.  There are a number of sub-problems that have to be solved as
part of this.&lt;/p&gt;
&lt;p&gt;We'll look at the
&lt;strong&gt;Transfer Problem&lt;/strong&gt; , the
&lt;strong&gt;EBCDIC Problem&lt;/strong&gt; , and the
&lt;strong&gt;File Layout Problem&lt;/strong&gt;  first.  Then we'll show what the
overall application might look
like.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Transfer Problem.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of the first hurdles
is getting files off the Z/OS mainframe and onto a desktop PC where they can be
analyzed.  One client fooled around with the TSO file transfer and declared data
analysis to be impossible.  The TSO file transfer takes HOURS to transfer a
moderately large file; FTP takes seconds.&lt;/p&gt;
&lt;p&gt;Python's &lt;a class="reference external" href="http://docs.python.org/lib/module-urllib.html"&gt;urllib&lt;/a&gt;  module allows us to write simple,
automated FTP-like scripts that reliably fetch files, produce useful messages
and log their progress.  TSO file moving is silly.  Manual file operations,
while fine for the initial round of development and test, shouldn't be used in
the long run.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The EBCDIC Problem.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parts of Z/OS files,
generally, are coded in EBCDIC.  Python expects ASCII or Unicode.  Because the
EBCDIC character set is disjoint from ASCII, you'll do well to use Unicode
files.  However, if you can't part with ASCII, you can work out sensible
translation schemes.&lt;/p&gt;
&lt;p&gt;Other parts of
Z/OS files, however, are not in EBCDIC.  Numeric data fields may be encoded in
binary, or may be encoded in packed decimal format.  Therefore, there is no
simple transformation from EBCDIC to ASCII or
Unicode.&lt;/p&gt;
&lt;p&gt;If you allow FTP to translate
from EBCDIC, all of your binary and packed decimal fields will become useless
coprolite.  Instead, you'll need to know the COBOL record layout.  This will
allow you to pick apart individual fields, doing appropriate conversions: text
to Unicode, binary to integer, and packed decimal to Python
decimal.&lt;/p&gt;
&lt;p&gt;Also, Python's &lt;a class="reference external" href="http://docs.python.org/lib/standard-encodings.html"&gt;codecs&lt;/a&gt;  module has the cp037 (also known as
IBM037 and IBM039) encodings that will translate EBCDIC to something more
useful.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Record Layout Problem.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;COBOL data is rarely in
any kind of delimited format.  It is almost universally in fixed field-length
format.  COBOL has verbs that will create XML or CSV files.  However, you're
adding to your legacy, not replacing it when you start writing mainframe
programs to help you get rid of mainframe programs.  To get rid of the legacy,
you have to stop using it.  This means stopping use of COBOL, even to prepare
files for use in non-COBOL environments.&lt;/p&gt;
&lt;p&gt;Fortunately, it's quite easy to handle
COBOL Data Definition Entries (DDE), also called Record Layouts or &amp;quot;Copybooks&amp;quot;.
These can be parsed in Python, and a Python data structure used to define the
offset, length and coding scheme for each field within a COBOL record.  Since
this structure knows the data type, it has responsibility for conversion from
Z/OS-COBOL encodings to more universal Unicode
encodings.&lt;/p&gt;
&lt;p&gt;There are two ways to
approach the DDE parsing.  You can -- without too much effort -- use &lt;a class="reference external" href="http://www.dabeaz.com/ply/"&gt;PLY&lt;/a&gt;  to create
a lexer and parser for the relevant subset of COBOL.  However, the subset of
COBOL is simple enough that 1,000 lines of code gets you a robust-enough parser
for COBOL DDE files.  I talk a little about this in &lt;a class="reference external" href="../C257963460/E20060902151714.html"&gt;My Legacy Nightmares: Coping with COBOL
Coexistence&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Analysis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The
data analysis applications devolve to something delightfully
simple.&lt;/p&gt;
&lt;p&gt;1.  Get the source file from
the mainframe.&lt;/p&gt;
&lt;p&gt;2.  Parse the DDE &amp;quot;copybook&amp;quot;
that defines the file.&lt;/p&gt;
&lt;p&gt;3.  Build a &amp;quot;record
analyzer&amp;quot; which picks specific fields out of the file, and accumulates a
dictionary of field values and number of occurrences.  A record analyzer is a
collection of individual field analyzers.  We'll look at a field analyzer
below.&lt;/p&gt;
&lt;p&gt;4.  Read each record, apply the record
analyzer to the sequence of bytes which were
read.&lt;/p&gt;
&lt;p&gt;5.  At end of file, write the final
results from each field of the record
analyzer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example Field Analyzer.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's a Field Analyzer.
There are a number of possible specializations for handling indexed fields and
numeric fields.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class FieldValue:
    &amp;quot;&amp;quot;&amp;quot;Accumulate unique values for a named field of a DDE.

    This will have to be subclassed for indexes of occurs clauses.
    &amp;quot;&amp;quot;&amp;quot;
    def __init__( self, dde, cobolName ):
        &amp;quot;&amp;quot;&amp;quot;Given a DDE and a COBOL name, set up a field extractor and frequency mapping.&amp;quot;&amp;quot;&amp;quot;
        self.cobolName= cobolName
        self.usage = dde.get(cobolName).usage
        self.get_field= dde.get(cobolName)
        self.domain= {}
    def getFrom( self, data ):
        &amp;quot;&amp;quot;&amp;quot;Get the value from the field, then accumulate in the frequency mapping.&amp;quot;&amp;quot;&amp;quot;
        v= self.get_field.of( data )
        self.domain[v]= self.domain.setdefault(v,0) + 1
    def fqTable( self ):
        &amp;quot;&amp;quot;&amp;quot;Return a sequence of tuples with value and frequency count, sorted.&amp;quot;&amp;quot;&amp;quot;
        val_count= self.domain.items()
        # Sort descending by second field (count), ascending by first field (value)
        val_count.sort( lambda a,b: cmp(b[1],a[1]) or cmp(a[0],b[0]) )
        return val_count
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example Record Analyzer.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's the canonical
record analyzer.  It is initialized with a sequence of field
analyzers.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class RecordAnalyzer:
    def __init__( self, aFieldList ):
        self.fieldList= aFieldList
    def process( self, recno, data ):
        for f in self.fieldList:
            f.getFrom( data )
    def final( self, records ):
        print &amp;quot;\n%d Records&amp;quot; % ( records )
        for f in self.fieldList:
            print &amp;quot;\n%-10s %7s&amp;quot; % ( f.cobolName, &amp;quot;count&amp;quot; )
            for di,c in f.fqTable():
                print &amp;quot;%-10s %7d&amp;quot; % ( di,c )
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Application Class.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here's the result data
analysis application class.  It is initialized with a parsed DDE and a
RecordAnalyzer.  This will examine one or more files to accumulate a data
domain.  The final report will show the selected fields, the unique values, and
the number of occurrences.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
class FileScan:
    &amp;quot;&amp;quot;&amp;quot;Basic file scanning operation.&amp;quot;&amp;quot;&amp;quot;
    def __init__( self, aDDE, aFieldProcess ):
        self.dde= aDDE
        self.fieldProcess= aFieldProcess
        self.record= 0
    def reclen( self ):
        return self.dde.size
    def process( self, aFileName, end=-1 ):
        self.theFile= file( aFileName, &amp;quot;rb&amp;quot; )
        self.record= 0
        data= self.theFile.read( self.reclen() )
        while data:
            self.record += 1
            self.fieldProcess.process( self.record, data )
            if self.record == end: break
            data= self.theFile.read( self.reclen() )
        self.theFile.close()
        self.fieldProcess.final(self.record)
&lt;/pre&gt;
&lt;p&gt;Perhaps in a future posting I'll
finish describing the COBOL DDE parser.  I'm reluctant to go too far, because I
really ought to rework it to be a proper PLY implementation, rather than a
from-scratch scanner and parser.&lt;/p&gt;
</content><category term="Management"></category><category term="reverse engineering"></category><category term="EBCDIC"></category><category term="data transfer"></category></entry><entry><title>IT's Drive to Self-Destruction</title><link href="https://slott56.github.io/2007_02_18-its_drive_to_self_destruction.html" rel="alternate"></link><published>2007-02-18T22:32:00-05:00</published><updated>2007-02-18T22:32:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-02-18:/2007_02_18-its_drive_to_self_destruction.html</id><summary type="html">&lt;p&gt;My approach to preventing IT insignificance
begins with firing the good programmers, since they're saddled with low-value
work to begin with.  In order to see what that means, let's look at the three
phases of an IT organization's collapse to irrelevance.  Then we'll see why some
specific reorganization steps can …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My approach to preventing IT insignificance
begins with firing the good programmers, since they're saddled with low-value
work to begin with.  In order to see what that means, let's look at the three
phases of an IT organization's collapse to irrelevance.  Then we'll see why some
specific reorganization steps can revitalize
IT.&lt;/p&gt;
&lt;div class="section" id="phase-1-hubris"&gt;
&lt;h2&gt;Phase 1, Hubris&lt;/h2&gt;
&lt;p&gt;During the &lt;strong&gt;Hubris&lt;/strong&gt; phase, projects are undertaken which boggle the mind.  CIO's, swayed by reading
books and magazine articles believe that they can make any kind of project work.
The CIO's job is to promote anything that makes sense.  In order to justify this
approach, the impact of each project must be
pervasive.&lt;/p&gt;
&lt;p&gt;The projects undertaken in
this phase are grand and sweeping; projects like replacing a hodge-podge of
back-office systems with some unified ERP application like Oracle Financials or
SAP.  It's the ledger system, the backbone of the back-office.  It can't be any
more central and sweeping.&lt;/p&gt;
&lt;p&gt;The focused conversion of data from old applications to the new application gets
circumvented by extensive customization, extension and interfaces.  Highly
optimized in-house software is supplanted.  Rather than replace strange,
non-standard processes with processes that fit the off-the-shelf software, the
pinnacle of hubris is rewriting the off-the-shelf application so that a peculiar
business process is optimized in an unusual
way.&lt;/p&gt;
&lt;p&gt;This isn't seen as hubris.  It's
seen as necessary customization.  It requires a high degree of programming
skill.  And it also requires incremental
delivery.&lt;/p&gt;
&lt;p&gt;However, the reason I call it
hubris is that the organization is not often able to deliver on this
customization.  Even a flashy SOA programming toolset, in the hands of
improperly managed programmers, can't deliver on the promise of making an
off-the-shelf package fit every user's individual, contrived whims.  It isn't a
skill issue, it's a management focus issue.  See &amp;quot;&lt;a class="reference external" href="http://codecraft.info/index.php/archives/69/"&gt;To
rewrite or not rewrite, that is the question&lt;/a&gt; &amp;quot; for related thinking on
cost and complexity considerations that will kill any software
project.&lt;/p&gt;
&lt;p&gt;There's something good about the &lt;strong&gt;Hubris&lt;/strong&gt; phase: programmers get to program.
However, the grandiose projects wind up failing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="root-cause"&gt;
&lt;h2&gt;Root Cause&lt;/h2&gt;
&lt;p&gt;The failure of over-the-top
development efforts comes from a single root cause:  not solving the business
problem.  A software development effort must demonstrably solve a business
problem.  However well-intentioned, carefully planned, meticulously executed the
project is, when it doesn't obviously solve an easy-to-articulate business
problem, it's useless.&lt;/p&gt;
&lt;p&gt;The business
value proposition for software has to be boiled down to something so pithy and
in incontrovertible that a hands-off executive can remember it and repeat it
when asked.  It helps to position the business value like this:
&lt;em&gt;[X] is broken; installing software fixes [X]&lt;/em&gt; .
It helps to be sure that each executive can describe exactly how &lt;em&gt;[X]&lt;/em&gt;
is broken, so they know what will be fixed.&lt;/p&gt;
&lt;p&gt;Note that we're not talking
about features and benefits.  We're talking about broken and fixed.  The
difference is that features are nice-to-have.  Broken is essential to stay in
business.  If the project doesn't fix something that's broken, it is pure hot
air.&lt;/p&gt;
&lt;p&gt;If a project contains elements
that stray outside the boundaries of &lt;strong&gt;Was Broken-To Be Fixed&lt;/strong&gt; ™ (WBTBF), those
elements will (and should) be cut.  If these logical extensions and add-ons
can't be separated from the &lt;strong&gt;Fixing a Business Problem&lt;/strong&gt; ™ (FBP) elements, then
the whole project will (and should) be cancelled.&lt;/p&gt;
&lt;p&gt;Once a hubristic project is cancelled,
the organization chills down to a &lt;strong&gt;Conciliation&lt;/strong&gt; phase.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="around-the-edges"&gt;
&lt;h2&gt;Around the Edges&lt;/h2&gt;
&lt;p&gt;When an organization
operates in the &lt;strong&gt;Hubris&lt;/strong&gt; phase, there is often a main, resource-hogging project, and many small,
around-the-edges projects.  The smaller projects are also mismanaged in a way
that cripples the organization.  They are managed by a process of
&lt;strong&gt;Descope and Drop into Production&lt;/strong&gt; ™ (DDP).  In this phase, a
cool solution to a business problem, one which takes more than 10 months to
complete, is descoped, dropped into production, and the developers moved on to
something else.&lt;/p&gt;
&lt;p&gt;The incomplete
application is now a burden on the organization.  For the entire life of the
application, someone will be fiddling with it, doing ad-hoc work, fixing broken
data, rerunning programs with patches and hacks.  The cumulative effort spent on
&amp;quot;maintenance&amp;quot; and &amp;quot;support&amp;quot; will exceed the effort to put permanent fixes in
place.  However, maintenance is paid for with &lt;strong&gt;Next Year's Dollars&lt;/strong&gt; ™ (NYD), which don't really
count.&lt;/p&gt;
&lt;p&gt;Often a top-shelf developer is
saddled with ad-hoc queries and data reloads.  Their creative spark is ground
out by the boot-heel of bad management.  They get bored doing &amp;quot;programming
lite&amp;quot;, when they could be writing real software.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="phase-2-conciliation"&gt;
&lt;h2&gt;Phase 2, Conciliation&lt;/h2&gt;
&lt;p&gt;During the &lt;strong&gt;Conciliation&lt;/strong&gt; phase, all projects must be meticulously cost-justified.  CIO's humbled by
earlier failures (or hired to replace a failed CIO) believe that most projects
are doomed to fail.  The CIO's job is to prevent anything that involves risk.
In order to justify this approach, the impact of each project must be
meticulously measured.&lt;/p&gt;
&lt;p&gt;Extensive ROI analysis and score-carding are the order of the day.  This reaches a level of
absurdity when ordinary Business Analysis to justify IT changes has to be
justified.  We have mini-projects to create the budget for the analysis and
planning to create the budget for the first phase of some initiative.  In order
to justify the justification, the initiative has to have a provable
ROI.&lt;/p&gt;
&lt;p&gt;Since IT is all about cost
reduction, the ROI is based on reduced cost.  We can never really measure cost
savings because we rarely have usable cost baselines.  Some easy project plans
will shave a number of people out of the organization.  Most projects, however,
will make existing people more efficient, and more able to focus on business
growth.  What's the ROI of &amp;quot;less fooling around reconciling a bunch of
badly-designed spreadsheets&amp;quot;?  It wasn't an entire department, or even a
full-time job.  But it is the source of occasional multi-million dollar
goof-ups.   It carries a vast down-side risk; what's the ROI of avoiding
risk?&lt;/p&gt;
&lt;p&gt;The IT-initiated ROI analysis
never seems to work out well.  The business starts to trump IT, doing things on
their own.  Often, the business will bring in their own developers, justify
their own projects to themselves, and spend their own investment dollars in
their own Hubris phase.  This creates shadow and duplicate IT organizations
within the enterprise.&lt;/p&gt;
&lt;p&gt;In the &lt;strong&gt;Conciliation&lt;/strong&gt; phase, programmers don't program.  At best, they integrate.  The most common
situation, however, is the programmers become glorified operators; they run
queries and extracts for the users.  They manually correct problems because of
incomplete or poorly-integrated software.  Rewrites and repair can't be
justified but endless maintenance and support is the order of the
day.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-desktop-solution"&gt;
&lt;h2&gt;The Desktop Solution&lt;/h2&gt;
&lt;p&gt;In the conciliation phase, few things can be approved, so end-users are forced to work with desktop
tools like Excel and Access.  IT can't (or won't) respond to user requests for
automation, so the users become power Excel hacks, learn Access or hire an
Access hack to kludge something together.  The desktop is there, why not use
it?&lt;/p&gt;
&lt;p&gt;Desktop products don't scale well;
the solutions are often little better than
&lt;strong&gt;Personal Programming Projects&lt;/strong&gt; ™ (PPP) applied to enterprise
information assets.  To improve these solutions, the users often beg for someone
to &lt;strong&gt;Scale Our Spreadsheet&lt;/strong&gt;  (SOS).  It's a plea for help, and it goes unrecognized.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-tipping-point"&gt;
&lt;h2&gt;The Tipping Point&lt;/h2&gt;
&lt;p&gt;There is a tipping
point that occurs in the organization.  This tipping point is passed when the IT
focus slips away from building and using software, to Keeping the Lights
On™ (KLO).  At some point, the CIO starts shooting down ideas because
there isn't enough new development money.  The budget is allocated for KLO work
only, and nothing new is possible.&lt;/p&gt;
&lt;p&gt;Once we can't afford change, we've devolved to the level of maximum entropy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="phase-3-maximum-entropy"&gt;
&lt;h2&gt;Phase 3, Maximum Entropy&lt;/h2&gt;
&lt;p&gt;While there are degrees of
entropy (from clumsiness to chaos to criminality), it's all essentially the same
net effect to the business.  IT is a large, fixed cost.  The CIO is simply the
head of computer maintenance.  Business initiatives come and go, and the CIO's
role is to provide the kind of cost information that helps executives choose the
lesser of a number of evils.&lt;/p&gt;
&lt;p&gt;There are a number of reasons why entropy is maximized:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;All software is interconnected.  There's no
focus, no nucleus, no easily identifiable &amp;quot;architecture&amp;quot;, &amp;quot;data flow&amp;quot; or &amp;quot;system
of record&amp;quot; for a piece of information.  It takes days of meetings just to get an
overview of the mission-critical systems.  Something as simple as adding
software to predict order volumes requires a day to uncover the nuances of a
architecture of truly Byzantine complexity.&lt;/li&gt;
&lt;li&gt;All people are of equal skill levels.  There's
no technical giant who can be trusted to write software and make it work.
There's no architect who can summarize the best way to implement something.
There's no QA person who can speak with authority on process or the software
portfolio.&lt;/li&gt;
&lt;li&gt;All processes are hopelessly complex.
Everything is a special case, and nothing can be changed.  For example, all
executables are built by programmers and put into production that way because
the production support people can't be trusted to run a build.  There's no
standardized build process, and endless meetings only reveal that no one
considers it possible to achieve a standardized build process.  No one has heard
of &amp;quot;open source software&amp;quot; (except in the negative sense of buggy, and
virus-ridden); no one has ever seen
configure; make; make
install as the entire set of instructions for
building software.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="consequences-of-entropy"&gt;
&lt;h2&gt;Consequences of Entropy&lt;/h2&gt;
&lt;p&gt;Every move is fraught with
&amp;quot;risks&amp;quot;.  The &amp;quot;risks&amp;quot; aren't risks (like cancer, stroke, heart disease), they're
just failure to manage ignorance.  The root cause of this level of ignorance,
BTW, is the baffling complexity of the application software.  There's no
&amp;quot;probability&amp;quot; of failure; it's essentially certain that any effort will be
under-analyzed, under-designed, under-scheduled, and under-funded.  Failure
isn't a chance, it's essentially certain.  Success is only possible in the
unlikely event that some of the self-serving statements happen to be true.&lt;/p&gt;
&lt;p&gt;To make anything happen at all, the
end-users are forced to an exaggerated level of mendacity.  At inception, they
require everything, providing fabulous ROI analysis.  At the transition to
production, they settle for almost none of what they required at inception.  And
they're satisfied, because they knew IT would never deliver on the full set of
requirements.  They only wrote the full set of requirements to make the project
seem important enough that it would rise above the &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Grey_goo"&gt;grey
goo&lt;/a&gt;  of IT.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-conversation"&gt;
&lt;h2&gt;The Conversation&lt;/h2&gt;
&lt;p&gt;I listen to conversations that go like this.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Business&lt;/strong&gt;:  We need to fix X (order entry, order value analysis, etc.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IT&lt;/strong&gt;:  Problem X is based on
software S1, S2 and S3, which are unique to each division.  Your problem, X, is
really only part of divisions 1 and 2, so you can't impact division 3.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Business&lt;/strong&gt;:  What if we all use S3?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IT&lt;/strong&gt;:  It doesn't scale, we can't
support it, the licensing is complex, we don't have the hardware, our skills
aren't current, it isn't strategic, it isn't compatible with R2.&lt;/p&gt;
&lt;p&gt;The conversation doesn't end there.
I'm brought in to sort out these various architectural details.  In particular
the &amp;quot;not compatible&amp;quot; one is a killer.  If we're retiring S2, why can't we also
retire R2?  Again, IT has some baffling, complex story that the user's can't
easily refute.  There's usually some technology issue that doesn't have any FBP
aspect to it; since no obvious business problem is being fixed, no one can
determine the value of the
software.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-solution"&gt;
&lt;h2&gt;A Solution&lt;/h2&gt;
&lt;p&gt;Here's a candidate
solution.  If we structure IT properly, we can more easily control what is done
and by whom.  First, we need to structure the overall IT organization around
available services.  We build IT as if we are going to outsource everything.  We
look at the network and hardware operations as if they are a hosting services
provider.  We look at our help desk as if we were outsourcing their skills and
knowledge.&lt;/p&gt;
&lt;p&gt;The most important thing
is to partition software development into a wholly-owned subsidiary.  IT, in
general, would then be run by a core group of business analysts who knit
together solutions to business problems.  They &amp;quot;subcontract&amp;quot; to an
infrastructure group.  They create operation units who work with end-users to
successfully use the software
solutions.&lt;/p&gt;
&lt;p&gt;The main IT organization now
&amp;quot;subcontracts&amp;quot; software development to the in-house software development
company.  That development company creates software solutions as if it had a
number of external customers.  It writes comprehensible, tidy, intellectually
manageable packages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-in-house-subsidiary"&gt;
&lt;h2&gt;The In-House Subsidiary&lt;/h2&gt;
&lt;p&gt;The in-house
software subsidiary creates the products that are used to solve business
problems.  The subsidiary also provides &amp;quot;level 3&amp;quot; help-desk support, much like
all of the other outside software vendors.  The programmers don't run random
queries and data extracts for end-users.  The operations folks handle that.&lt;/p&gt;
&lt;p&gt;The programmers, rather than
hand-holding, have to focus on delivering new, expanded value to justify their
maintenance agreements.  They have to respond to trouble tickets and bug
reports, as well as put in enhancements that fit with their software product
line.&lt;/p&gt;
&lt;p&gt;The programmers aren't the
dutiful drudges that turn user whims into software.  They interpret the user
requirements into a tidy, comprehensible, compatible, usable package of
software.  They adhere to in-house interface standards to assure compatibility
and interoperability.  They provide usable API's for the operations ETL
programmers who are integrating, loading, and extracting data for the
end-users.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-advantage-of-distance"&gt;
&lt;h2&gt;The Advantage of Distance&lt;/h2&gt;
&lt;p&gt;We'll separate programmers into two groups: our developers and our operations support folks.
By separating the developers we do several things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;We lift the developers out
of the grey goo of the &lt;strong&gt;Maximum Entropy&lt;/strong&gt;  phase, and give them a way to effect
change.  Rather than micro-managing hellishly complex tangles of requirements,
we let them cut the Gordian knot by proposing a solution which they can build
and maintain.  We assign operation support programmers to migrate the data to
this solution, handling any integration and operation.  We keep a firm hand on
the tiller to prevent the operations folks from creating complex applications
under the rubric of creating an
interface.&lt;/li&gt;
&lt;li&gt;We end the second-guessing of the &lt;strong&gt;Conciliation&lt;/strong&gt;
phase.  The programmers own the solution; they create it, they maintain it.
Most importantly, they are able to extend it.  Projects aren't cut off at 10
months because managers are bored.  Projects become products, which can have a
long, productive life.&lt;/li&gt;
&lt;li&gt;We prevent the pitfalls of &lt;strong&gt;Hubris&lt;/strong&gt; phase.
The software developers have to create a product which solves a business
problem.  They are, like any vendor, responsible for competing against similar
products, and positioning their solution.  They have to provide pithy,
intelligible summaries.  They can't hide inside IT as just another cost of doing
business.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;They can't (initially)
compete on price with an external vendor: they don't have enough products or
customers.  After a few years of product development, however, they will have
enough products in use that the aggregate maintenance fees for those products
will keep a development organization running.  Each individual product fee would
be competitive on the open market.&lt;/p&gt;
&lt;p&gt;Since the programmers are --
technically -- outside the main IT organization, they turn over source for IT to
compile, build and install.  In this respect, they are now competing against
best practices in the open source community.  The open source quality bar is set
very, very high.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="next-steps"&gt;
&lt;h2&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Fire your best programmers.
Re-hire them in a subsidiary that creates products.  Cut them off from running
reports and extracts.  Connect them up with their customers: the business
analysts that have to solve business problems with software
products.&lt;/p&gt;
&lt;p&gt;Make that subsidiary
responsible for quality and supportability.  Make them compete with the best
open-source products for quality and reliability.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="failures"></category><category term="roi"></category><category term="budget"></category><category term="planning"></category></entry><entry><title>The Question of Risk (Revised)</title><link href="https://slott56.github.io/2007_01_06-the_question_of_risk_revised.html" rel="alternate"></link><published>2007-01-06T15:16:00-05:00</published><updated>2007-01-06T15:16:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-01-06:/2007_01_06-the_question_of_risk_revised.html</id><summary type="html">&lt;p&gt;Yes, it's an omission and, yes, it's a mistake.
I should have said something along the lines of &amp;quot;risk is an uninteresting
complication&amp;quot; or &amp;quot;risk is just a euphemism for bad
management.&amp;quot;&lt;/p&gt;
&lt;p&gt;Why is risk uninteresting?&lt;/p&gt;
&lt;p&gt;First, the seeds (Chad Fowler's &amp;quot;&lt;a class="reference external" href="http://chadfowler.com/2006/12/27/the-big-rewrite%22%20target=%22NewWindow"&gt;The
Big Rewrite&lt;/a&gt; &amp;quot;,
and CodeCraft, &amp;quot;&lt;a class="reference external" href="http://codecraft.info/index.php/archives/69/%22%20target=%22NewWindow"&gt;To
Rewrite or not …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Yes, it's an omission and, yes, it's a mistake.
I should have said something along the lines of &amp;quot;risk is an uninteresting
complication&amp;quot; or &amp;quot;risk is just a euphemism for bad
management.&amp;quot;&lt;/p&gt;
&lt;p&gt;Why is risk uninteresting?&lt;/p&gt;
&lt;p&gt;First, the seeds (Chad Fowler's &amp;quot;&lt;a class="reference external" href="http://chadfowler.com/2006/12/27/the-big-rewrite%22%20target=%22NewWindow"&gt;The
Big Rewrite&lt;/a&gt; &amp;quot;,
and CodeCraft, &amp;quot;&lt;a class="reference external" href="http://codecraft.info/index.php/archives/69/%22%20target=%22NewWindow"&gt;To
Rewrite or not to rewrite, that is the question&lt;/a&gt; &amp;quot;) don't mention
risk.&lt;/p&gt;
&lt;p&gt;Second, and more important,
&amp;quot;risk,&amp;quot; as commonly used in IT planning, usually means &amp;quot;bad management&amp;quot;.  Most
people will discuss risk in a broad, unfocused, intangible, &amp;quot;$#!+ Happens&amp;quot; kind
of way.  They say vague things like &amp;quot;How much risk is associated with this
project?&amp;quot; as if risk is a quantity.  Rarely will they talk about a specific
thing that might not turn out as planned.&lt;/p&gt;
&lt;p&gt;I think any discussion of risk has to
be separated into bad management and actual unplannable events.  The unplannable
events are &lt;strong&gt;real&lt;/strong&gt; risks like heart disease, cancer, stroke, or motor vehicle accidents.  Almost
everything else that can go wrong is little more than bad
management.&lt;/p&gt;
&lt;p&gt;There is no single, broad
&amp;quot;risk&amp;quot; associated with a software development project.  There are a number of
specific risks, each one is unique, and each is a symptom of bad management.
Software development risks cannot easily be aggregated, except in a theoretical
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Expected_value"&gt;expected value&lt;/a&gt;  calculation.  And even then,
that's dead wrong for software.&lt;/p&gt;
&lt;p&gt;There are many lists of specific risk factors.  The Visual FoxPro Wiki, for example,
has a Software Development Risk Factors &lt;a class="reference external" href="http://fox.wikis.com/wc.dll?Wiki~SoftwareDevelopmentRiskFactors~VFP"&gt;http://fox.wikis.com/wc.dll?Wiki~SoftwareDevelopmentRiskFactors~VFP&lt;/a&gt;  page that's
handy.
Here is the heart of the problem: &lt;strong&gt;failing to address risks as discrete kinds of mistakes&lt;/strong&gt; .
Almost all of the things we see as software risks are just bad management, each a kind of failure to cope with
ignorance.  I believe that, like an &lt;a class="reference external" href="https://slott56.github.io/2006_08_22-a_new_architecture_involves_ignorance.html"&gt;architecture&lt;/a&gt; , software development involves
strategies to manage ignorance.&lt;/p&gt;
&lt;p&gt;[The worst conversations are the &amp;quot;we don't know what we don't know, anything could
happen&amp;quot; conversations.  Those are exasperating.  You do, in fact, have tangible
risk models and lists of risk factors, better termed &amp;quot;potential problems.&amp;quot;]&lt;/p&gt;
&lt;div class="section" id="software-risks-are-different"&gt;
&lt;h2&gt;Software Risks are Different&lt;/h2&gt;
&lt;p&gt;Software development
isn't like other construction trades.  We aren't building something, but
learning something.  Software development is all about knowledge capture.  Even
if we don't build the application software that was in the &amp;quot;Goals&amp;quot; section of a
project charter, we still learned something of
value.&lt;/p&gt;
&lt;p&gt;From the old &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Max_Headroom_(TV_series)"&gt;Max Headroom TV series&lt;/a&gt; ,
I learned, &amp;quot;&lt;strong&gt;There are no failed experiments, only more data&lt;/strong&gt;.&amp;quot;  This appears to be a paraphrase
of a quote from R. Buckminster Fuller, but I can't find a reference to Fuller's
original quote.&lt;/p&gt;
&lt;p&gt;Software development
risk factors don't fit the standard mold.  Most risk analysis is based on the
probability of a loss: the house burns down, the bridge collapses, the culvert
washes out, the footings are undermined, the boat sinks.  Software doesn't
involve the same kinds of loss.  Indeed, it rarely involves any loss at all.
Unless a server actually burns up, or all the people leave the organization --
taking all their notes with them -- you don't have a total
loss.&lt;/p&gt;
&lt;p&gt;In software development, a
&amp;quot;failure&amp;quot; isn't like a classical &amp;quot;loss&amp;quot;: you still learned something, and the
thing you learned &lt;strong&gt;is&lt;/strong&gt;  of real value.  You may think that you only learned that you can't deliver 10
person-years of software in 1/2 a person-year.  But your requirements, designs,
and partial solutions all have real, tangible value, and can be reworked into
something.  The team that remains grew in experience, management gained some
knowledge, the organization learned
something.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="but-the-labor-was-wasted"&gt;
&lt;h2&gt;But the Labor was Wasted&lt;/h2&gt;
&lt;p&gt;A software project failure
isn't even a total loss of labor hours.  You can only lose the labor hours by a
two step process: failing to deliver a solution to the problem and then firing
the every single person who learned the lessons.  When this happens, it
indicates a criminal disregard for how an organization accumulates knowledge and
skills.&lt;/p&gt;
&lt;p&gt;Generally, a software project
&amp;quot;failure&amp;quot; is little more than excessive labor hours for relatively low-value
lessons learned.  You may, for example, learn that your customers lie, or can't
focus on a problem, or get distracted, or have no sense of perspective. You may
learn that your developers aren't very good.  You may learn that your tool
vendors misrepresented their products.  These can be learned more cheaply or
more dearly.  The most expensive way to learn these lessons is by investing
millions in software development only to learn that &lt;a class="reference external" href="http://www.fox.com/house/"&gt;everybody
lies&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;Often, software
development projects are labeled &amp;quot;failure&amp;quot; for the wrong reasons.  For example,
we have some random business problem (&amp;quot;can't consolidate 85 spreadsheets&amp;quot;).  We
have over-blown user requirements (&amp;quot;must include an in-ground swimming pool with
wide-screen underwater TV&amp;quot;).  We fail to deliver on the requirements, the
project is labeled a failure and people are sacked.  However, the users changed
their processes and tools and can now consolidate with fewer errors.   The
business problem is solved, or perhaps reduced in scope or impact.  The
organization is satisfied and elects to focus on something that's more valuable.
How -- precisely -- is that a failure, other than a failure to deliver on
undeliverable
requirements?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-not-to-do"&gt;
&lt;h2&gt;What Not To Do&lt;/h2&gt;
&lt;p&gt;A software development risk isn't a risk of a &lt;strong&gt;loss&lt;/strong&gt;.
It doesn't have a win &lt;em&gt;vs.&lt;/em&gt; loss potential the way we see it in a simple expected-value calculation.
It's just an unexpected outcome.  Or, more precisely, an outcome with a value that
isn't commensurate with the cost.&lt;/p&gt;
&lt;p&gt;Here's the biggest possible
project planning mistake:  adding contingency fees.  For example, there's a risk
of key staff not being available.  This has a defined project premium of 5%.
This is unjustifiable since each situation is unique.  You should be asking
which specific key staff member?  Unavailable for what reason?  How do we
prevent that?  You should not be tacking money onto the
project.&lt;/p&gt;
&lt;p&gt;Here's the second biggest
project planning mistake: trying to do expected value calculations.  For
example, there's a risk of low productivity.  We assign a cost ($100,000), we
assign a probability (0.10) and we compute an expected value of $10,000 for low
productivity.  Funny, this looks like the 5% premium, with more assumptions
folded in.  Again, this is unjustifiable.  Specifically, if you anticipate a
cost of $100,000 for low productivity, what's the investment to prevent this?
You should be doing ROI calculations on your prevention
strategy.&lt;/p&gt;
&lt;p&gt;Don't waste time on the odds of &amp;quot;$#!+ Happens&amp;quot;.
Take action to prevent &amp;quot;$#!+ From Happening.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-strategies"&gt;
&lt;h2&gt;Project Strategies&lt;/h2&gt;
&lt;p&gt;For now, we're stuck
with &amp;quot;potential problems&amp;quot; being called &amp;quot;risk factors&amp;quot;.  It's common terminology
and hard to dislodge.  For each software development risk factor, you have two
strategies: prevent the problem and recover from the problem.  Indeed, all of
the software development risk factors I've ever seen are simply lists of
management mistakes, all of which are avoidable or
preventable.&lt;/p&gt;
&lt;p&gt;You shell out money to
prevent problems.  Having done that, you can set aside contingency money to
recover if something doesn't go according to plan.  Since this is software,
there's &lt;strong&gt;always&lt;/strong&gt;  a kind of recovery available; something of value can be retained.&lt;/p&gt;
&lt;p&gt;[What's distressing is the management
distaste for making intelligent choices that preserve value.  Instead we see
sweeping reorganizations that assure that little of value is
retained.]&lt;/p&gt;
&lt;p&gt;If the technology doesn't
work out, you can switch to a new technology.  If your developers aren't up to
the job, you can hire or rent new developers.  If your users lie -- well --
you've got big problems, but there are techniques for managing even this.&lt;/p&gt;
&lt;p&gt;Looking at list of &lt;a class="reference external" href="http://fox.wikis.com/wc.dll?Wiki~SoftwareDevelopmentRiskFactors~VFP%22%20target=%22NewWindow"&gt;Software
Development Risk Factors&lt;/a&gt; , we see that each one is a simple,
discoverable, preventable situation.  Some situations, appear to be difficult to
prevent.  Specifically, if we run afoul of the eight things in &amp;quot;&lt;a class="reference external" href="http://codecraft.info/index.php/archives/69/%22%20target=%22NewWindow"&gt;To
Rewrite or not to rewrite, that is the question&lt;/a&gt; &amp;quot;, we've done something
colossally stupid.  We've guaranteed that the project -- as planned -- can't
meet the expectations.&lt;/p&gt;
&lt;p&gt;This leads us to
two kinds of project problems: &lt;strong&gt;planning for failure&lt;/strong&gt;, and &lt;strong&gt;mismanaging ignorance&lt;/strong&gt;.
Both of these are labeled &amp;quot;risk&amp;quot;, but they're not random &amp;quot;$#!+ Happens&amp;quot;.
They're not like ramming a &lt;a class="reference external" href="http://www.oceannavigator.com/article.php?a=1008"&gt;submerged shipping container&lt;/a&gt;  and losing your
boat.  They're management dumbosity (a cross between dumbness and pomposity.)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="planning-for-failure"&gt;
&lt;h2&gt;Planning for Failure&lt;/h2&gt;
&lt;p&gt;Here's a great example
from &amp;quot;To Rewrite..&amp;quot;: &amp;quot;Do you honestly believe that if you rewrote it without
adding any features the resulting code would be 33% smaller than the current
code?&amp;quot;  If you can't simplify during the rewrite, then you've assured that you
will not achieve the desired simplification, and reduction in maintenance cost.
Your plan -- &lt;strong&gt;not&lt;/strong&gt;  to simplify -- won't meet anyone's expectation of a better product after the
rewrite.&lt;/p&gt;
&lt;p&gt;This isn't risk.  This is dumb
management.  Someone specifically planned to fail.  They may even write the plan
-- the plan that won't achieve the desired simplification -- down in glorious detail.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="failing-to-manage-ignorance"&gt;
&lt;h2&gt;Failing to Manage Ignorance&lt;/h2&gt;
&lt;p&gt;Here's an example risk
factor: &amp;quot;Large number of complex external interfaces&amp;quot;.  When you think about it,
this is just ignorance.  This is basic dumb project management: proceed from a
position of ignorance and insist on a budget or schedule or
both.&lt;/p&gt;
&lt;p&gt;Often, my customers demand a
price for something where I'm ignorant of scope or complexity.  I have to make
up a real number based on what I know and what I expect.  My assumptions (the
cost factors that are unsupported by facts) are sometimes called &amp;quot;risk&amp;quot; or
&amp;quot;contingency&amp;quot;.  In reality, it's the cost of ignorance, and our expected labor
to overcome the ignorance.  We just can't call it &amp;quot;ignorance&amp;quot; in a
proposal.&lt;/p&gt;
&lt;p&gt;This isn't risk.  Proceeding
without the facts is just dumb management.   There are better ways to manage
this than simply proceeding or declaring the potential cost too high and
canceling the project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bottom-line"&gt;
&lt;h2&gt;Bottom Line&lt;/h2&gt;
&lt;p&gt;The usual sense of &amp;quot;risk&amp;quot; doesn't exist for software development projects.
Unless you take &amp;quot;risk&amp;quot; as a synonym for bad management.&lt;/p&gt;
&lt;p&gt;Yes, bad things can happen that are not foreseeable.  However, for a software development
project they are the same as they are for throwing a party with the same number
of people.  They risks are microscopic, and involve things like &amp;quot;heart disease&amp;quot;,
&amp;quot;cancer&amp;quot;, &amp;quot;stroke&amp;quot;, &amp;quot;motor vehicle accident&amp;quot; that you'd find any &lt;a class="reference external" href="http://www.cdc.gov/nchs/fastats/lcod.htm"&gt;leading
cause of death&lt;/a&gt;  or &lt;a class="reference external" href="http://www.nsc.org/lrs/statinfo/odds.htm"&gt;odds of
dying&lt;/a&gt;  table.  (Note that the top three killers are diseases often
managed by life-style changes.)&lt;/p&gt;
&lt;p&gt;Projects don't &amp;quot;fail&amp;quot; in a
broad and vague way.  Managers either create a plan that can never meet
expectations or they create a plan that doesn't manage ignorance.  Then they
execute that plan until someone with budget authority realizes that the plan
isn't producing value commensurate with the cost.&lt;/p&gt;
&lt;p&gt;Maybe I've spent too much time
reading &lt;a class="reference external" href="http://www.mcbreen.ab.ca/SoftwareCraftsmanship/%22%20target=%22NewWindow"&gt;Software
Craftsmanship&lt;/a&gt; , but I think that the incremental, &lt;a class="reference external" href="http://www.scrumalliance.org/index.php/scrum_alliance/for_everyone/learning_scrum/weekly_column/weekly_column_5_15_2006"&gt;Scrum approach using TDD&lt;/a&gt;  is the only thing that
makes any sense.  Build in small pieces, each one of which creates
value.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="risk"></category><category term="cost"></category><category term="strategy"></category></entry><entry><title>Project Justification</title><link href="https://slott56.github.io/2007_01_05-project_justification.html" rel="alternate"></link><published>2007-01-05T14:31:00-05:00</published><updated>2007-01-05T14:31:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-01-05:/2007_01_05-project_justification.html</id><summary type="html">&lt;p&gt;In &amp;quot;&lt;a class="reference external" href="https://slott56.github.io/2006_09_08-its_strategic_but_its_not_but_it_was_now_its_a_burden.html"&gt;It's Strategic -- but it's not -- but it was -- now it's a
burden&lt;/a&gt; &amp;quot;, I rambled about the situation I encounter on a regular basis.
Here's a Haiku that captures the situation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Please Replace It&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It's heavily customized,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We can't install an upgrade,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We don't dare touch it.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The maintenance costs …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In &amp;quot;&lt;a class="reference external" href="https://slott56.github.io/2006_09_08-its_strategic_but_its_not_but_it_was_now_its_a_burden.html"&gt;It's Strategic -- but it's not -- but it was -- now it's a
burden&lt;/a&gt; &amp;quot;, I rambled about the situation I encounter on a regular basis.
Here's a Haiku that captures the situation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Please Replace It&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It's heavily customized,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We can't install an upgrade,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We don't dare touch it.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The maintenance costs are killing my customer,
but the rewrite costs are unacceptable.  Even identifying a replacement product
is impossible to discuss because there just isn't money available to invest so
that we can stop bleeding money.  No matter how many times I do the math, I
can't understand a single word of what they're
saying.&lt;/p&gt;
&lt;p&gt;Our maintenance cost is
$100,000 per year, forever.  I'll emphasize that last point: forever.  The
service life of software is often measured in decades.  Let's assume just one
decade, so we're spending $1,000,000 on maintenance for the life of the
product.&lt;/p&gt;
&lt;p&gt;Let's say that it would cost
$1,000,000 to rewrite the thing so we can redirect the maintainer to do
something else.  We spend a million now, and we get back $100,000 a year
forever.  I'll emphasize that:  we're buying an annuity that returns $100,000
per year forever.&lt;/p&gt;
&lt;div class="section" id="investment-strategy"&gt;
&lt;h2&gt;Investment Strategy&lt;/h2&gt;
&lt;p&gt;Here's where the friction
occurs.  The CIO says &amp;quot;we can't spend that million on ourselves, we have to
spend it on our internal customers.&amp;quot;  Okay.  We'll spend $1M on something for
sales or HR or production or someone outside IT.  What do we have to show for
that $1M?  $100,000 per year, forever?  If so, that's good; invest
away.&lt;/p&gt;
&lt;p&gt;However, what I often see are
whimsical project justifications that include some potential value from
integration or decision support without an actual dollar value.  Or, if there is
a dollar value, it's almost farcical.  For example, an integration project will
save two clerks from reconciling vendor billing, vendor time cards and vendor
work tickets.  What will those two clerks then be doing?  No
hint.&lt;/p&gt;
&lt;p&gt;We can redeploy one IT person, or
we can redeploy two clerks.  What's the new, high-value task for the two clerks?
Actually one's a temp, so we'll lay that one off.  That doesn't create value,
that simply reduces operating cost.  I'd rather redeploy the IT person than the
clerk.&lt;/p&gt;
&lt;p&gt;Maybe I've spent too much time
reading &lt;a class="reference external" href="http://www.mcbreen.ab.ca/SoftwareCraftsmanship/"&gt;Software Craftsmanship&lt;/a&gt; , but I think IT
undervalues itself when competing internally for investment dollars.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-question"&gt;
&lt;h2&gt;My Question&lt;/h2&gt;
&lt;p&gt;How do we get to a
rational justification for a rewrite?  Too often, managers seems willing to
spend “next years dollars” on maintenance, and seem unwilling to
spend some money this year to prevent the ongoing (perpetual, infinitely large)
costs of maintenance.&lt;/p&gt;
&lt;p&gt;While there are
problems with doing a rewrite badly, in some cases, there are problems even
starting an intelligent discussion of the need for a rewrite.  How can we
justify a rewrite instead of bleeding money on ongoing maintenance?&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="cost"></category><category term="investment"></category><category term="strategy"></category></entry><entry><title>More of the Open Source Value Proposition</title><link href="https://slott56.github.io/2006_09_30-more_of_the_open_source_value_proposition.html" rel="alternate"></link><published>2006-09-30T12:10:00-04:00</published><updated>2006-09-30T12:10:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-09-30:/2006_09_30-more_of_the_open_source_value_proposition.html</id><summary type="html">&lt;p&gt;Binstock does a quick compare and contrast
between Ruby and NetRexx, showing how an active community promoted Ruby, and
NetRexx's lack of a community left it languishing.  I think that this analysis
is only partly true, and misses part of the value of open
source.&lt;/p&gt;
&lt;p&gt;Specifically, IBM's proprietary
NetRexx can't …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Binstock does a quick compare and contrast
between Ruby and NetRexx, showing how an active community promoted Ruby, and
NetRexx's lack of a community left it languishing.  I think that this analysis
is only partly true, and misses part of the value of open
source.&lt;/p&gt;
&lt;p&gt;Specifically, IBM's proprietary
NetRexx can't be extended, revised, tweaked or improved.  It isn't the
scripting, &lt;em&gt;per se&lt;/em&gt; , that the community of users value.  It's
the ability to tweak the basic language and interpreter that is so
valuable.&lt;/p&gt;
&lt;p&gt;My theory is that the
&amp;quot;serious&amp;quot; (growing, enthused, proselytizing) community springs up when people
have a stake in the language (or interpreter or tool) itself.  In the case of
Python, the most serious advocation seems to follow from the language evolution:
the community improves an idea into a good idea; advocacy makes it a great idea;
enthusiastic support makes it part of the language (or libraries).  And -- in
the case of Python -- you have to convince the BDFL, Guido, that it's totally
Pythonic as well as a great
idea.&lt;/p&gt;
&lt;p&gt;Scripts themselves aren't the
ticket.  If the NetRexx interpreter was open source, then people would fix the
bumps and warts that they discovered while writing scripts.  For example, the
classic Python division operator had some serious problems in certain kinds of
numeric programming contexts.  It takes considerable exploration of alternatives
to propose an improvement that preserves simplicity, but adds a distinguishing
feature.  If you don't have open source, you can't -- effectively -- explore the
alternatives.&lt;/p&gt;
&lt;p&gt;The source for the tool
(or language) is the ticket.  Once you have the source, you can add, change and
delete features.  If your changes are an improvement -- and you can prove it by
using them -- then you have a compelling argument for your ideas.  If, on the
other hand, your changes are a paper-and-pencil exercise, they don't have any
more merit than the insulated development team's pet project.  Indeed, an
isolated development team has a queue of bug-fixes and enhancement requests, a
microscopic budget, and little real input except from schedule-obsessed
managers.&lt;/p&gt;
&lt;p&gt;Dynamic scripting languages
aren't successful because of the community-driven scripting.  They're successful
because of community-driven language evolution, fueled by the needs of the
community-driven scripting.&lt;/p&gt;
</content><category term="Management"></category><category term="open source"></category><category term="Enterprise IT"></category><category term="value"></category><category term="rewards"></category></entry><entry><title>It's Strategic -- but it's not -- but it was -- now it's a burden</title><link href="https://slott56.github.io/2006_09_08-its_strategic_but_its_not_but_it_was_now_its_a_burden.html" rel="alternate"></link><published>2006-09-08T13:06:00-04:00</published><updated>2006-09-08T13:06:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-09-08:/2006_09_08-its_strategic_but_its_not_but_it_was_now_its_a_burden.html</id><summary type="html">&lt;p&gt;Here's the scenario I see:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The customer bought something, and then
customized it.  The customization -- by definition -- must have had significant
strategic value.&lt;/li&gt;
&lt;li&gt;The customer set it aside, making no more
changes of any kind.  Okay, there were bug fixes, but nothing significant.  The
developers were re-assigned to something new …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;Here's the scenario I see:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The customer bought something, and then
customized it.  The customization -- by definition -- must have had significant
strategic value.&lt;/li&gt;
&lt;li&gt;The customer set it aside, making no more
changes of any kind.  Okay, there were bug fixes, but nothing significant.  The
developers were re-assigned to something new.  Perhaps a maintainer was brought
in.&lt;/li&gt;
&lt;li&gt;After a decade of neglect mixed with casual
bug-fix and work-around maintenance, they call and want a significant change to
the functionality.  The word &amp;quot;strategic&amp;quot; is used.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The cost, of course, is astronomical.
Our proposal gets thrown out because we're going to charge a fortune for someone
to reverse engineer the software.  The neglect appeared to have a minute cost,
setting up the appearance of a low-cost piece of application
software.&lt;/p&gt;
&lt;p&gt;However, neglect is a cost
which accrues from year to year.  The total cost of a decade of neglect is now
owed.  The lost knowledge has to be rebuilt.  Then software designed based on
that new knowledge.  Then the old software reworked to the new
design.&lt;/p&gt;
&lt;div class="section" id="what-happened"&gt;
&lt;h2&gt;What Happened?&lt;/h2&gt;
&lt;p&gt;It's hard to say why
software is Strategic when it's being acquired and customized, but non-strategic
for the rest of it's service life.  I've heard it described as &lt;strong&gt;Executive ADD&lt;/strong&gt;™:
an inability to focus.
This means that every shiny new idea wind up with the label &amp;quot;Strategic&amp;quot; so that it's
acceptable to pour resources into it.&lt;/p&gt;
&lt;p&gt;One consequence of Executive ADD is
&lt;a class="reference external" href="https://slott56.github.io/2006_07_11-the_root_cause_of_turnover_in_it.html"&gt;Turnover in IT&lt;/a&gt; .  Another consequence is poor
quality:  nothing is ever improved or refined.  Instead it is implemented, then
the ADD kicks in and everyone is assigned to the next shiny new
thing.&lt;/p&gt;
&lt;p&gt;What causes this flip-flopping?
I think there are several reasons, all of which stem from a feeling that
&lt;strong&gt;Software is Omniscient&lt;/strong&gt;.  Once we install it, it will so
regulate and structure our work-life that nothing bad will ever happen.  Once
we've tested it, it cannot be misused, it's a &lt;strong&gt;Thing of Beauty and A Joy Forever&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Clearly, &lt;strong&gt;Executive ADD&lt;/strong&gt;™ is caused by the failure to see how
people abuse and mistreat software.&lt;/p&gt;
&lt;p&gt;I often see examples of the &lt;a class="reference external" href="https://slott56.github.io/2005_09_17-essay_13_analysis_without_running_aground.html"&gt;Third Christmas Club Problem&lt;/a&gt; : there's a field
that isn't currently in use, so we can put data in there.  Sometimes we'll find
that our business entity has multiple state changes, but only one status code,
so end users invent new status codes to reflect combinations of the various
states.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="invisible-abuse"&gt;
&lt;h2&gt;Invisible Abuse&lt;/h2&gt;
&lt;p&gt;Why don't managers and
executives see this envelope-pushing and mistreatment?  A couple of reasons
spring immediately to mind.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The business process is already so complex
that there are numerous manual operations; fudging things in the software is
largely invisible against the background noise of manual
processing.&lt;/li&gt;
&lt;li&gt;There are limited skills or interest in
knowing what is really going on.  Who really wants to watch their staff doing
customer account updates all day just to be sure nothing &amp;quot;funny&amp;quot; is going
on?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;What we wind up with is a perception that &amp;quot;Strategic&amp;quot; software is a &lt;strong&gt;Fire and Forget&lt;/strong&gt;  proposition.
Once installed, it runs on autopilot forever.  The complexities are inherent in the business, and the
details are boring (or complex), so we'll never be 100% rock-solid sure that the
software is being used properly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="choices"&gt;
&lt;h2&gt;Choices&lt;/h2&gt;
&lt;p&gt;We have really two choices: (1) treat strategic software like any other strategic
asset and work to improve it, or (2) don't call it strategic unless it really is
the centerpiece of the business for the next few years.&lt;/p&gt;
&lt;p&gt;If it's a strategic asset, it's
someone's job to make sure it works, and to make enhancements and improvements.
It isn't a maintenance (read &amp;quot;bug fix&amp;quot;) job.  It's strategic, visionary, a
differentiator, a source of ongoing value creation.  This means that there will
be revisions, expansions, integration, new features and roll-outs.  This will
look more like a for-sale product than in-house, back-office information
technology.&lt;/p&gt;
&lt;p&gt;If it's merely business-critical, it's something you install, and then assign a maintainer to
apply bug fixes.  It isn't a differentiator; indeed, all your competitors may
have the same thing.  The vendor-supplied upgrades will be dutifully installed
as necessary.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="customization"&gt;
&lt;h2&gt;Customization&lt;/h2&gt;
&lt;p&gt;Where does customization fit into this stark dichotomy?  There is really only one
proper role for customization, and that's to transform commodity software into
strategic software.  If the customizations are strategic, then they are
visionary and a differentiator, a source of ongoing value creation.  Someone
owns those customizations, and their job is to leverage those customizations
throughout the business to maximize their
value.&lt;/p&gt;
&lt;p&gt;I think this is the only way to
avoid the following Haiku, called &amp;quot;Please Replace it,&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It's heavily customized,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We can't install an upgrade,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We don't dare touch it.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="strategic"></category><category term="Enterprise IT"></category><category term="technical debt"></category></entry><entry><title>Creating Value with Open Source Products (part 2)</title><link href="https://slott56.github.io/2006_08_31-creating_value_with_open_source_products_part_2.html" rel="alternate"></link><published>2006-08-31T18:15:00-04:00</published><updated>2006-08-31T18:15:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-08-31:/2006_08_31-creating_value_with_open_source_products_part_2.html</id><summary type="html">&lt;p&gt;Here's a novel point of view on open source
software.&lt;/p&gt;
&lt;p&gt;'In fact, one of the things
Google likes about open source software is that it facilitates secrecy. &amp;quot;If we
had to go and buy software licenses, or code licenses, based on seats, people
would absolutely know what the Google infrastructure …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Here's a novel point of view on open source
software.&lt;/p&gt;
&lt;p&gt;'In fact, one of the things
Google likes about open source software is that it facilitates secrecy. &amp;quot;If we
had to go and buy software licenses, or code licenses, based on seats, people
would absolutely know what the Google infrastructure looks like,&amp;quot; DiBona says.
&amp;quot;The use of open source software, that's one more way we can control our
destiny.&amp;quot;'&lt;/p&gt;
&lt;p&gt;Since Google is competing
against Micro$oft, IBM, Sun, Oracle, and most other software vendors, this makes
a lot of sense.&lt;/p&gt;
&lt;p&gt;But, does it apply
outside the software realm?  I would think so.  In particular, open source gives
you considerably more control over your destiny than packaged software does.&lt;/p&gt;
&lt;p&gt;The amazing amount of money poured
into customizing a &amp;quot;packaged solution&amp;quot; always leaves me breathless.  If the
package required so much rework, why not get the an open-source product, and
customize that?&lt;/p&gt;
&lt;p&gt;Indeed, how can you
call it a &amp;quot;package&amp;quot; or a &amp;quot;solution&amp;quot; if you have to customize it
extensively?&lt;/p&gt;
&lt;p&gt;In Andrew Conry-Murray's
piece, &amp;quot;Do Small Businesses Fear Open Source&amp;quot; lists a number of concerns,
including support, skills, stability and the potential complexity of building a
working architecture.&lt;/p&gt;
&lt;p&gt;Interestingly,
one obvious solution to most of the problems in the article isn't mentioned at
all.  For some reason, no one associates their standard, in-house QA programs
with open source software.  I don't understand the disconnect.  In an otherwise
outstanding article on the concerns and value of open source, QA was never
mentioned once.&lt;/p&gt;
&lt;p&gt;Perhaps I'm missing
something, but wouldn't you subject open source software to the same extensive
functional, integration and performance testing you subject your in-house
software?&lt;/p&gt;
</content><category term="Management"></category><category term="open source"></category><category term="Enterprise IT"></category><category term="rewards"></category></entry><entry><title>Google vs. the Herd</title><link href="https://slott56.github.io/2006_08_28-google_vs_the_herd.html" rel="alternate"></link><published>2006-08-28T10:52:00-04:00</published><updated>2006-08-28T10:52:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-08-28:/2006_08_28-google_vs_the_herd.html</id><summary type="html">&lt;p&gt;My thesis is that CIO's are herd animals, making
purchasing decisions based on the perceived direction of the herd.  They sense
this through &lt;a class="reference external" href="http://www.gartner.com/"&gt;Gartner&lt;/a&gt;   research reports.  There are many
competitors, but Gartner is the
name-brand.&lt;/p&gt;
&lt;p&gt;If Gartner signals a shift in the herd, then alternatives may become interesting.
How will …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My thesis is that CIO's are herd animals, making
purchasing decisions based on the perceived direction of the herd.  They sense
this through &lt;a class="reference external" href="http://www.gartner.com/"&gt;Gartner&lt;/a&gt;   research reports.  There are many
competitors, but Gartner is the
name-brand.&lt;/p&gt;
&lt;p&gt;If Gartner signals a shift in the herd, then alternatives may become interesting.
How will Google signal this shift so that the herd can change direction?
Does Google have the kind of name-brand recognition that CIO's recognize?
Will they be the &lt;a class="reference external" href="http://www.pvh.com/Brand_Izod.html"&gt;Izod&lt;/a&gt; of software the way Micro$oft is?&lt;/p&gt;
&lt;p&gt;Note that we're talking about social pressure and name-brand.  We're not talking
about quality or functionality.  We know that quality doesn't matter -- the
evidence is the endless patch cycle for MS products.  We know that functionality
doesn't matter: corporate IT routinely removes, disables or replaces parts of
Windows before configuring a standard PC image.  Clearly, the Micro$oft solution
wasn't precisely what anyone
wanted.&lt;/p&gt;
&lt;p&gt;Interestingly, if you ask someone, they'll tell you that MS desktop software &amp;quot;just works&amp;quot;.
As if Linux on the desktop doesn't work, or Mac OS isn't a desktop operating system.
And after telling you that MS desktop software works, they'll tell you about the patch
release cycle.&lt;/p&gt;
&lt;p&gt;A great rationalization the &lt;strong&gt;Salvation&lt;/strong&gt; argument:  MS &amp;quot;standardized&amp;quot; or &amp;quot;integrated&amp;quot; desktop applications.
I've been told that before MS, the desktop was a zoo of incompatible file formats and
applications.  I didn't recall that we had profound problems with Word Star and
Visicalc.  I think that this is justification for following the herd, not a real
technical issue.&lt;/p&gt;
&lt;p&gt;My favorite rationale is &lt;strong&gt;The Decision Is Already Made&lt;/strong&gt;™:  literally, &amp;quot;we're an all
Micro$oft shop&amp;quot;.  This -- effectively -- forbids change or innovation.  Since I
prefer not to work with IIS/ASP/VB/C#, I always ask.  And when I'm given one of
the variations on &lt;strong&gt;The Decision Is Already Made&lt;/strong&gt;, I know that we will have a number of
strange problems arising from the exceptions to the rule.  The presence of
exceptions, however, is not permission to think outside the box.&lt;/p&gt;
&lt;p&gt;How will Google break up the herd?  If
MS was our Salvation, why leave it now?  If the Decision is Already Made, how
will they get people to unmake the decision?&lt;/p&gt;
</content><category term="Management"></category><category term="google"></category><category term="gartner"></category><category term="CIO"></category><category term="herd animals"></category></entry><entry><title>Tools Aren't the Answer</title><link href="https://slott56.github.io/2006_08_04-tools_arent_the_answer.html" rel="alternate"></link><published>2006-08-04T10:47:00-04:00</published><updated>2006-08-04T10:47:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-08-04:/2006_08_04-tools_arent_the_answer.html</id><summary type="html">&lt;p&gt;See &lt;a class="reference external" href="http://jroller.com/page/cpurdy"&gt;/dev/null&lt;/a&gt; 's post &amp;quot;&lt;a class="reference external" href="http://jroller.com/page/cpurdy?entry=and_the_braindead_award_goes"&gt;And the Braindead Award goes to...&lt;/a&gt; &amp;quot; for an
interesting tale of things that turn up in spite of 100% test
coverage.&lt;/p&gt;
&lt;p&gt;Here's the recap:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;They have 100% test coverage.&lt;/li&gt;
&lt;li&gt;Yet, they uncovered an error in an abstract superclass.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How is this possible?  How was it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See &lt;a class="reference external" href="http://jroller.com/page/cpurdy"&gt;/dev/null&lt;/a&gt; 's post &amp;quot;&lt;a class="reference external" href="http://jroller.com/page/cpurdy?entry=and_the_braindead_award_goes"&gt;And the Braindead Award goes to...&lt;/a&gt; &amp;quot; for an
interesting tale of things that turn up in spite of 100% test
coverage.&lt;/p&gt;
&lt;p&gt;Here's the recap:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;They have 100% test coverage.&lt;/li&gt;
&lt;li&gt;Yet, they uncovered an error in an abstract superclass.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How is this possible?  How was it possible to turn up an untested method in spite of 100% test
coverage?&lt;/p&gt;
&lt;p&gt;There's a technicality in
Java that makes some things hard to test.  In this case, a method
(&lt;tt class="docutils literal"&gt;isEmpty()&lt;/tt&gt;) was overridden in each subclass.  You can't really test abstract superclasses very
well, you can only test concrete subclasses.  The superclass method was never
used by any concrete subclass, and was never
tested.&lt;/p&gt;
&lt;p&gt;So, was the 100% coverage claim
correct?  Here's one comment: &amp;quot;Clearly you did NOT have 100% test coverage,
otherwise that error would have been caught.&amp;quot;&lt;/p&gt;
&lt;p&gt;However, I disagree.  I think they &lt;strong&gt;did&lt;/strong&gt;  test every API that was implemented.&lt;/p&gt;
&lt;p&gt;That one overridden API could only be tested by creating a concrete subclass with the
purpose of testing superclass methods.   This subclass would be a contrived
beast this isn't deliverable, and only exists because someone concocted it to
exercise the superclass methods.&lt;/p&gt;
&lt;p&gt;Someone would have to understand the
design well enough to build the necessary &lt;strong&gt;Proxy&lt;/strong&gt; classes.
This sounds suspiciously complex for any test coverage tool to tangle with.&lt;/p&gt;
&lt;div class="section" id="how-would-they-know"&gt;
&lt;h2&gt;How would they know?&lt;/h2&gt;
&lt;p&gt;How would they know that a
method was always overridden?  What test coverage tool does that analysis?
Indeed, who knew that analysis even needed to be done in the first
place?&lt;/p&gt;
&lt;p&gt;&amp;quot;I believe that we (as an industry) can get to Zero Defect Software, but do we actually have the tools to
get there today?&amp;quot;  is Purdy's rhetorical question.&lt;/p&gt;
&lt;p&gt;I think the tools can &lt;em&gt;never&lt;/em&gt;
exist to provide the kind of 100% coverage he's looking for.  Why not?  Why
can't we build a perfect unit test tool that absolutely proves our software
works?&lt;/p&gt;
&lt;p&gt;The root problem is that we can't create an automated proof our software works.
By prove, I mean absolute, iron-bound, 100% proof of correctness.&lt;/p&gt;
&lt;p&gt;Why not?  We can't create an automated proof of loop termination.&lt;/p&gt;
&lt;p&gt;Assume that HP/Mercury wrote a utility called &lt;tt class="docutils literal"&gt;terminates()&lt;/tt&gt;
which returned True if a given
function would terminate.
Assume I wrote a function, &lt;tt class="docutils literal"&gt;whistle()&lt;/tt&gt; which
plays a MIDI file using samples of tea-kettle whistles.
Then I wrote this unit test:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def test_whistler():
    while terminates( test_whistler ):
        whistle( &amp;quot;stars_and_stripes.mid&amp;quot; )
&lt;/pre&gt;
&lt;p&gt;What does this do?
If the &lt;tt class="docutils literal"&gt;terminates()&lt;/tt&gt; function thinks that &lt;tt class="docutils literal"&gt;test_whistler()&lt;/tt&gt;
will terminate, it has to loop forever.&lt;/p&gt;
&lt;p&gt;Contradiction.&lt;/p&gt;
&lt;p&gt;Therefore, this &lt;tt class="docutils literal"&gt;terminates()&lt;/tt&gt; function can't exist.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="if-they-can-t-know-what-can-they-do"&gt;
&lt;h2&gt;If they can't know, what can they do?&lt;/h2&gt;
&lt;p&gt;Since absolute proof can't exist, what can we do?  It has to involve much more than
tools.  It's about people, process, tools, funding and
organization.&lt;/p&gt;
&lt;p&gt;People have to care about
perfect software.  People need the skills and education in what's possible and
how they contribute to it.  A ruthless eye for quality is essential.
Additionally, the empowerment to make change to meet quality objectives is also
a necessary component.&lt;/p&gt;
&lt;p&gt;Process is the
most important part.  Tools can't do everything.  Therefore, manual inspections,
walkthroughs and reviews are as important as anything else.  Properly scheduled
reviews are critical; if you are forced to wait a week, you make assumptions and
move on.  It's critical to get feedback early and often, or an assumption
solidifies into design, accretes features and eventually fossilizes into
coprolite.&lt;/p&gt;
&lt;p&gt;Funding and Organization
must assure that &amp;quot;shipping something which works&amp;quot;, and &amp;quot;passed all the tests&amp;quot;,
and &amp;quot;deadlines matter most&amp;quot; are foreign concepts.  Funding should never trump
defect removal by reducing staff, tools or schedule.  The organization,
similarly, should never play the &amp;quot;too busy doing other things&amp;quot; trump
card.&lt;/p&gt;
&lt;p&gt;Tools are least important.  Good
tools help, but it's the people and the processes that make a
difference.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-they-did-right"&gt;
&lt;h2&gt;What they did right&lt;/h2&gt;
&lt;p&gt;Purdy found the defect. Therefore, a process worked.
It's hard to say which process, but something worked.&lt;/p&gt;
&lt;p&gt;Purdy says &amp;quot;... we carefully
designed, implemented, tested (100% API coverage!), reviewed, and it still
slipped through&amp;quot; which isn't quite correct.  It didn't slip through.  An
additional review caught it, or we wouldn't have the benefit of the posting and
the lessons learned.&lt;/p&gt;
&lt;p&gt;That additional --
possibly informal -- review caught the error.  I guess this means that the
additional review process is important, and should be added to their current
practices.&lt;/p&gt;
&lt;p&gt;I say that what they're
doing worked, and they should do more of it.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="test coverage"></category><category term="abstract classes"></category></entry><entry><title>The Root Cause of Turnover in IT</title><link href="https://slott56.github.io/2006_07_11-the_root_cause_of_turnover_in_it.html" rel="alternate"></link><published>2006-07-11T14:40:00-04:00</published><updated>2006-07-11T14:40:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-07-11:/2006_07_11-the_root_cause_of_turnover_in_it.html</id><summary type="html">&lt;p&gt;Why does IT have such a high turnover?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Technology appeal?&lt;/li&gt;
&lt;li&gt;Money?&lt;/li&gt;
&lt;li&gt;Boredom?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No.  None of those.  We can
look at Maslow, but it's too high-level.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Self-Actualization?&lt;/li&gt;
&lt;li&gt;Self-Esteem?&lt;/li&gt;
&lt;li&gt;Belonging?&lt;/li&gt;
&lt;li&gt;Safety and Security?&lt;/li&gt;
&lt;li&gt;Physical Needs?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most IT jobs pay pretty well,
above the median income.  Look at &lt;a class="reference external" href="http://mcpmag.com/salarysurveys/"&gt;MCP Magazine&lt;/a&gt;  or &lt;a class="reference external" href="http://www.informationweek.com/731/salsurvey.htm"&gt;InformationWeek&lt;/a&gt; , for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Why does IT have such a high turnover?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Technology appeal?&lt;/li&gt;
&lt;li&gt;Money?&lt;/li&gt;
&lt;li&gt;Boredom?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No.  None of those.  We can
look at Maslow, but it's too high-level.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Self-Actualization?&lt;/li&gt;
&lt;li&gt;Self-Esteem?&lt;/li&gt;
&lt;li&gt;Belonging?&lt;/li&gt;
&lt;li&gt;Safety and Security?&lt;/li&gt;
&lt;li&gt;Physical Needs?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most IT jobs pay pretty well,
above the median income.  Look at &lt;a class="reference external" href="http://mcpmag.com/salarysurveys/"&gt;MCP Magazine&lt;/a&gt;  or &lt;a class="reference external" href="http://www.informationweek.com/731/salsurvey.htm"&gt;InformationWeek&lt;/a&gt; , for example.   Compare this
with &lt;a class="reference external" href="http://www.census.gov/hhes/www/income/income.html"&gt;census&lt;/a&gt;  data on income
levels.&lt;/p&gt;
&lt;p&gt;So, we're into the belonging,
self-esteem and self-actualization levels of Maslow.  This post isn't going to
beat the standard drums of bad management.  This isn't about managers who don't
listen, or managers who aren't flexible, or that
junk.&lt;/p&gt;
&lt;p&gt;No, the reason IT people turn
over so quickly is because they are &lt;strong&gt;forced&lt;/strong&gt;
out by a manager's appallingly bad problem-solving
skills.&lt;/p&gt;
&lt;div class="section" id="the-curtain-rises"&gt;
&lt;h2&gt;The Curtain Rises&lt;/h2&gt;
&lt;p&gt;Projects start with an
initiating incident, a situation, a stumbling block.  It's generally something
trivial, but it's the last straw, the one that broke the camel's
back.&lt;/p&gt;
&lt;p&gt;For example, we have a data feed
that contains labor records that are filled with errors.  We can't, however,
reconcile those errors unless we put the labor records side-by-side with
invoices, bills, production schedules and some other stuff to get really solid
comparison reports.&lt;/p&gt;
&lt;p&gt;While ugly, it
isn't a problem until someone gets sick while someone else is on vacation, and
management discovers this rat's nest of spreadsheets, MS-access databases, and
ad-hoc processing to try and locate the labor hour reporting
problems.&lt;/p&gt;
&lt;p&gt;Management's solution: &lt;strong&gt;This Requires Software&lt;/strong&gt;™.   Note that we haven't stated
a problem, or really talked rationally about candidate solutions.  We've leaped
past all of the thinking and picked the latest and greatest buzzword; in this
case, &lt;strong&gt;Data Warehouse&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-first-act"&gt;
&lt;h2&gt;The First Act&lt;/h2&gt;
&lt;p&gt;Once we've determined
that our labor hour problem is repaired by a Data Warehouse, we immediately hire
someone to build one of those warehouse things.
Immediately.&lt;/p&gt;
&lt;p&gt;The important thing about the &lt;em&gt;immediately&lt;/em&gt;
is that we haven't really spent too much time thinking this through.  We've
drafted a project charter that amounts to the following:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Problem: We don't have a data
warehouse.&lt;/li&gt;
&lt;li&gt;Forces:  We can build or we can buy.  We can
use contractors or in-house staff.&lt;/li&gt;
&lt;li&gt;Solution: Build a data warehouse.&lt;/li&gt;
&lt;li&gt;Consequences:  We can use this for things like
resolving labor reporting.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that the real problem (incorrect labor reports) is tangential -- almost irrelevant --
to the project charter.  We've managed to refocus from the real problem to some
technical thing that we &lt;em&gt;hope&lt;/em&gt;
will solve the problem.  We can't prove anything, since we leapt past problem
definition to designing the software solution.&lt;/p&gt;
&lt;p&gt;There are two branches in the road: Contractors or Staff.&lt;/p&gt;
&lt;p&gt;There's a hiring freeze (or we can't justify hiring more staff), and we have to bring in
Contractors.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;If we're disciplined, we require a
Statement of Work, and an estimate.  The estimate shows that this project is
expensive and daunting.  We're forced to actually think through the &amp;quot;situation&amp;quot;,
the &amp;quot;problem&amp;quot; and what we're pitching as a solution.  This is unpleasant, and
often causes us to abandon the DW, and just fix the reporting problem.  Note
that we didn't pay the contractors for their help; indeed, we complained about
their solution being &amp;quot;too vague&amp;quot; because it reflected the vagueness in the
request for proposal.&lt;/li&gt;
&lt;li&gt;If we're not disciplined, we bring in
contractors, and start paying.  After a while, the warehouse they're building
diverges from the situation we hoped it would address.  We fire the contractors
after spending millions on a non-solution to the unstated problem.  Consequence:
turnover in the contractor
organization.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We hire someone, and explain the situation.  They're happy to have a job.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;If we're disciplined, we demand a project
plan.  It proves expensive and daunting.  Now we're forced to think through the
&amp;quot;situation&amp;quot;, the &amp;quot;problem&amp;quot; and what we're pitching as a solution.  We reassign
our warehouse person.  Effectively lying to them about the job and the goals.
Consequence: turnover.&lt;/li&gt;
&lt;li&gt;If we're not disciplined, but still
managed to hire a self-starter, they start work.  After a while, the warehouse
they're building diverges from the situation we're addressing.  We wind up
reassigning the warehouse person.  We have -- effectively -- lied to them about
the job and the goals.  Consequence:
turnover.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="the-second-act"&gt;
&lt;h2&gt;The Second Act&lt;/h2&gt;
&lt;p&gt;The contractors (or the staff)
have built a warehouse-like thing that doesn't quite address the situation.
Performance is bad, and it's mission critical.  Why is performance bad?  We told
people to stop gold-plating the application, just get something into production
on the given date.  In effect, we mandated bad performance by insisting that the
date was more important than anything
else.&lt;/p&gt;
&lt;p&gt;Since performance of the
warehouse-like thing is bad, and it is also mission-critical, we now need
someone to speed up the performance of the application.  Recall that we either
fired the contractors or reassigned the staff.  After being lied to, they left.&lt;/p&gt;
&lt;p&gt;We are forced to bring in more
contractors (or more staff) to address performance.  We describe the half-baked
data warehouse.  We describe the situation.  Neither add up to a &amp;quot;problem&amp;quot; with
a &amp;quot;solution&amp;quot;.  Instead, it is a rapidly worsening &amp;quot;situation&amp;quot;.&lt;/p&gt;
&lt;p&gt;Indeed, we are
specifically asking the new person for a &lt;a class="reference external" href="https://slott56.github.io/2006_06_19-faerie_dusttm.html"&gt;Faerie Dust Solution™&lt;/a&gt; ; something that it
is impossible to deliver.  We want it faster, but we won't allow changes to the
data structures or algorithms.  Indeed, we don't really have time for a lot of
analysis, we just need it fixed.  And we all know that &amp;quot;analysis&amp;quot; is just a
rat-hole of lost time.&lt;/p&gt;
&lt;p&gt;In spite of the
obvious Fairy Dust, who wouldn't stick around to catch a few paychecks?  It's
okay if the underlying problem is off limits, technology change is off limits,
and the existing architecture is sacred; it's okay if the organization must
&amp;quot;preserve the investment.&amp;quot;  Getting paid to listen to this nonsense is better
than not getting paid.  Anyone would listen to this for as long as we're willing
to pay them.&lt;/p&gt;
&lt;p&gt;So, when the contractors
(or staff) fail to make significant performance improvements, they're fired or
reassigned.  In effect, we lied to them to get them on board.  We told them
about a thing we're calling a warehouse which doesn't really exist.  We told
them about an architecture that doesn't really work.  And, best of all, when
they found the real labor hour reporting problem, they stopped making progress
on the &lt;strong&gt;Software&lt;/strong&gt; we've been imagining since the curtain went up.&lt;/p&gt;
&lt;p&gt;We reassign them.  They quit.  We created more turnover in IT.&lt;/p&gt;
&lt;p&gt;Note that the fantasy &lt;strong&gt;Software&lt;/strong&gt;
(which somehow improves something about labor hour reporting or error
correction), may be little more than a hack-around to one or more broken
business processes.   It also may be a solution that got conflated with random
Data Warehouse buzzwords.  Either way, we're lying about the problem and the
solution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-third-act"&gt;
&lt;h2&gt;The Third Act&lt;/h2&gt;
&lt;p&gt;The third act is a strategic
refocus on -- whatever.  The project is either cancelled, or suspended, or put
on hold, or rescoped.  The words don't matter.  What matters is that there's a
change in the project and the people involved are not doing what we originally
asked them to do.&lt;/p&gt;
&lt;p&gt;We have, in essence asked them to be something, and then devalued that thing.  They quit.  We create
turnover by creating a situation in which people cannot succeed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="we-can-t-fix-it"&gt;
&lt;h2&gt;We can't fix it&lt;/h2&gt;
&lt;p&gt;Clearly, this is the way IT is.
It is an inescapable consequence of applying technology to information that
projects get cancelled, scope changes, people get
reassigned.&lt;/p&gt;
&lt;p&gt;Right?&lt;/p&gt;
&lt;p&gt;I disagree.  Scope-change is not a
logical consequence of IT.  Scope-change is a logical consequence of wrong
scope.  Wrong scope happens for two reasons.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Defining scope in the first place.  If we do
away with &amp;quot;scope&amp;quot;, we do away with &amp;quot;scope creep&amp;quot;.  This is -- superficially --
ridiculous.  However, after reading an &lt;a class="reference external" href="http://agilemanifesto.org/"&gt;Agile Manifesto&lt;/a&gt;  and looking at Agile
methodologies, part of the reason Agile techniques work is because the static,
fixed, &lt;strong&gt;Grand and Glorious Greater Scope&lt;/strong&gt;, is set aside for something more
realistic and useful.&lt;/li&gt;
&lt;li&gt;Defining the wrong scope.  If we must have a
scope, why can't we have a scope that defines real problems that real people
really have?  Why do we have to write vague (incorrect, misleading) statements?
A generalization is the same thing as under-specification; why do we complain
when our specific problem isn't solved by a general
solution?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We define the wrong scope for a number of reasons.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;We're afraid of &amp;quot;point solutions&amp;quot;.  Why
solve this one problem?  That's a lot of money.  Why can't we solve something
more general, and get more bang for our buck?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We don't want to solve the &amp;quot;labor hours problem&amp;quot;, that's too specific.  We want to solve all data reconciliation problems.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;We're afraid of &amp;quot;naming names&amp;quot;.
Identifying a specific problem can result in embarrassment, termination or legal
action.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The labor hour reporting involves subcontractors behaving badly, or it involves purchasing behaving badly.  Some of it could -- actually -- be illegal.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;We're afraid of &amp;quot;root causes&amp;quot;.
Identifying the root cause of a problem can require a lot of cooperative work,
and may put us in the position of naming names.  If we focus on the technology,
not the organization, we don't have to do as much work, and we don't run the
risk of embarrassing (or angering) someone important.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If we locate the real reason for contractors misreporting their hours, it may involve incomplete work planning or incomplete task assignments.  It may involve rotten communication with our subcontractors at any of a large number of organizational touch-points.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;We're afraid of &amp;quot;becoming a target&amp;quot;.  If
we're very specific, someone else may fix the problem another, cheaper way and
we're left with nothing to do.  Worse, if we're specific, the Talmudic scholars
and lawyers can spring out of the woodwork, split hairs, and prove that our
specific problem never existed in the first place.  Either way, we're an
embarrassing nay-sayer, describing problems that are already solved or never
existed as described.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After writing an RFP, the manager of purchasing may fix the touch-point, providing better and more complete information to the contractors.  Or, a legal-eagle may say the the definition of &amp;quot;labor hour input&amp;quot; is incorrect, and &amp;quot;input&amp;quot; doesn't happen when they enter the hours, but when the hours are accepted.  The &amp;quot;incorrect&amp;quot; situation happens &amp;quot;before input&amp;quot;.  The problem is reframed into something new.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="the-illusion-of-control"&gt;
&lt;h2&gt;The Illusion of Control&lt;/h2&gt;
&lt;p&gt;What do these things have
in common?  Most of these are about the &lt;strong&gt;Illusion of Control&lt;/strong&gt;.
When we wring our hands over the
cost of a point solution, we're really admitting that (a) the problem isn't that
valuable and (b) we can't find a fix with a cost commensurate with the value.
Who wants to admit that they can't control what's going on?  When we avoid names
and root causes, we're protecting someone else's Illusion of Control.  If the
problem slips away from us (solved or reframed out of existence) we appear to
have lost control.&lt;/p&gt;
&lt;p&gt;To maintain our
Illusion of Control, we define scope badly.  Sometimes we don't define the scope
at all, which gives us a very satisfying feeling of control.  By failing to
define the scope correctly, we wind up misleading people, reassigning them, and
creating IT turnover.&lt;/p&gt;
&lt;p&gt;Turnover isn't part-and-parcel of IT.  Nor is scope creep.  It's all just failure to focus on
the actual problem.  It's really our feeble efforts to maintain the Illusion of
Control.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-do-we-do"&gt;
&lt;h2&gt;What do we do?&lt;/h2&gt;
&lt;p&gt;How do we reduce IT turnover?
Easy:  be honest.  Define project scope correctly.&lt;/p&gt;
&lt;p&gt;Define the real problem: if
the cost to fix is out of line with the cost to leave it alone, so be it.  Name
the names: if people don't like it, either you've fixed the organization, or
you'll be invited to leave a dysfunctional organization.  It doesn't look bad on
your resume, since you can document the real reason you were pressured out.  It
isn't &amp;quot;just political&amp;quot; anymore, it's specific bad
behavior.&lt;/p&gt;
&lt;p&gt;Find the root causes:
they're cheaper to fix, and the fix is permanent.  Be a target:  if the problem
gets solved (or reframed out of existence), act like you own the solution;
follow up with metrics on how well you did the problem identification and how
well you motivated others to solve
it.&lt;/p&gt;
&lt;p&gt;When you hire (or rent) people,
they'll actually do what they're expecting to do.  There won't be the same
egregious level of scope creep.  People will tend to stay where they're
valued.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="Enterprise IT"></category><category term="turnover"></category><category term="problem-solving"></category></entry><entry><title>Creating Value with Open Source Solutions</title><link href="https://slott56.github.io/2006_07_11-creating_value_with_open_source_solutions.html" rel="alternate"></link><published>2006-07-11T14:23:00-04:00</published><updated>2006-07-11T14:23:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-07-11:/2006_07_11-creating_value_with_open_source_solutions.html</id><summary type="html">&lt;p&gt;What is the reward structure for open source?&lt;/p&gt;
&lt;p&gt;If a corporate IT team builds software
using open source components, CP insists, they've made a fundamental blunder.  I
forget CP's litany of concerns, but he worries that the software is unproven,
untrustworthy, risky, etc., etc.&lt;/p&gt;
&lt;p&gt;My argument that &amp;quot;you have the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;What is the reward structure for open source?&lt;/p&gt;
&lt;p&gt;If a corporate IT team builds software
using open source components, CP insists, they've made a fundamental blunder.  I
forget CP's litany of concerns, but he worries that the software is unproven,
untrustworthy, risky, etc., etc.&lt;/p&gt;
&lt;p&gt;My argument that &amp;quot;you have the source&amp;quot; means nothing to CP, since any commercial
license also has a complex source-escrow clause that -- he claims -- provides
the same level of assurance.  Unless, of course, your commercial package is no
longer officially supported, then all bets are off.  But somehow, lawyers will
cover this base to CP's satisfaction, and actually having the source isn't as
good.&lt;/p&gt;
&lt;p&gt;But CP does raise one point of
some value:  what about innovation?  What happens when the open source author
moves on, and the package
stagnates?&lt;/p&gt;
&lt;div class="section" id="rewarding-innovation"&gt;
&lt;h2&gt;Rewarding Innovation&lt;/h2&gt;
&lt;p&gt;First, open source tends
to be far more innovative than commercial products.  We have to separate open
source from individual efforts.  In CP's world, open source means an individual
developer slaving away for the love of the craft.  This is often false, and
consequently, misleading.&lt;/p&gt;
&lt;p&gt;An individual
contributor's rewards are clearly different from an open source community's
reward structure.  And, of course, corporate users of open source have their own
internal rewards, as well as a contribution to the open source author (or
community) rewards.  Since all of these are separate, it's helpful to have a
nice Information Week article to lay out some of the
issues.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="corporate-it-rewards"&gt;
&lt;h2&gt;Corporate IT Rewards&lt;/h2&gt;
&lt;p&gt;As a consumer of OS
projects, a corporate IT department is rewarded by implementing (a) cheap, and
(b) effective solutions to problems.  Open Source software tends to be more
standardized than commercial products, making it more adaptable.  Further, the
presence of the source, makes it easier to understand, adapt and maintain.  It's
a big win, all the way around.&lt;/p&gt;
&lt;p&gt;But how can corporate IT reward an open source community or the authors?&lt;/p&gt;
&lt;p&gt;Acknowledgment is a
significant part of the reward structure.  Corporate IT should clearly and
boldly document the technology stack for the various applications that are built
and maintained.  Intranet web sites should have links and logos for the OS
projects.  Since corporate users now have to support the OS project, they should
become active, visible members of the
community.&lt;/p&gt;
&lt;p&gt;Serious use of Open Source
projects means that the solution developers can find problems, extensions and
new directions.  Much of this can help the open source community.  Feedback --
in the form of fixes and extensions -- is what validates the design of an Open
Source project.  This intellectual investment increases the value of the
project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-about-money"&gt;
&lt;h2&gt;What About Money?&lt;/h2&gt;
&lt;p&gt;Money is always a good thing.
Some open source authors have day jobs because their open source project
is so valuable.  A company is willing to put up with time spent nurturing an
open source community, in order to maximize the value from the open source
project.&lt;/p&gt;
&lt;p&gt;In the more common case, the
open source author has a day job and builds open source solutions entirely
outside their work life.  Their company is unwilling to foster an open source
community.  Or their company doesn't make direct use of the open source project.&lt;/p&gt;
&lt;p&gt;Perhaps the most rare situation arises
with OS projects that also have commercially usable counterparts.  MySQL, for
example, has a commercial license, as well as supporting an open source
community.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conflicts-and-shifts"&gt;
&lt;h2&gt;Conflicts and Shifts&lt;/h2&gt;
&lt;p&gt;Babcock's article identifies
the conflicting goals of creating proprietary solutions that include open source
components.  This provides some prominent reasons why open source contributors
aren't rewarded appropriately for their
contributions.&lt;/p&gt;
&lt;p&gt;Perhaps, however, as open source use matures, the economics will shift.&lt;/p&gt;
&lt;p&gt;Currently, we have two ways of
using open source components.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;Blind Trust&lt;/strong&gt;.  We download it, use it, and hope that
the rest of the community has thoroughly vetted the project.  This is the way
most organizations use products like Apache or Linux.  They just download it and
use it without giving it much more thought than that.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Healthy Respect&lt;/strong&gt;.  We download it, put it through an
acceptance test cycle, and determine that it is fit for purpose and can be used
in our in-house solutions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are
many war stories where people find that open source was expensive, perhaps
because of the support required.  This is not a third scenario, because it leads
to open source being banned or deprecated.  Once consequence of an official
position against open sources is that it forces the organization to use PERL,
Apache and Linux in &lt;strong&gt;Blind Trust&lt;/strong&gt; mode.&lt;/p&gt;
&lt;p&gt;Using Open Source software in &lt;strong&gt;Healthy Respect&lt;/strong&gt;  mode means that we put OS projects
through the same processes we put our in-house solutions.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Configuration Management&lt;/strong&gt;.  Rather than simply downloading
blindly, someone is in charge of a subversion (or CVS) repository for the latest
and greatest, the official, the development and the testing releases of open
source packages.  This person can create value in the OS community by validating
the releases.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Testing&lt;/strong&gt;.  Rather than implementing blindly,
someone has specific use cases, and conducts performance, integration, and
functional tests.  This person can create value in the OS community by reporting
bugs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Patching&lt;/strong&gt;.  Rather than deprecating OS
software, someone can look into the problem, and determine if it is fixable and
how to share the fix.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extending&lt;/strong&gt;.  Perhaps the most valuable
contribution from a mature organization is the extensions and new directions for
an open source project.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these quality-related activities feed back to the open source community.  But more
importantly, the people being paid to do this work, are being paid to create and
maintain open source projects.&lt;/p&gt;
&lt;p&gt;This mature use of open source puts a solid, predictable, corporate-friendly reward
structure in place.  Once people are paid to contribute, the &amp;quot;business risks&amp;quot;
are eliminated; eliminated in the sense that being able to explain the reward
structure to lawyers and accountants reduces the sillier objections to open
source solutions.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="open source"></category><category term="enterprise IT"></category><category term="rewards"></category></entry><entry><title>My Microsoft Blind-Spot</title><link href="https://slott56.github.io/2006_05_04-my_microsoft_blind_spot.html" rel="alternate"></link><published>2006-05-04T14:08:00-04:00</published><updated>2006-05-04T14:08:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-05-04:/2006_05_04-my_microsoft_blind_spot.html</id><summary type="html">&lt;p&gt;Hobbit says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Everything in the windows world does not
directly work with the &amp;quot;rapidly-evolving&amp;quot; windows api's (for example, c# devs
rarely concern themselves with api calls.) If there is such a lack of clarity in
these API's causing a &amp;quot;barrier to innovation,&amp;quot; why is windows still the easiest
and most …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;Hobbit says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Everything in the windows world does not
directly work with the &amp;quot;rapidly-evolving&amp;quot; windows api's (for example, c# devs
rarely concern themselves with api calls.) If there is such a lack of clarity in
these API's causing a &amp;quot;barrier to innovation,&amp;quot; why is windows still the easiest
and most popular platform to develop
on?&lt;/p&gt;
&lt;p&gt;&amp;quot;I would argue that development
tools, languages and technologies are one of the few areas that MS actually
excels, and that love it or not, it's played a big role in their market
dominance.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First, there's a
distinction being emphasized here, between application programming (in C#, apart
from low-level API's) and platform programming (where the low-level API's matter
more).  This is an important distinction and gets at the heart of my
complaint.&lt;/p&gt;
&lt;p&gt;Tangentially, there's a the
question of &amp;quot;easy&amp;quot; and &amp;quot;popular&amp;quot;, which are not what I'm complaining about.
Many people are willing to pay top dollar for the &amp;quot;easy&amp;quot; part of Windows.  Other
people consider Windows to be essential to success because it's popular.  These
are different reasons; sometimes people will buy into both, sometimes only one
or the other.&lt;/p&gt;
&lt;p&gt;One of my customers is
big on the &amp;quot;easy&amp;quot; and cares very little for the &amp;quot;popular&amp;quot;, as an example.  They
feel that the Windows Visual Studio has so many easy-of-use factors that it is
worth every penny.  And they feel that they can -- at any time -- cut the cord
and switch to Mono &lt;a class="reference external" href="http://www.mono-project.com/Main_Page"&gt;http://www.mono-project.com/Main_Page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally,
I reject the proposition that &amp;quot;tools, languages and technologies [have] played a
big role in their market dominance.&amp;quot;  I think that marketplace dominance is a
herd-mentality feedback loop.  Other people are using it, so I'll use it, too.
Popularity isn't about
&lt;em&gt;superior&lt;/em&gt;
technology, but about good-enough technology.  Popularity isn't about
innovation, but about stability.  Indeed, some claim that it's all about
predictability &lt;a class="reference external" href="http://www.joelonsoftware.com/design/1stDraft/03.html"&gt;http://www.joelonsoftware.com/design/1stDraft/03.html&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="the-api-bottleneck"&gt;
&lt;h2&gt;The API Bottleneck&lt;/h2&gt;
&lt;p&gt;My problem may be
that I see the really innovative stuff in the LAMP (Linux, Apache, MySQL,
Python/PHP/Perl) or MARS (MySQL, Apache, Rails, Solaris) worlds first.
If it is viable, it moves into Windows.
One example is the sophisticated FFMPEG &lt;a class="reference external" href="http://ffmpeg.sourceforge.net/index.php"&gt;http://ffmpeg.sourceforge.net/index.php&lt;/a&gt; application suite, which doesn't seem to
be a Windows innovation.&lt;/p&gt;
&lt;p&gt;This is not to say that the open source world &lt;em&gt;owns&lt;/em&gt;
innovation.  Good stuff arises first in Windows, also, but it is generally not
so envelope-pushing.  In Windows, you can create a nice application, but you'd
be hard pressed to create a new &lt;em&gt;kind&lt;/em&gt; of application.&lt;/p&gt;
&lt;p&gt;This could be my bias
in watching LAMP-technology arena more closely than the Windows arena.  Or, it
could be that the open source world is free from constraints imposed by the MS
technology stack.  By constraints, I mean the &amp;quot;what does this do?&amp;quot; mystery.
There's a limit to these efforts at &amp;quot;lower-level&amp;quot; innovation when you can't be
sure what the API rally does.&lt;/p&gt;
&lt;p&gt;At the
end-user application-level, if the API's aren't visible in C# using .NET, then
the effect is indirect.  What happens is that upper-tier software (like
applications in C#) are only hampered slightly by the pace of innovation in C#;
C#, on the other hand, is hampered by the mysterious API's.&lt;/p&gt;
&lt;p&gt;I have to grant that C# does isolate
application developers from the opacity of the underlying OS.  However, in the
long run, I think this leads to complex and fragile architectures that will get
trumped by simpler and more effective
solutions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="standards"&gt;
&lt;h2&gt;Standards&lt;/h2&gt;
&lt;p&gt;As a tangent, I notice that library definitions in Python are filled with &amp;quot;doesn't
work the same in Windows.&amp;quot;  To me, this implies that there's a right way, a
wrong way, and a Windows way.  While it may be popular and easy-to-use, it seems
to have problems.&lt;/p&gt;
&lt;p&gt;If the
documentation said &amp;quot;doesn't work the same in Linux&amp;quot;, then I'd have to agree that
Windows is the standard for correctness.  But given that there's a POSIX
standard &lt;a class="reference external" href="http://www.posix.com/posix.html"&gt;http://www.posix.com/posix.html&lt;/a&gt; and no Windows standard, I'm left to think
that the presence of a standard for the API's is one of the reasons for
innovation in this arena.&lt;/p&gt;
&lt;p&gt;On the other hand, it could be simply that I watch the LAMP community more closely than the
Windows community.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="microsoft"></category><category term="lamp"></category></entry><entry><title>The Leading Edge (Revised)</title><link href="https://slott56.github.io/2006_04_26-the_leading_edge_revised.html" rel="alternate"></link><published>2006-04-26T19:15:00-04:00</published><updated>2006-04-26T19:15:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-04-26:/2006_04_26-the_leading_edge_revised.html</id><summary type="html">&lt;div class="section" id="is-now-the-time"&gt;
&lt;h2&gt;Is Now the Time?&lt;/h2&gt;
&lt;p&gt;First, and foremost, Open Source solutions are growing rapidly.&lt;/p&gt;
&lt;p&gt;Let's pick a random periodical
sitting in my recycling: Information Week.   There are 1579 items in
InformationWeek &lt;a class="reference external" href="http://www.informationweek.com/TechSearch/Search.jhtml;jsessionid=RN4ODNGHETZR2QSNDBCSKHSCJUMEKJVN?site_id=InformationWeek&amp;amp;personality=category&amp;amp;queryText=open+source"&gt;http://www.informationweek.com/TechSearch/Search.jhtml;jsessionid=RN4ODNGHETZR2QSNDBCSKHSCJUMEKJVN?site_id=InformationWeek&amp;amp;personality=category&amp;amp;queryText=open+source&lt;/a&gt; for 'open source'.  SOA …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="is-now-the-time"&gt;
&lt;h2&gt;Is Now the Time?&lt;/h2&gt;
&lt;p&gt;First, and foremost, Open Source solutions are growing rapidly.&lt;/p&gt;
&lt;p&gt;Let's pick a random periodical
sitting in my recycling: Information Week.   There are 1579 items in
InformationWeek &lt;a class="reference external" href="http://www.informationweek.com/TechSearch/Search.jhtml;jsessionid=RN4ODNGHETZR2QSNDBCSKHSCJUMEKJVN?site_id=InformationWeek&amp;amp;personality=category&amp;amp;queryText=open+source"&gt;http://www.informationweek.com/TechSearch/Search.jhtml;jsessionid=RN4ODNGHETZR2QSNDBCSKHSCJUMEKJVN?site_id=InformationWeek&amp;amp;personality=category&amp;amp;queryText=open+source&lt;/a&gt; for 'open source'.  SOA, in contrast, was
142 items.   There are 2413 items for Oracle.  So, I'd say that it's 65% as
important as Oracle and 11× more important than SOA.  There are 7497 items
for Micro$oft; it's 21% as important.  5121 for IBM; 30% as important as
IBM.&lt;/p&gt;
&lt;p&gt;Of course, open source -- as a
concept -- generates no revenue for this random periodical.  Open Source is
fighting for editorial space against paying customers like Oracle, IBM and
Micro$oft.  So, 1579 items without revenue dollars appears to be very
significant.&lt;/p&gt;
&lt;p&gt;Let's look at the top 10
languages in the TPCI &lt;a class="reference external" href="http://www.tiobe.com/tpci.htm"&gt;http://www.tiobe.com/tpci.htm&lt;/a&gt;.  Positions 1, 4, 6, 8 and 9 -- 42% of the
ratings -- are open-source languages.  That carries some weight with me, being
in the staffing business.  42% of my business will be in open source languages
and technologies.&lt;/p&gt;
&lt;p&gt;Bottom line on point #1, &amp;quot;is now the time...&amp;quot;,  is a resounding &lt;strong&gt;yes&lt;/strong&gt; , now is the time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-far-ahead-of-your-customers-do-you-want-to-be"&gt;
&lt;h2&gt;How Far Ahead Of Your Customers Do You Want To Be?&lt;/h2&gt;
&lt;p&gt;This quote has me puzzled: &amp;quot;you
don't want to get too far ahead of your customers&amp;quot;.
It's an interesting point of view.&lt;/p&gt;
&lt;p&gt;Why would we want to lag
behind our customers?  The reason must be because we don't want to introduce
anything new to them.  I shouldn't offer anything of higher value or lower risk
because -- well -- it doesn't say.  It only suggests that I not offer anything
novel.&lt;/p&gt;
&lt;p&gt;Let's look at some examples
where the customers take the lead in technical innovation.  The only examples
would be where customers (1) create something, and then (2) demand support for
the product that they created.  Let's see... what do people build?  It has to be
something ultra-low-tech, or people wouldn't build it on their own.&lt;/p&gt;
&lt;p&gt;The one example that I can locate for
something where the customer leads innovation is lawn care.  People create
gardens and lawns and outsource the management.  This would be LCO - Lawn Care
Outsourcing.  Lawns are ultra-low-tech: dirt and plants.&lt;/p&gt;
&lt;p&gt;In the case of lawns, we don't want to
get out in front of our customers with anything too novel.  A new kind of lawn
mower, a new fertilizer, a more robust grass seed would be something that
wouldn't sell.  Why should a lawn service offer to install a &lt;a class="reference external" href="http://www.mowbot.co.uk/"&gt;MowBot&lt;/a&gt; `
&amp;lt;&lt;a class="reference external" href="http://www.21stcentury.co.uk/special_promotions/mowbot.asp"&gt;http://www.21stcentury.co.uk/special_promotions/mowbot.asp&lt;/a&gt;&amp;gt;`_ or &lt;a class="reference external" href="http://www.friendlyrobotics.com/robomow/"&gt;RoboMow&lt;/a&gt; ?&lt;/p&gt;
&lt;p&gt;The comment suggests that I wouldn't want to even make that kind of offer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-is-corporate-it-like-lawn-care"&gt;
&lt;h2&gt;How is Corporate IT like lawn care?&lt;/h2&gt;
&lt;p&gt;Actually, there are a number of interesting parallels between Corporate IT and a Lawn Care Service.&lt;/p&gt;
&lt;p&gt;IT is all about maintenance,
support, up-time, and response to problems.  The lawn is green, very stable,
always available (weather-permitting), and someone has to fix the gopher
holes.&lt;/p&gt;
&lt;p&gt;Who designs our lawns and
gardens?  Professional landscape architects?  That's as crazy as having a
software architect design our application software.  Our maintenance programmers
are perfectly capable of building new software from
scratch.&lt;/p&gt;
&lt;p&gt;Can we leverage are lawns as
for-profit parts of our home/business? &lt;strong&gt;Wait!&lt;/strong&gt;
That's where the parallel falls down.
Indeed, that's the problem I have with
the whole &amp;quot;...you don't want to get too far ahead of your customers&amp;quot; point.&lt;/p&gt;
&lt;p&gt;If we aren't offering novel,
high-value, low-risk solutions to our IT customers, what are we saying?  We're
saying that IT isn't about &lt;em&gt;value&lt;/em&gt; ,
it's about &lt;em&gt;status quo&lt;/em&gt;.
Keeping the status quo isn't a marketplace opportunity.
It's a defensive position in response to some kind of threat.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-can-you-sell"&gt;
&lt;h2&gt;What Can You Sell?&lt;/h2&gt;
&lt;p&gt;One reason for a defensive
position is fear of failure.  A commenter suggested that I shouldn't whine because my
low-end customers can't afford a RoboMow.  This comment appears to mean that I should not
expect to sell high-end products to low-end customers.&lt;/p&gt;
&lt;p&gt;The comment means that a rejection is
such a devastating blow that I shouldn't even make an offer.  I should lag my
customers because they might reject my high-tech, leading-edge, open-source
alternative.&lt;/p&gt;
&lt;p&gt;At first this appears to
be an irrelevant tangent.  I wasn't talking about selling, I was talking about
technology leadership.  I was talking about who creates technology demand.  I
was trying to state that IT consultants -- as vendors -- create demand for open
source solution, not IT customers.  It's the vendor's offer, not the customer's
request that creates innovation, and leads to adoption of open source
technology.&lt;/p&gt;
&lt;p&gt;While the comment says to
stop whining about failing to sell, it raises the question of &amp;quot;what will you
actually sell?&amp;quot;  The answer is that I won't sell &lt;em&gt;anything&lt;/em&gt; if I don't make an offer.&lt;/p&gt;
&lt;p&gt;I have two choices: wait for customer demand or make an offer.  If I don't make a new
technology offer, I'll never grow beyond low-bidding for lawn care services.  If
I do make an offer of new technology, I may have materially changed the game for
the customers who are ready.&lt;/p&gt;
&lt;p&gt;Why would I not make the offer of new technology?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="so-what-s-the-threat"&gt;
&lt;h2&gt;So What's the Threat?&lt;/h2&gt;
&lt;p&gt;There's another threat
causes someone to say &amp;quot;you don't want to get too far ahead of your customers&amp;quot;
The threat of new technology itself.  If we're threatened by new technology,
then we don't want to introduce it.  We want to wait for our customers to demand
it.&lt;/p&gt;
&lt;p&gt;What is threatening about the
technology?  The price of entry?  The novelty?  The number of choices made
available?  The instability of a growing market?  The expanding skill set
required to service the new open-source technologies?  The lack of a clear
single-vendor hegemony?&lt;/p&gt;
&lt;p&gt;Actually, I
think all of these things are terrifying for some people.  I think that IT
positions against open source stem from simple fear of the unknown that is at
the heart of adopting new technology.&lt;/p&gt;
&lt;p&gt;An Open Source product will,
inevitably, spawn large for-profit businesses.  Apache, Linux, MySQL, PHP,
Python and Perl are all supported by for-profit businesses of various sizes.
The &lt;a class="reference external" href="http://www.ironpython.com/"&gt;Iron
Python&lt;/a&gt;   project, for example, folds Python into Micro$oft's family of
products.  Does this reduce the fear of the unknown?
Possibly.&lt;/p&gt;
&lt;p&gt;It doesn't seem to make
business sense to wait around for all fear-inducing unknowns to be resolved.
Who wants to fight for table scraps in a declining market?&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="open source"></category><category term="enterprise"></category></entry><entry><title>The Cost (and Benefit) of Open Source</title><link href="https://slott56.github.io/2006_04_24-the_cost_and_benefit_of_open_source.html" rel="alternate"></link><published>2006-04-24T23:59:00-04:00</published><updated>2006-04-24T23:59:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-04-24:/2006_04_24-the_cost_and_benefit_of_open_source.html</id><summary type="html">&lt;p&gt;I've had this conversation more than once.&lt;/p&gt;
&lt;p&gt;Me: &amp;quot;We can download something like &lt;a class="reference external" href="http://jakarta.apache.org/poi/"&gt;POI&lt;/a&gt;  to read the Excel™ files.
Or I can spend months writing something.&amp;quot;&lt;/p&gt;
&lt;p&gt;Them: &amp;quot;We have a policy against open source software.&amp;quot;&lt;/p&gt;
&lt;p&gt;Me:  &amp;quot;Do you use &lt;a class="reference external" href="http://www.apache.org/"&gt;Apache&lt;/a&gt; ?&amp;quot;&lt;/p&gt;
&lt;p&gt;Them: &amp;quot;That's different.&amp;quot;&lt;/p&gt;
&lt;p&gt;Me:  &amp;quot;How so?  Be specific in enumerating …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've had this conversation more than once.&lt;/p&gt;
&lt;p&gt;Me: &amp;quot;We can download something like &lt;a class="reference external" href="http://jakarta.apache.org/poi/"&gt;POI&lt;/a&gt;  to read the Excel™ files.
Or I can spend months writing something.&amp;quot;&lt;/p&gt;
&lt;p&gt;Them: &amp;quot;We have a policy against open source software.&amp;quot;&lt;/p&gt;
&lt;p&gt;Me:  &amp;quot;Do you use &lt;a class="reference external" href="http://www.apache.org/"&gt;Apache&lt;/a&gt; ?&amp;quot;&lt;/p&gt;
&lt;p&gt;Them: &amp;quot;That's different.&amp;quot;&lt;/p&gt;
&lt;p&gt;Me:  &amp;quot;How so?  Be specific in enumerating every difference between open-source Apache and open-source POI.&amp;quot;&lt;/p&gt;
&lt;p&gt;Them:  A whole firehose of &amp;quot;Fine, but what about...&amp;quot;&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Bugs?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Me: &amp;quot;Your software is a paragon of virtue?&amp;quot;&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;Viruses and Malware?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Me: &amp;quot;The other 1,000 users will have found it and fixed it.&amp;quot;&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;Support?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Me: &amp;quot;You have their source. You have my source.  I'm leaving, eventually, you know.&amp;quot;&lt;/p&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;Licensing?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Me:  &amp;quot;&lt;a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0"&gt;Here&lt;/a&gt; .&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Varieties of Discomfort&lt;/strong&gt;.  This conversation is really
about discomfort with software where the focus is squarely on maintenance,
adaptation, integration and support.  The bottom line on discomfort is this:
&amp;quot;Who do you sue when something goes wrong?&amp;quot;&lt;/p&gt;
&lt;p&gt;Everyone denies that &amp;quot;who do we sue?&amp;quot;
is the bottom line.  But when you provide the license agreement to the CIO and
they provide it to the lawyers, the lawyer only looks at a few clauses related
to liability.  Everything else is -- well -- technical and not the lawyer's
problem.  Once it bounces back to the CIO, it can become a hand-wringing
exercise.&lt;/p&gt;
&lt;p&gt;Previously, I mentioned
&amp;lt;{filename}/blog/2006/04/2006_04_22-the_role_of_open_source_in_the_enterprise_it_investment_strategy.rst&amp;gt; the &amp;quot;I don't see the value in converting&amp;quot;
conversation.  This misses the point of open source software entirely, reducing
it to a strange either-or proposition.  This tend to derail the conversation,
leaving the discomfort factor front and center, and ignoring the real issue of
cost and benefit.&lt;/p&gt;
&lt;p&gt;This plays out into
the question &amp;quot;Is it really about replacement or is it about where new
development will be done?&amp;quot;
This question is still way off target, since it provides a &lt;em&gt;strategy&lt;/em&gt;
for conversion.  While a strategic direction (replace vs. evolve) might be a
nice thing to have, you can't establish a direction until after you address the
underlying discomfort issue.  Clearly, I can't say this enough times: it isn't
about &lt;em&gt;converting&lt;/em&gt;
to open source.  That implies were converting &lt;em&gt;from&lt;/em&gt;
something, and reduces the conversation to strange either-or situations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Buy vs. Build&lt;/strong&gt;.  A comment notes  that the real point is the minute
incremental cost in deploying open source software.  The incremental cost of
another &lt;em&gt;license to use&lt;/em&gt;  is zero.  Support costs do rise with
number of desktops served.  Indeed, the costs of open source are often
comparable to proprietary software, but they're in-house costs.  The point is
that we can move beyond the tangential conversations about your level of
discomfort by focusing on two things: &lt;strong&gt;cost&lt;/strong&gt;  and &lt;strong&gt;benefit&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A focus on cost and benefit (and the tiny incremental cost of increasing your
usage) leads to the following:  &lt;strong&gt;What's the best approach to acquiring the needed software?&lt;/strong&gt;
We used to call this question the
&amp;quot;Buy vs. Build&amp;quot; decision.  However, it's expanded into the following bewildering
spectrum of choices:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Buy and Customize&lt;/strong&gt;. Possibly the least effective solution: begin
with a standardized commercial product, then customize it so that it cannot be
supported, maintained or enhanced.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buy&lt;/strong&gt;.  Possibly the lowest risk solution:
purchase something standardized from a commercial vendor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build&lt;/strong&gt;.  In this case, we want something
totally unique, and hope we have the technical chops.  Emphasis on the
&lt;em&gt;hope&lt;/em&gt;; not all organizations are structured to do development well.  Indeed, some IT
organizations seemed to be intentionally structured to do development
poorly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build by someone else&lt;/strong&gt;.  The strange world of &amp;quot;we want the
software, but not the collateral learnings that come from building the
software.&amp;quot;  Possibly even the worse situation of &amp;quot;we feel the process is more
important than most of the products.&amp;quot; ../C1076854706/E20060325113712.html&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Download&lt;/strong&gt;.  Possibly the most effective
solution: download it.  Want to customize it?  While still a bad idea, it's more
possible here than with something you
purchased.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Readiness Test&lt;/strong&gt;.  I think there are two elements of readiness to implement open source
solutions.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Desperation.&lt;/li&gt;
&lt;li&gt;Focus.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you are &lt;strong&gt;desperate&lt;/strong&gt; to have your problem solved, you don't quibble about who you will sue.  When
I've had the frustrating tangential conversations focusing on discomfort, part
of the reason is that the customer isn't truly desperate to &lt;em&gt;solve&lt;/em&gt;
a business problem.  Instead, they're busy implementing large and complex
application software, usually by building it from scratch.  They're proud of
their software development capabilities, and bypassing programmers by
downloading ready-to-hand solutions isn't what they want to
do.&lt;/p&gt;
&lt;p&gt;If you are &lt;strong&gt;focused&lt;/strong&gt;
on solving a problem, you can rationally evaluate the fit between a software
solution and the problem.  If you are doing something else, you have a million
other considerations that spin the conversation away from &lt;em&gt;problem-and-solution&lt;/em&gt;
toward strategy, tactics, operational considerations, who do we sue, and other
tangents.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ramp Up&lt;/strong&gt;.  With all &amp;quot;new&amp;quot; directions, introducing a
new set of tools must be done incrementally.  It must be focused on solving a
problem where the customer is desperate.  Adding POI, for example, solved an
immediate problem.  We had to talk it to death, but the policy against open
source wasn't exactly as broad and silly as the customer initially described.
Or, it wasn't inflexible in the face of a solution and a level of
desperation.&lt;/p&gt;
&lt;p&gt;You'll always have a &amp;quot;one
true language&amp;quot; conversation &lt;a class="reference external" href="https://slott56.github.io/2006_01_27-after_perl_what_revised.html"&gt;After PERL what?&lt;/a&gt;, but people will eagerly add Python to the
mix when there isn't a viable alternative.  Here's an
example:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;We need batch extractions to produce files for
a variety of purposes.  We have a batch-job production control system with which
it must interface.  Many kinds of tools can run in this environment, but GUI
tools aren't a good choice.&lt;/li&gt;
&lt;li&gt;We need garden-variety CSV and Tab files, and
SQL*Plus doesn't do this without a lot of pain.&lt;/li&gt;
&lt;li&gt;We need flexibility, but we don't want to
spend $10K for an elaborate ETL or EAI application.  It's just CSV
extracts.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A small technology stack
helps speed adoption.  Python 2.4 &lt;a class="reference external" href="http://www.python.org/"&gt;http://www.python.org/&lt;/a&gt; and cx_Oracle &lt;a class="reference external" href="http://www.python.org/pypi/cx_Oracle/4.1.2"&gt;http://www.python.org/pypi/cx_Oracle/4.1.2&lt;/a&gt; allows them to write 10-line extraction
programs that run from the command-line in AIX or Windows, can be scheduled by
their tools, and can be modified without the egregious overhead of a Java
application.&lt;/p&gt;
&lt;p&gt;One tipping point was
the addition of the CSV library module in Python 2.3.  I've written CSV parsers,
and the regular expressions required to handle quote balancing are opaque.  In
the Python 2.3+ world, we can write a tidy chunk of code that expresses the
&lt;em&gt;Database to CSV™&lt;/em&gt;  implementation with almost no
non-problem technology overheads.&lt;/p&gt;
&lt;p&gt;[An example of a non-problem technology
overhead is the Java technique of locating a JDBC driver before opening a
connection.  Yes it's short, but it's also confusingly opaque when we only have
one vendor for our production
databases.]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No Pain No Gain&lt;/strong&gt;.  The cost and benefit of Open Source is
only apparent if you have a specific problem to solve.  The derailing tangent
conversations about &amp;quot;converting&amp;quot; and the &amp;quot;value proposition&amp;quot; seem to happen when
discomfort with the approach is larger than the discomfort of the problem
itself.  If the problem isn't causing enough pain, then we are free to quibble
over solution strategies.&lt;/p&gt;
&lt;p&gt;Consequently, my real question is more fundamental.  It's not &amp;quot;why adopt open source?&amp;quot; nor is
it &amp;quot;how do we adopt open source?&amp;quot;
My question is &amp;quot;Are we ready to &lt;strong&gt;support&lt;/strong&gt; open source
when (a) it solves our customer's problems and (b) they're ready to adopt?&amp;quot;&lt;/p&gt;
</content><category term="Management"></category><category term="open source"></category><category term="enterprise"></category></entry><entry><title>The Role of Open Source in the Enterprise IT Investment Strategy</title><link href="https://slott56.github.io/2006_04_22-the_role_of_open_source_in_the_enterprise_it_investment_strategy.html" rel="alternate"></link><published>2006-04-22T14:37:00-04:00</published><updated>2006-04-22T14:37:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-04-22:/2006_04_22-the_role_of_open_source_in_the_enterprise_it_investment_strategy.html</id><summary type="html">&lt;p&gt;My point -- always -- is that I'm not here to &lt;strong&gt;convert&lt;/strong&gt; anyone.
I'm just here to respond to the need for open source consulting skills.&lt;/p&gt;
&lt;p&gt;As a parallel example, TH explained (at length) that there was NO earthly reason to retire a perfectly
good IBM z-series mainframe.  The z-series represents cheap …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My point -- always -- is that I'm not here to &lt;strong&gt;convert&lt;/strong&gt; anyone.
I'm just here to respond to the need for open source consulting skills.&lt;/p&gt;
&lt;p&gt;As a parallel example, TH explained (at length) that there was NO earthly reason to retire a perfectly
good IBM z-series mainframe.  The z-series represents cheap, reliable,
predictable, high-value, paid-for, processing power.  My point to him is not
that I have a better business model, or that I have a compelling argument for
conversion.  I only know that our firm has customers undertaking the
conversion.&lt;/p&gt;
&lt;p&gt;Thank goodness for articles
like Information Week's &lt;a class="reference external" href="http://www.informationweek.com/"&gt;http://www.informationweek.com/&lt;/a&gt; &amp;quot;Red Hat Seizes an Opening&amp;quot; &lt;a class="reference external" href="http://www.informationweek.com/story/showArticle.jhtml?articleID=185302881"&gt;http://www.informationweek.com/story/showArticle.jhtml?articleID=185302881&lt;/a&gt;.  This article paints the picture very
clearly:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Businesses are using open source
software.&lt;/li&gt;
&lt;li&gt;It doesn't matter that you can't see the
justification.&lt;/li&gt;
&lt;li&gt;There it is.  Deal with it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I really like that.  It helps me to
get past the &amp;quot;I just don't see the value&amp;quot; part of the conversation.  That's not
the point.&lt;/p&gt;
&lt;p&gt;It helps move the
conversation onto the more interesting topics:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;What open source packages should we focus on?&lt;/li&gt;
&lt;li&gt;Is there a business angle in open source
support for &lt;a class="reference external" href="http://www.ctg.com"&gt;CTG&lt;/a&gt; ?&lt;/li&gt;
&lt;li&gt;How can we be sure that our customers turn to
us first?&lt;/li&gt;
&lt;li&gt;Is there more that we can do to help customers
considering open source?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And, it helps
to have the Red Hat Business Model documented somewhere.  I believe it is the
coming model for all consulting firms.&lt;/p&gt;
</content><category term="Management"></category><category term="open source"></category><category term="enterprise"></category></entry><entry><title>Offshoring and Short-Term Thinking</title><link href="https://slott56.github.io/2006_03_25-offshoring_and_short_term_thinking.html" rel="alternate"></link><published>2006-03-25T16:37:00-05:00</published><updated>2006-03-25T16:37:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-03-25:/2006_03_25-offshoring_and_short_term_thinking.html</id><summary type="html">&lt;p&gt;A comment on &lt;a class="reference external" href="https://slott56.github.io/2006_03_20-making_pdfs_with_and_without_xsl_fo_revised.html"&gt;Offshoring Shows How Valuable Code Is&lt;/a&gt; floored me: &amp;quot;Another answer [to the 'what
do you value?' question] could be to show cost reduction for the quarter. Its
the old short term thinking to make Wall Street
happy.&amp;quot;&lt;/p&gt;
&lt;p&gt;First, I concluded that &amp;quot;cost
reduction&amp;quot; is somehow separate from …&lt;/p&gt;</summary><content type="html">&lt;p&gt;A comment on &lt;a class="reference external" href="https://slott56.github.io/2006_03_20-making_pdfs_with_and_without_xsl_fo_revised.html"&gt;Offshoring Shows How Valuable Code Is&lt;/a&gt; floored me: &amp;quot;Another answer [to the 'what
do you value?' question] could be to show cost reduction for the quarter. Its
the old short term thinking to make Wall Street
happy.&amp;quot;&lt;/p&gt;
&lt;p&gt;First, I concluded that &amp;quot;cost
reduction&amp;quot; is somehow separate from &amp;quot;offshoring production of COBOL&amp;quot;.  Which
confuses me, because I thought cost reduction was the driving force behind
offshoring the production of COBOL.  That can't be right, because the comment
reinforces the premise, but is worded as though it
disagrees.&lt;/p&gt;
&lt;p&gt;Let's assume the comment is
challenging my conclusion (code captures corporate knowledge, and should be
treated as something of value).   In which case, the comment means that it's
possible that short term cost containment is &lt;strong&gt;more&lt;/strong&gt; valuable than the knowledge capture.
Okay.  That's what everyone who is using
cheap off-shore development resources is already saying.&lt;/p&gt;
&lt;p&gt;It appears that the comment is the
same as my statement &amp;quot;So the knowledge capture is of no value, therefore we can
outsource it.&amp;quot;  Which was the point I was trying to refute, but didn't do a good
enough job of stating the contradiction.  I'll try
again.&lt;/p&gt;
&lt;p&gt;My claim is the
following:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge capture has value, that's why we're producing code in the first place.   We produce code (COBOL, Java, doesn't matter which) to capture knowledge.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Contradicting this is
the following:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Knowledge capture is so expensive, we outsource it so that we only partially capture the knowledge.  Indeed, we hand considerable knowledge to our vendors.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hopefully, this -- by
itself -- shows that claiming &amp;quot;short term thinking to make Wall Street happy&amp;quot;
involves a basic contradiction.  A business will both value producing code and
hate the cost of producing code.   It will value the code and simultaneously
treat it as a liability -- a cost to be
reduced.&lt;/p&gt;
&lt;p&gt;I'll try my conclusion again,
also.  I suggest we pick one.  Either value code, and do it well, or stop
producing code and start downloading open source and buying
packages.&lt;/p&gt;
</content><category term="Management"></category><category term="outsourcing"></category><category term="offshoring"></category></entry><entry><title>Offshoring Shows How Valuable Code Is (Revised)</title><link href="https://slott56.github.io/2006_03_20-offshoring_shows_how_valuable_code_is_revised.html" rel="alternate"></link><published>2006-03-20T21:58:00-05:00</published><updated>2006-03-20T21:58:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-03-20:/2006_03_20-offshoring_shows_how_valuable_code_is_revised.html</id><summary type="html">&lt;p&gt;See Schrage in CIO magazine on March 15 &lt;a class="reference external" href="http://www.cio.com/archive/031506/schrage.html?page=1"&gt;http://www.cio.com/archive/031506/schrage.html?page=1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When
we outsource of offshore some coding, what are we saying is
valuable?&lt;/p&gt;
&lt;p&gt;We're saying that the net
effect of the installed software has value.  We're saying that no existing
product does …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See Schrage in CIO magazine on March 15 &lt;a class="reference external" href="http://www.cio.com/archive/031506/schrage.html?page=1"&gt;http://www.cio.com/archive/031506/schrage.html?page=1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When
we outsource of offshore some coding, what are we saying is
valuable?&lt;/p&gt;
&lt;p&gt;We're saying that the net
effect of the installed software has value.  We're saying that no existing
product does what our new software will
do.&lt;/p&gt;
&lt;p&gt;We're also saying that the capture
of institutional knowledge isn't very important.   Yes, business analysts
capture the knowledge in words and specifications.  But the code -- the final
result of the programming effort, the delivered software -- is the real captured
knowledge that we're going to commit ourselves to using every
day.&lt;/p&gt;
&lt;p&gt;So the knowledge capture is of no
value, therefore we can outsource it.&lt;/p&gt;
&lt;p&gt;Worse, we're saying that the COBOL
language is so valuable that we must perpetuate
it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tools, too.&lt;/strong&gt;  We're also saying that the tools and
technologies for programming are an onerous burden on our people.  If the
languages and tools are such a burden, perhaps we're missing
something.&lt;/p&gt;
&lt;p&gt;My experiences with
customers who outsource is limited to the &amp;quot;outsource the commodity COBOL&amp;quot;
variety.  Looking at Schrage's article, I finally saw the contradiction.  The
COBOL is burdensome, but we can't eliminate the COBOL.  Since we have to
perpetuate it, we'll have it perpetuated by someone
else.&lt;/p&gt;
&lt;p&gt;Why do we have to perpetuate
COBOL programming?  Is it because our programmers only have COBOL as their
principle skill?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold the Phone.&lt;/strong&gt;   Let's review this slowly and
carefully.  Here's the problem: It's too expensive to produce COBOL programs.
Just so we're clear, the issue is the cost of COBOL.  The solution appears to be
&amp;quot;do COBOL more cheaply&amp;quot;, not &amp;quot;do something else that is inherently cheaper.&amp;quot;
Why the focus on doing COBOL
cheaply?&lt;/p&gt;
&lt;p&gt;Do we farm out COBOL because
we love the language?  Is it the only tool that works?  That's the hidden
message in the value proposition: that COBOL is essential, and rather than do
anything new or different, we'll locate someone who can make COBOL for us at a
lower price.&lt;/p&gt;
&lt;p&gt;And, in case you know
people who are outsourcing Java, you can simply cut and paste &amp;quot;Java&amp;quot; in place of
&amp;quot;COBOL&amp;quot;.  The argument is the same:  the code is
&lt;em&gt;simultaneously&lt;/em&gt;
of no value
&lt;em&gt;and&lt;/em&gt;
critical to success.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Changing Tacks&lt;/strong&gt; .  Why can't we switch to a
higher-powered language?  If I had a language that requires 1/2 the lines of
code of COBOL, it would be 1/2 the price to create and proportionately cheaper
to maintain.  If I could do this without engaging off-shore resources, wouldn't
that cut management overhead?  The institutional knowledge capture (the activity
that really matters) could be handled by a simple, fact-to-face,
user-analyst-programmer team.&lt;/p&gt;
&lt;p&gt;Why can't
we do this?  Because even though we hate COBOL -- really we hate the price and
process of building COBOL programs -- COBOL is as essential as death and
tax-law.  It appears to be the result of some kind of dogmatic article of faith:
COBOL is the only language my people
understand.&lt;/p&gt;
&lt;p&gt;Or, phrased another way, my
people are too intellectually impaired to do programming other than COBOL.  And,
of course, my people are too expensive to do COBOL programming.   So, we must do
COBOL and we can't do COBOL.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Which Language?&lt;/strong&gt;   I think the reason we can't abandon
COBOL is that we wouldn't know what to do next.  With a legacy of COBOL, and a
non-technical CIO (or CTO), language choice isn't on the table.  We can slowly
evolve to Java or C#, claiming it as a &amp;quot;strategic&amp;quot; direction for new projects,
meanwhile continuing to build upgrades and extensions to existing software in
COBOL.&lt;/p&gt;
&lt;p&gt;Rather than a tidy, small,
AIX/Linux Python application, we have to buy special-purpose tools, write
extensive specifications, send the work offshore, and then complain that it is
late, expensive and relatively
shoddy.&lt;/p&gt;
&lt;p&gt;Is Python really better?  If by
&amp;quot;better&amp;quot;, we mean cheaper to produce, then Python has many advantages.  First,
it has extensive and sophisticated libraries and frameworks.  Also, the language
is more compact.  For silly demo programs &lt;a class="reference external" href="http://www.csis.ul.ie/cobol/examples/Accept/Multiplier.htm"&gt;http://www.csis.ul.ie/cobol/examples/Accept/Multiplier.htm&lt;/a&gt;, the Python is 1/2 the size of COBOL.  For
serious programs, the Python can be even smaller.  Of course, there are some
things that are very hard to express in COBOL, but are quite simple in
Python.&lt;/p&gt;
&lt;p&gt;Yes, Python is new.  Yes, it is
open source.  More importantly, however, it captures corporate knowledge every
bit as well as COBOL, and you can create Python more simply using your existing
on-shore, in-house, skilled
resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What Do You Value?&lt;/strong&gt;   If you value the business solution,
then existing products and open source will usually solve your problem faster
and more cheaply than offshoring the development of new software.  However, you
may have something unique that requires unique
software.&lt;/p&gt;
&lt;p&gt;Since you are creating new
software, you value capturing corporate knowledge.  If this isn't true, then you
are creating software as a hobby, and offshoring your hobby makes no sense at
all.&lt;/p&gt;
&lt;p&gt;Since you value capturing
corporate knowledge, then you have to value the process of capturing and the
people who are doing the capture.  It only makes sense to give them powerful
tools that capture knowledge in a compact and usable form.&lt;/p&gt;
</content><category term="Management"></category><category term="outsourcing"></category><category term="offshoring"></category></entry><entry><title>C#, Microsoft and Hegemony</title><link href="https://slott56.github.io/2006_03_01-c_microsoft_and_hegemony.html" rel="alternate"></link><published>2006-03-01T01:26:00-05:00</published><updated>2006-03-01T01:26:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-03-01:/2006_03_01-c_microsoft_and_hegemony.html</id><summary type="html">&lt;p&gt;First, I've had some opinions on this &amp;quot;one
language&amp;quot; ideal &lt;a class="reference external" href="https://slott56.github.io/2006_01_27-after_perl_what_revised.html"&gt;After PERL what?&lt;/a&gt;.  We have a variety of languages for a
good reason: the languages express different kinds of things.  Shell command
languages really have little to do with markup languages, database manipulation
languages or &amp;quot;general-purpose&amp;quot; programming
languages.&lt;/p&gt;
&lt;p&gt;One of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;First, I've had some opinions on this &amp;quot;one
language&amp;quot; ideal &lt;a class="reference external" href="https://slott56.github.io/2006_01_27-after_perl_what_revised.html"&gt;After PERL what?&lt;/a&gt;.  We have a variety of languages for a
good reason: the languages express different kinds of things.  Shell command
languages really have little to do with markup languages, database manipulation
languages or &amp;quot;general-purpose&amp;quot; programming
languages.&lt;/p&gt;
&lt;p&gt;One of the C#/LINQ issues is
to collapse some higher-level predicates into the programming language.  The
problem is that predicates mean loops and loops mean proof of termination and
those proofs are impossible in general.&lt;/p&gt;
&lt;p&gt;Further, there is the difficulty in
optimizing those predicate loops.  Oracle has had years to work out cost-based
optimization, and it is still looked on with suspicion.&lt;/p&gt;
&lt;p&gt;If you have no persistent data, how do
you do optimization?  You have to know something about the data and the
algorithms.  This makes general-purpose predicates not terribly useful.&lt;/p&gt;
&lt;p&gt;When looking at C# from a distance, I
have to ask about innovation in the Windows world.  Are there barriers or is it
my personal bias?&lt;/p&gt;
&lt;p&gt;I think there are
barriers.&lt;/p&gt;
&lt;p&gt;First, and foremost,
everything in Windows world must play with the obscure and rapidly-evolving
Windows OS API's.  The lack of clarity and stability in the closed-source API's
is a barrier to innovation.&lt;/p&gt;
&lt;p&gt;Second, you
are competing against Microsoft.  If your idea is good, it will show up in a
competing closed-source MS product.  While good for your idea, the innovation is
effectively clamped off once it becomes a closed-source product
offering.&lt;/p&gt;
&lt;p&gt;Third, almost everything has
a large fee associated with it.  The tools, the platform and the libraries all
cost real money.  This is, I think, the reason why the open source folks have an
edge -- they can work for free.&lt;/p&gt;
&lt;p&gt;I'm
happy that I don't have to sweat the details of this .NET, C#, LINQ, CLI,
Managed Code world.  Oracle's OAS, OC4J is complex enough, and much of it is
open source.  I can't imagine how I'd make a complex closed-source environment
work.&lt;/p&gt;
</content><category term="Management"></category><category term="microsoft"></category><category term="perl"></category><category term="c-sharp"></category></entry><entry><title>Opacity and Perl</title><link href="https://slott56.github.io/2006_02_07-opacity_and_perl.html" rel="alternate"></link><published>2006-02-07T11:51:00-05:00</published><updated>2006-02-07T11:51:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-02-07:/2006_02_07-opacity_and_perl.html</id><summary type="html">&lt;p&gt;In my case, the opacity of Perl actually wasn't
entirely my opinion.  I was contacted by folks that were struggling with Perl.
In one case, they specifically lifted up the opacity problem.  &amp;quot;If my partner
gets hit by the bus, I can't maintain these web
sites.&amp;quot;&lt;/p&gt;
&lt;p&gt;In the other case …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my case, the opacity of Perl actually wasn't
entirely my opinion.  I was contacted by folks that were struggling with Perl.
In one case, they specifically lifted up the opacity problem.  &amp;quot;If my partner
gets hit by the bus, I can't maintain these web
sites.&amp;quot;&lt;/p&gt;
&lt;p&gt;In the other case, the opacity
was something they danced around.  The backbone of their application is Perl.
They have to make extensive changes.  They can't easily support those changes
with the structure they have.  Rather than touch the backbone, they want a far
more sophisticated web front-end.  That's probably spending money in the wrong
place.  Simplifying or replacing the Perl coupled with incremental improvements
to the web presentation may be a much smarter way to spend the
money.&lt;/p&gt;
&lt;p&gt;So, the opacity problem isn't
mine.  Indeed, I can read Perl just fine.&lt;/p&gt;
&lt;p&gt;However, I can't read XSLT at all.  I
really have to struggle with it.  I've often (see &lt;a class="reference external" href="https://slott56.github.io/2003_12_13-not_the_first_time.html"&gt;Not the first time&lt;/a&gt;) wondered about the lure of XML and XSLT
and I just don't see it.&lt;/p&gt;
&lt;p&gt;I think we
agree that opacity is a serious problem.  While you may not see it in Perl, we
both see the cost and complexity that stems from difficult-to-read software.
The point of software is to capture knowledge.  If you can't read it, then how
well was it captured?&lt;/p&gt;
</content><category term="Management"></category><category term="perl"></category><category term="opacity"></category></entry><entry><title>After Perl, what? (Revised)</title><link href="https://slott56.github.io/2006_01_27-after_perl_what_revised.html" rel="alternate"></link><published>2006-01-27T00:58:00-05:00</published><updated>2006-01-27T00:58:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-01-27:/2006_01_27-after_perl_what_revised.html</id><summary type="html">&lt;div class="section" id="the-problem"&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;Perl's old.  And Perl is
without shame about adopting every syntax gimmick on earth.  Consequently, Perl
has accreted enough features that Perl programs are hard to read, making them
impossible to maintain.  More thoughts on this opacity problem in Gadgetopia
&lt;a class="reference external" href="http://www.gadgetopia.com/post/1919"&gt;http://www.gadgetopia.com/post/1919&lt;/a&gt; and Freshmeat …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="the-problem"&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;Perl's old.  And Perl is
without shame about adopting every syntax gimmick on earth.  Consequently, Perl
has accreted enough features that Perl programs are hard to read, making them
impossible to maintain.  More thoughts on this opacity problem in Gadgetopia
&lt;a class="reference external" href="http://www.gadgetopia.com/post/1919"&gt;http://www.gadgetopia.com/post/1919&lt;/a&gt; and Freshmeat &lt;a class="reference external" href="http://freshmeat.net/articles/view/1339/"&gt;http://freshmeat.net/articles/view/1339/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Further, Perl 6 is caught up in political wrangling of the first magnitude.  There's the
Larry Wall camp (Apocalypses), Curl, Lua, Monkey, Ponie and Parrot.  And there's
further opinions like Rindolf &lt;a class="reference external" href="http://vipe.technion.ac.il/~shlomif/rindolf/%22%20target=%22NewWindow"&gt;http://vipe.technion.ac.il/~shlomif/rindolf/%22%20target=%22NewWindow&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Perhaps most limiting, Perl isn't a hotbed of application frameworks [&lt;a class="reference external" href="http://www.haloscan.com/comments/slott/E20060126195803/#66236"&gt;Thanks&lt;/a&gt; ].
Products include &lt;a class="reference external" href="http://catalyst.perl.org/"&gt;Catalyst&lt;/a&gt;  and &lt;a class="reference external" href="http://maypole.perl.org/"&gt;Maypole&lt;/a&gt; .
Perl suffers from being one of the first scripting extensions to Apache,
consequently innovation was focused elsewhere.  Java, PHP, Python and Ruby all
have the advantage of many sophisticated frameworks that minimize the
programming and consequently, minimize the obscurity of the programming
language.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-choices"&gt;
&lt;h2&gt;Some Choices&lt;/h2&gt;
&lt;p&gt;If Perl is too opaque for
ongoing use, and the future of Perl is cloudy, we should probably think about
moving on to another language.  So step one is the following
advice:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ditch-perl"&gt;
&lt;h2&gt;Ditch Perl&lt;/h2&gt;
&lt;p&gt;When we ditch Perl, we'll need to replace it
with some language.  Which one?  Further, we'll need a plan for retiring working
applications in Perl and upgrading them to something newer and less
opaque.&lt;/p&gt;
&lt;p&gt;O'Reilly's LAMP &lt;a class="reference external" href="http://www.onlamp.com/"&gt;http://www.onlamp.com/&lt;/a&gt; architecture
(Linux-Apache-MySQL-P.*) lifts up three languages: Perl, PHP and Python.
Recently, Ruby has matured to the point where it deserves some consideration.
Finally, there's always Java.&lt;/p&gt;
&lt;p&gt;Here's a chart &lt;a class="reference external" href="http://www.jvoegele.com/software/langcomp.html"&gt;http://www.jvoegele.com/software/langcomp.html&lt;/a&gt; that provides some head-to-head comparison
among these languages.  One issue, of course, is that languages express ideas,
and the world of software is big:  too big for a single language.  There is no
one-language &amp;quot;right&amp;quot; answer.  This isn't a trick question.  We're going to look
at tradeoffs and priorities: always messy
work.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-one-true-language"&gt;
&lt;h2&gt;The One True Language&lt;/h2&gt;
&lt;p&gt;Let's dispose of the
one-language-to-rule-them-all-and-in-the-darkness-bind-them
myth:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We have command languages like the shell
optimized for a few tasks like running programs&lt;/li&gt;
&lt;li&gt;We have markup languages (HTML, XML)&lt;/li&gt;
&lt;li&gt;We have programming languages for
complex, high-performance processing (C)&lt;/li&gt;
&lt;li&gt;We have data query languages (SQL)&lt;/li&gt;
&lt;li&gt;We have specialized template languages
for assembling HTML results from data queries and lightweight computations (JSP,
PHP)&lt;/li&gt;
&lt;li&gt;We have other programming paradigms
embodied in Haskell, Groovy or
Prolog&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have the good-old
general-purpose language (Python, Perl, PHP, Java, Ruby) that can do almost
anything.  Doing almost anything translates to doing anything badly and doing
nothing well.  For any of the above specific purposes, general-purpose languages
are just too wordy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-domain"&gt;
&lt;h2&gt;The Domain&lt;/h2&gt;
&lt;p&gt;If one language won't solve all of
our problems, we'll need to pick a problem, then pick a suitable language.
Let's focus, then, on web application development.  Further, let's look at
someone with a legacy of applications developed primarily in Perl.  We need to
look at the alternatives to Perl for web application
development.&lt;/p&gt;
&lt;p&gt;Compounding the problem is
the rest of the architecture stack.  We can't easily focus narrowly on using
just Apache as the web server.  While &amp;quot;bare&amp;quot; Apache had some appeal in the murky
past, the world has matured.  CGI and mod_Perl are no longer new; a great deal
of useful infrastructure has arisen, which can reduce the volume of programming
necessary to put dynamic, interactive content onto the
web.&lt;/p&gt;
&lt;p&gt;When we look at languages, we're
really looking at a programming environment which includes a web application
framework and a programming language.  Our programming language(s), then,
extend, customize and tailor a generic web application for our specific customer
requirements.  This will complicate our analysis because we aren't merely
comparing languages, we're really comparing framework +
language.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-quality-factors"&gt;
&lt;h2&gt;Some Quality Factors&lt;/h2&gt;
&lt;p&gt;We can't easily evaluate
all of the tools available.  However, we can provide some essential criteria
that can be used to narrow the field
rapidly.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Model-View-Controller separation.  The data model, the HTML view, and the controls must be
separated.&lt;/li&gt;
&lt;li&gt;Object-Relational Mapping with
Persistence.  We should be able to bury our SQL in mapping rules.  Ideally, it's
generated seamlessly and silently.&lt;/li&gt;
&lt;li&gt;RDBMS-agnostic.  Any of the MySQL, Postgres, SQLite products (or any of the expensive, commercial products) should be
supported.&lt;/li&gt;
&lt;li&gt;Web best-practices:  session management, POST-redirect-GET, validation and quoting to prevent SQL/Shell
command injections, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Additionally, the number of skilled people is important.  Here is the TIOBE programming
community index &lt;a class="reference external" href="http://www.tiobe.com/tpci.htm"&gt;http://www.tiobe.com/tpci.htm&lt;/a&gt; for the languages we're looking at.  We'll
discard C and C++ as being unsuitable for web applications:  Python does the
same processing as C (or C++) without the endless (and error-prone) drudgery of
memory management.  While popular in general, they aren't applicable to web
applications.  Additionally, we'll discard VB and C# because they are
proprietary products and have a cost which exceeds their real value.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PHP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;VB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(off the list): &lt;strong&gt;Ruby&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="java"&gt;
&lt;h2&gt;Java&lt;/h2&gt;
&lt;p&gt;Java is totally dominated by J2EE (Tomcat, JBoss, etc.) as the application framework.
Apache Struts &lt;a class="reference external" href="http://struts.apache.org/"&gt;http://struts.apache.org/&lt;/a&gt; or Spring &lt;a class="reference external" href="http://www.springframework.org/"&gt;http://www.springframework.org/&lt;/a&gt; put
an MVC framework on top of J2EE.  Toplink, JDO and Hibernate are choices for the
Object-Relational Mapping &lt;a class="reference external" href="http://c2.com/cgi-bin/wiki?ObjectRelationalMapping"&gt;http://c2.com/cgi-bin/wiki?ObjectRelationalMapping&lt;/a&gt; and Persistence.  Plus, there are
pure-persistence packages &lt;a class="reference external" href="http://java-source.net/open-source/persistence"&gt;http://java-source.net/open-source/persistence&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Struts can be complex (at first)
because it is a very sophisticated environment which finely partitions the work
among the Action classes, the struts-config definitions, validations, and EJB's
(or POJO's).  Struts, however, has the advantage of separating the model, the
view and the control into EJB's, JSP's and Action classes.  The EJB's write
themselves, since they are the enduring business facts.  The JSP's write
themselves because they are the presentations, done with JSP's HTML template
language.  The struts configuration handles the subtlety of transaction flow,
and the most obvious validation rules.  What's left?  The &amp;quot;business rules&amp;quot; --
validations that can't easily be written as simple XML-encoded rules, and the
actual effect of the web transaction (ordering, canceling, inquiring,
etc.)&lt;/p&gt;
&lt;p&gt;Sadly, however, the JSP world was
originally a complete stand-alone application development environment, so it has
a bewildering level of feature-itis.  Further, the XML-based JSP's have a number
of extension tag libraries that are a mixed blessing.  Yes, forms are very easy
to create.  No, you'll never understand all of those JSP tag
libraries.&lt;/p&gt;
&lt;p&gt;Java is, however, pure
OO-programming:  everything is very clean and precise, and you have the full
power of inheritance and the sophisticated design patterns.  Some of the
mystique of EJB's can be eliminated in favor of Plain-Ol' Java Objects (POJO's).
Generally, the complexities of EJB's aren't all that pleasant to deal with, so
I'm a POJO
programmer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="php"&gt;
&lt;h2&gt;PHP&lt;/h2&gt;
&lt;p&gt;PHP has over 40 individual frameworks &lt;a class="reference external" href="http://www.phpwact.org/php/mvc_frameworks"&gt;http://www.phpwact.org/php/mvc_frameworks&lt;/a&gt;, &lt;a class="reference external" href="http://dmoz.org/Computers/Programming/Languages/PHP/Scripts/Frameworks/"&gt;http://dmoz.org/Computers/Programming/Languages/PHP/Scripts/Frameworks/&lt;/a&gt;.  How to penetrate the clutter?  There is
no quick answer.  Just looking at PHP content management &lt;a class="reference external" href="http://dmoz.org/Computers/Programming/Languages/PHP/Scripts/Content_Management/"&gt;http://dmoz.org/Computers/Programming/Languages/PHP/Scripts/Content_Management/&lt;/a&gt; turns up a huge list.  Some sorting is
available at CMS Matrix &lt;a class="reference external" href="http://www.cmsmatrix.org/"&gt;http://www.cmsmatrix.org/&lt;/a&gt;.  However, LinuxWorld &lt;a class="reference external" href="http://linux.sys-con.com/read/86022.htm"&gt;http://linux.sys-con.com/read/86022.htm&lt;/a&gt; has selected two that merit serious
consideration: &lt;strong&gt;Mambo&lt;/strong&gt; &lt;a class="reference external" href="http://www.mamboserver.com/"&gt;http://www.mamboserver.com/&lt;/a&gt;
and &lt;strong&gt;phpWebsite&lt;/strong&gt; &lt;a class="reference external" href="http://phpwebsite.appstate.edu/"&gt;http://phpwebsite.appstate.edu/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When I first looked at PHP (five years ago, in 2000), the language looked like a
clutter of features, and a seemingly-endless library of functions.  While it's
nice to have all those functions, I would have appreciated a few packages and
modules to break them into more meaningful chunks.  More important to me would
have been a focus on object-oriented programming as the way to build web
applications.  However, PHP was originally an HTML template language on
steroids, and seems to remain focused on that
niche.&lt;/p&gt;
&lt;p&gt;The frameworkes make PHP more
palatable; separating model, view and control is absolutely essential to
success.  Classical PHP (without a framework) is little more than Java JSP, and
has the same basic complexity.&lt;/p&gt;
&lt;p&gt;While PHP has class definitions, Mambo doesn't emphasize OO-style examples.  On the
other hand, phpWebsite, does seem to land on the OO feature set.  The list of
object-oriented MVC frameworks &lt;a class="reference external" href="http://www.google.com/search?q=php+object-oriented+framework"&gt;http://www.google.com/search?q=php+object-oriented+framework&lt;/a&gt; shows how important it is to promote reuse
and simplification using
objects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python"&gt;
&lt;h2&gt;Python&lt;/h2&gt;
&lt;p&gt;Python
has over 30 frameworks &lt;a class="reference external" href="http://wiki.python.org/moin/WebProgramming"&gt;http://wiki.python.org/moin/WebProgramming&lt;/a&gt;.  The question is, which are production
ready and reasonably complete?  The answer is to look at frameworks which build
complete content-management solutions.  These can then be tailored for on-line
shopping or any other purpose.  This is a shorter list &lt;a class="reference external" href="http://wiki.python.org/moin/ContentManagementSystems"&gt;http://wiki.python.org/moin/ContentManagementSystems&lt;/a&gt; including the following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Zope&lt;/strong&gt; &lt;a class="reference external" href="http://www.zope.org/"&gt;http://www.zope.org/&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nevow&lt;/strong&gt; &lt;a class="reference external" href="http://divmod.org/projects/nevow"&gt;http://divmod.org/projects/nevow&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Webware&lt;/strong&gt; &lt;a class="reference external" href="http://www.webwareforpython.org/"&gt;http://www.webwareforpython.org/&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Django&lt;/strong&gt; &lt;a class="reference external" href="http://www.djangoproject.com/"&gt;http://www.djangoproject.com/&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Python, the object-orientation isn't mandatory, but is almost universal, unlike PHP or Perl.&lt;/p&gt;
&lt;p&gt;Zope takes a very interesting approach to creating content as an assembly of elements.  The
interaction between the Zope DB, the various page templating tools, and the
Python programming language works out very nicely.  Zope is not a rehashing of
other technologies, but a clean and unique approach to web presentation.  In
can, consequently, be very uncomfortable to have Zope do so much and you (the
programmer) do so little.&lt;/p&gt;
&lt;p&gt;Django is a little more conventional.  It has an explicit Model, View, Controller separation
and leans on Struts (to an extent).  It has an easy-to-live-with templating
language, full Python programming, and a sophisticated set of built-in
capabilities.  It has a model definition capability that takes some getting used
to, but once you work out the details, the default object-relational mapping can
be made to work nicely.&lt;/p&gt;
&lt;p&gt;Nevow's approach to mixing Python programming and template insertion makes use of some
slightly extended HTML syntax.  This has the pleasant consequence of allowing
someone to design pages in largely &amp;quot;pure&amp;quot; HTML, then slap a few special purpose
tag attributes into things like &lt;tt class="docutils literal"&gt;&amp;lt;span&amp;gt;&lt;/tt&gt; tags, to provide a linkage with
Python programs.  Python has the functions, the stan markup extensions provide
the presentation.&lt;/p&gt;
&lt;p&gt;WebWare has a Servlet engine (like J2EE web applications), it also has Kid and PSP's, which are
PHP-like (or JSP-like) template pages with Python code inserted.  Consequently,
you can use the WebKit servlets and KidKit template pages to build a very robust
Struts-like
application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ruby"&gt;
&lt;h2&gt;Ruby&lt;/h2&gt;
&lt;p&gt;Ruby, as the new language, still has
much to prove.  It enjoys considerable popularity because it has numerous
features and the Rails web application framework is very powerful.  Ruby (like
Python) embodies a DRY - Don't Repeat Yourself - philosophy.  There aren't a lot
of external configuration files and additional descriptive material.  The Ruby
language (like Python) includes enough introspection that the code can examine
itself to do the various mappings from HTML Form to Object to Relational row.&lt;/p&gt;
&lt;p&gt;However, Ruby has one serious
flaw: it is largely opaque.  Part of that is the novelty of the language.  But
part of it is the very &amp;quot;spare&amp;quot; look, without a lot of punctuation or other
visual cues.  Ruby may have the same problem that Perl has.  Perl and Ruby may
both be examples of write once programming languages.  They may be
unmaintainable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="action-plan"&gt;
&lt;h2&gt;Action Plan&lt;/h2&gt;
&lt;p&gt;Look closely at PHP and Python for a Perl replacement.  Each framework has a &amp;quot;style&amp;quot; or &amp;quot;flavor&amp;quot; that is
difficult to summarize.  However, once experienced, it is either compelling or
confusing.  There's a lot of room for researching and there's a fine line
between researching and hang-wringing.  Here's the
plan.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Download PHP.  Take a few
weeks and write some small demo programs in PHP to see how it works, and how
well it fits your mind-set.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.  Download Python.  Take a few weeks and write some small demo programs in
Python.&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;Make the first (and toughest) decision: PHP or Python.  PHP will probably be more familiar to a
procedural Perl programming.  Python's object-orientation may be hard to fathom.
In the long run, OO allows you to create far more sophisticated programs.  But
it can be a difficult programming style to
learn.&lt;/li&gt;
&lt;li&gt;Once you've chosen a
language, you can then choose a framework.  Download an appropriate combination
of Mambo, PHPWebSite, Django, Nevow, WebWare, and Zope.&lt;/li&gt;
&lt;li&gt;Do the tutorials for the products
you've downloaded.  You may, at this time, rethink your language choice, and
decide to try the other language and the other frameworks.  However, stick to
the tutorials so that you can minimize your investment in technologies that you
won't make serious use of.  In some cases, the documentation of the tutorial may
be enough to provide you a hint that the approach doesn't resonate well with
your mental model of web
applications.&lt;/li&gt;
&lt;li&gt;Convert something small, safe and reliable to the chosen framework.  You will make mistakes.  It
won't be easy.&lt;/li&gt;
&lt;li&gt;Convert something
else small, safe and reliable.  Rework your mistakes in the previous
conversion.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Perl's opacity makes Perl it's own problem.  It's great to write in, but awful to
maintain.  Replacing Perl is hard -- you can stick with procedural programming
and choose PHP, or you can make a decision to exploit the power of objects and
choose Python.  You can leverage large, expensive, commercial products and
choose Java, also.&lt;/p&gt;
&lt;p&gt;More important is the choice of web application frameworks.  The idea of a framework is to
structure the application and leverage existing code from other projects as much
as possible.  This is the big win in replacing Perl: exploiting
well-thought-out, next-generation frameworks for web applications.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Management"></category><category term="LAMP"></category><category term="perl"></category><category term="php"></category><category term="java"></category><category term="python"></category><category term="ruby"></category></entry><entry><title>Ouch, this is going to hurt</title><link href="https://slott56.github.io/2006_01_11-ouch_this_is_going_to_hurt.html" rel="alternate"></link><published>2006-01-11T12:06:00-05:00</published><updated>2006-01-11T12:06:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2006-01-11:/2006_01_11-ouch_this_is_going_to_hurt.html</id><summary type="html">&lt;p&gt;While some spread-sheet
use is civilized numerical stuff, and other spread-sheet use is merely personal
organization, too much spread-sheet use is the poor-person's database management
system.  I call it the Spreadsheet Schema (SSS), different from normalized
relational schema and star
schema.&lt;/p&gt;
&lt;p&gt;There is a serious problems
with people using spreadsheets …&lt;/p&gt;</summary><content type="html">&lt;p&gt;While some spread-sheet
use is civilized numerical stuff, and other spread-sheet use is merely personal
organization, too much spread-sheet use is the poor-person's database management
system.  I call it the Spreadsheet Schema (SSS), different from normalized
relational schema and star
schema.&lt;/p&gt;
&lt;p&gt;There is a serious problems
with people using spreadsheets as databases, and this has a number of
consequences.  Principally, the SSS isn't normalized, and doesn't allow for the
&amp;quot;Update Anomaly&amp;quot; problem.  Consequently, breakage is
inevitable.&lt;/p&gt;
&lt;p&gt;1.  People do global find
and replace operations.  Failure to make a global change breaks a relationship.
Now the manually tweaked rows have one set of relationships, while the rows
which were missed have a different
relationship.&lt;/p&gt;
&lt;p&gt;2.  Small data quality
issues cause the procedure to break down.  I misspelled Mississippi on just one
row, and my global replace hits all but that one.&lt;/p&gt;
&lt;p&gt;3.  Spreadsheets are two-dimensional,
where the world is multi-dimensional.  The lesson learned from star-schema
design is that a 5-dimensional hypercube is often what we're talking about, and
a two-dimensional pivot table is a handy way to boil that information down to
something useful.&lt;/p&gt;
&lt;p&gt;This is not an
indictment of the JotSpot Tracker's ability to absorb a spreadsheet.  It's the
elevation of spreadsheet to surrogate database that's the problem.  JotSpot just
makes it visible, and makes the resulting problems
inevitable.&lt;/p&gt;
&lt;p&gt;Sadly, here's the saga as
it plays out on a daily basis.&lt;/p&gt;
&lt;p&gt;First,
someone has an idea and slaps together a spreadsheet.  The boss and the rest of
the working group love it and use it.  It works, it's
great.&lt;/p&gt;
&lt;p&gt;Then, someone extends the idea,
expands the spreadsheet and hits a wall.  Either the normalization problem
stings them or the multi-dimensionality stings them.  Or they get to so many
columns they can't manage it, or so many rows it takes 5 minutes to open, or
worse.  Worse, for example, is someone corrupting it and no one kept
backups.&lt;/p&gt;
&lt;p&gt;So, they call in-house
computer folks to turn the spreadsheet into application software.  They can't
articulate all the use cases very clearly (since a spreadsheet doesn't enforce
much discipline) and when in-house IT wants to talk about it, the meetings drag
on, the costs rise.  It takes more time to explain it than it did to slap it
together and start using it.&lt;/p&gt;
&lt;p&gt;Then, of
course, IT slaps on all the &amp;quot;missing&amp;quot; functionality to make a &amp;quot;real system&amp;quot; and
then begins to build the thing using the least effective set of tools ever
purchased as a corporate standard.  Meanwhile, the meetings to talk about use
cases have caused some thinking and use of the spreadsheet morphs while the
&amp;quot;real system&amp;quot; is being built.  Costs rise, the official IT version isn't very
good and the whole project collapses into
finger-pointing.&lt;/p&gt;
&lt;p&gt;Someone calls in the
consultants.  I look at the situation, develop a plan, write up a statement of
work, and get thrown out on my ear.  Here's what I hear as I'm being flung down
the stairwell: &amp;quot;It didn't cost us that much to build it the first two
times!&amp;quot;&lt;/p&gt;
</content><category term="Management"></category><category term="spreadsheet"></category><category term="database"></category></entry><entry><title>Paying Micro$oft Twice</title><link href="https://slott56.github.io/2005_11_06-paying_microoft_twice.html" rel="alternate"></link><published>2005-11-06T18:01:00-05:00</published><updated>2005-11-06T18:01:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2005-11-06:/2005_11_06-paying_microoft_twice.html</id><summary type="html">&lt;p&gt;MS AntiSpyware &amp;quot;free&amp;quot; beta &lt;a class="reference external" href="http://www.microsoft.com/athome/security/spyware/software/default.mspx"&gt;http://www.microsoft.com/athome/security/spyware/software/default.mspx&lt;/a&gt;.  Also, it appears &lt;a class="reference external" href="http://blogs.chron.com/techblog/archives/2005/11/microsoft_antis_1.html"&gt;http://blogs.chron.com/techblog/archives/2005/11/microsoft_antis_1.html&lt;/a&gt; to be called Windows
Defender.&lt;/p&gt;
&lt;p&gt;eWeek's slavish lack of clue
&lt;a class="reference external" href="http://www.eweek.com/article2/0,1895,1872253,00.asp"&gt;http://www.eweek.com/article2/0,1895,1872253,00.asp&lt;/a&gt;; Paul Thurott's lack …&lt;/p&gt;</summary><content type="html">&lt;p&gt;MS AntiSpyware &amp;quot;free&amp;quot; beta &lt;a class="reference external" href="http://www.microsoft.com/athome/security/spyware/software/default.mspx"&gt;http://www.microsoft.com/athome/security/spyware/software/default.mspx&lt;/a&gt;.  Also, it appears &lt;a class="reference external" href="http://blogs.chron.com/techblog/archives/2005/11/microsoft_antis_1.html"&gt;http://blogs.chron.com/techblog/archives/2005/11/microsoft_antis_1.html&lt;/a&gt; to be called Windows
Defender.&lt;/p&gt;
&lt;p&gt;eWeek's slavish lack of clue
&lt;a class="reference external" href="http://www.eweek.com/article2/0,1895,1872253,00.asp"&gt;http://www.eweek.com/article2/0,1895,1872253,00.asp&lt;/a&gt;; Paul Thurott's lack of clue &lt;a class="reference external" href="http://www.winsupersite.com/reviews/ms_antispyware_preview.asp"&gt;http://www.winsupersite.com/reviews/ms_antispyware_preview.asp&lt;/a&gt;; ComputerWorld, too &lt;a class="reference external" href="http://www.computerworld.com/securitytopics/security/story/0,10801,105766,00.html?from=story_package"&gt;http://www.computerworld.com/securitytopics/security/story/0,10801,105766,00.html?from=story_package&lt;/a&gt; had a sidebar &amp;quot;Plugging the Windows Hole&amp;quot;
which was almost embarrassing.&lt;/p&gt;
&lt;p&gt;Everyone treats this like it's A Good
Thing.  Okay, so MS pays a lot of advertising dollars.  That appears to be why
no one says &amp;quot;&lt;strong&gt;MS Created The Problem&lt;/strong&gt; &amp;quot;, or
&amp;quot;&lt;strong&gt;How Is a New Product Necessary?&lt;/strong&gt; &amp;quot;  Couldn't we fix the root cause of
of malware: the unapproved installation of software with root-like powers?
Couldn't we have someone in MS-Land say &amp;quot;No&amp;quot; to installations on-the-fly?
Couldn't we fix the core OS to simply not do
this?&lt;/p&gt;
&lt;p&gt;I find it hard to believe that MS
had to buy a spyware product at bundle it with their OS.  I find it hard to
believe for the following reason.&lt;/p&gt;
&lt;p&gt;They
claim that they wrote this &amp;quot;Windows&amp;quot; product.  But they can't seem to locate the
bugs.&lt;/p&gt;
&lt;p&gt;Just think about this for a
moment.  (1) They wrote the software.  (2) The software permits malware.  But,
inexplicably, (3) they can't locate the bugs which permit the malware.  They
can't stop the surprise installation of software.&lt;/p&gt;
&lt;p&gt;I read about products that &amp;quot;lock out
spyware&amp;quot; &lt;a class="reference external" href="http://www.computerworld.com/securitytopics/security/story/0,10801,105814,00.html?from=story_package"&gt;http://www.computerworld.com/securitytopics/security/story/0,10801,105814,00.html?from=story_package&lt;/a&gt; with incredulity.   If MS can't fix the
software they wrote, what does that mean?  They didn't write Windows; or the
people who did write Windows are long gone; or worse, they don't
&lt;em&gt;want&lt;/em&gt;
to fix it.  Spyware, it appears, is good for business.  Or, Microsoft found
Windows lying under a rock and can't improve it or even correct
it.&lt;/p&gt;
&lt;p&gt;First, MS sells an operating
system.  Not to users, of course, but to Dell, IBM, HP, et. al.  Second, MS
sells patches to fix that operating system.  They sell the fixes to the end
users: a far larger revenue base with no ability to negotiate.  And this also
spins off  an industry of admins, security consultants, hackers and patchers.
All of which is no-value work that drags away time and money from value-creating
activities.&lt;/p&gt;
&lt;p&gt;I can already hear CP
telling me that Microsoft has done great things for the world.  Before MS
Office, desktop integration was a nightmare.  And I have to tell you CP, again,
I'm not talking about their office suite, I'm talking about their bug-filled OS.
And if you say that the bug-filled OS is the barrier to entry for using the
Office Suite, I'll have yet another embarrassing shouting fit in a public place.
So, please, don't bother.  Just download Open Office and stop this -- well --
extortion.&lt;/p&gt;
</content><category term="Management"></category><category term="microsoft"></category><category term="spyware"></category></entry><entry><title>Java - the new COBOL (Revised)</title><link href="https://slott56.github.io/2005_11_03-java_the_new_cobol_revised.html" rel="alternate"></link><published>2005-11-03T14:55:00-05:00</published><updated>2005-11-03T14:55:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2005-11-03:/2005_11_03-java_the_new_cobol_revised.html</id><summary type="html">&lt;p&gt;Kontrawize says &lt;a class="reference external" href="http://kontrawize.blogs.com/kontrawize/2005/11/java_is_the_new.html"&gt;http://kontrawize.blogs.com/kontrawize/2005/11/java_is_the_new.html&lt;/a&gt; that Java is the new assembler.&lt;/p&gt;
&lt;p&gt;/dev/null &lt;a class="reference external" href="http://www.haloscan.com/comments/slott/E20051101105604/#27166"&gt;http://www.haloscan.com/comments/slott/E20051101105604/#27166&lt;/a&gt; says &amp;quot;While we are willing to expose and
discuss the problems in Java, we do it because we want to improve it, not …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Kontrawize says &lt;a class="reference external" href="http://kontrawize.blogs.com/kontrawize/2005/11/java_is_the_new.html"&gt;http://kontrawize.blogs.com/kontrawize/2005/11/java_is_the_new.html&lt;/a&gt; that Java is the new assembler.&lt;/p&gt;
&lt;p&gt;/dev/null &lt;a class="reference external" href="http://www.haloscan.com/comments/slott/E20051101105604/#27166"&gt;http://www.haloscan.com/comments/slott/E20051101105604/#27166&lt;/a&gt; says &amp;quot;While we are willing to expose and
discuss the problems in Java, we do it because we want to improve it, not
because we need to cut &amp;amp; run&amp;quot;.  Taken out of context, I could twist this to
mean that Java is no longer looked at merely technology to build a solution, but
has developed an independent existence and a rabidly patriotic following.&lt;/p&gt;
&lt;p&gt;I think /dev/null is being a Java
realist (&amp;quot;it has problems, but it solves some problems well&amp;quot;).  I think
Kontrawize's point isn't quite right; really the point is that Java is sometimes
applied to the wrong problems.&lt;/p&gt;
&lt;p&gt;While
Java is the next big legacy, some of Kontrawize reasons are wrong.  Comparing
Java to Assembler as low-productivity toolsets, misses the mark.  Assembler is
only low-productivity if you're using it for the wrong thing.  If you're writing
I/O drivers, assembler rules.  If you're writing a multi-media presentation,
assembler is the pits.  It's the &amp;quot;mismatch between levels of abstraction&amp;quot;
problem.&lt;/p&gt;
&lt;p&gt;In the IT shops I've been in
over the last few decades, assembler is a legacy that leads to absolute
deer-in-the-headlights paralysis.  The few shops that still had some assembler
had to treat it as a black box.  The software had to be documented without
reference to internal structure, and the replacement had to involve the
potential for business change, since the nuances of the assembler were already
lost forever.&lt;/p&gt;
&lt;p&gt;COBOL, on the other hand,
is more like Java.  IT shops have lots of legacy COBOL folks, and when you try
to introduce something new (like Java or Python) to them, they fight back every
step of the way.  They often cling to old work processes, unwilling to consider
that the brave new world is upon
them.&lt;/p&gt;
&lt;p&gt;One example:  We build the entire
Java application system and turn over four JAR files that are put into
production.  The COBOL folks ask questions like:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Why turn over everything?  Why not just
turn over the &amp;quot;program&amp;quot; which changed?&lt;/li&gt;
&lt;li&gt;Why recompile everything?  Wouldn't be
&amp;quot;simpler&amp;quot; (&amp;quot;more efficient&amp;quot; was also used) to recompile only the &amp;quot;program&amp;quot; that
changed?&lt;/li&gt;
&lt;li&gt;Why don't you have proper application
main programs?  Why do you have these reusable packages that are recombined
every which way?  Wouldn't it be &amp;quot;simpler&amp;quot; to use &amp;quot;copy books&amp;quot; (a/k/a/ include
files) so you could more easily track the dependencies among your programs and
the reusable bits?&lt;/li&gt;
&lt;li&gt;What's wrong with shell scripts?  They're
just like JCL and we use JCL all the
time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think the idea that Java will
become the next COBOL is very important.  One consequence will be the
&amp;quot;Technology Freeze Play&amp;quot;: we're an All-Singing-All-Dancing-All-Java shop and you
can take your silly Python (or Open Source components) and just stick it in your
ear.  We measure effectiveness by our entrenched skill set, not cost to solve a
business problem and value of the business problem being
solved.&lt;/p&gt;
&lt;p&gt;When I taught C programming, I
remember one conversation about upgrading the skills of some of the COBOL people
in addition to bringing in new C programmers.  &amp;quot;We don't really plan on
upgrading our COBOL programmer's skills&amp;quot;, I was told.  My response: &amp;quot;Why not?
Were they born
stupid?&amp;quot;&lt;/p&gt;
&lt;p&gt;Addendum.&lt;/p&gt;
&lt;p&gt;Is
it arrogant to suggest that COBOL programmers can or perhaps
&lt;em&gt;should&lt;/em&gt;
learn C?&lt;/p&gt;
&lt;p&gt;Or, is it arrogant to suggest
that COBOL programmer should not be
pigeon-holed?&lt;/p&gt;
&lt;p&gt;Or, is it arrogant to
suggest that pigeon-holing COBOL programers is the same as labeling them &amp;quot;born
stupid&amp;quot; and, therefore, untrainable?&lt;/p&gt;
&lt;p&gt;It
is probably arrogant to suggest that COBOL programmers are being
&lt;em&gt;maliciously&lt;/em&gt;
held back from learning new technology.  Sometimes, they aren't offered the
training because of the huge legacy maintenance burden that they have to support
while new technology is being introduced
elsewhere.&lt;/p&gt;
&lt;p&gt;This, I think, is why Java
will become like COBOL -- a legacy which we hate but must support.  The people
supporting Java will be pigeon-holed.  New technology efforts will be focused
elsewhere, leaving these people behind.  Not because they're literally born
stupid, but because they've had the bad luck to be supporting the technology
that became the reviled legacy.&lt;/p&gt;
</content><category term="Management"></category><category term="java"></category><category term="cobol"></category><category term="legacy"></category></entry><entry><title>Specifying-Bidding-Buying Software</title><link href="https://slott56.github.io/2005_09_02-specifying_bidding_buying_software.html" rel="alternate"></link><published>2005-09-02T14:44:00-04:00</published><updated>2005-09-02T14:44:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2005-09-02:/2005_09_02-specifying_bidding_buying_software.html</id><summary type="html">&lt;p&gt;Check this out for a new model of software
development.  Why hire full-time developers when your business is not software
development?  Why rent contract labor?  Why not just buy the custom
software?&lt;/p&gt;
&lt;p&gt;Note that your own internal
QA processes have to be top-shelf to do this.  Internal staff can screw …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Check this out for a new model of software
development.  Why hire full-time developers when your business is not software
development?  Why rent contract labor?  Why not just buy the custom
software?&lt;/p&gt;
&lt;p&gt;Note that your own internal
QA processes have to be top-shelf to do this.  Internal staff can screw up and
you can shift deadlines, reduce the promises and otherwise fudge.  If your
specifications are shoddy, and you get a shoddy product, then you permitted a
shoddy contractor to work to your shoddy specifications.  You still hold most of
the blame for cost overruns and
problems.&lt;/p&gt;
&lt;p&gt;Consider many small
deliverables with incremental payments so that you can &amp;quot;pull the plug&amp;quot; when
things don't go the way you
imagined.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.projectspring.com/freelance/index.html"&gt;http://www.projectspring.com/freelance/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.thecentralmall.com/index.html"&gt;http://www.thecentralmall.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.guru.com/"&gt;http://www.guru.com/&lt;/a&gt; `  &amp;lt;&lt;a class="reference external" href="http://www.guru.com/"&gt;http://www.guru.com/&lt;/a&gt;&amp;gt;`_&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.programmingbids.com/"&gt;http://www.programmingbids.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.dice.com/"&gt;http://www.dice.com/&lt;/a&gt;   (to a limited
extent)&lt;/p&gt;
</content><category term="Management"></category><category term="specification"></category><category term="incremental development"></category><category term="outsourcing"></category></entry></feed>