<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>S.Lott -- Software Architect - Literate Programming</title><link href="https://slott56.github.io/" rel="alternate"></link><link href="/feeds/literate-programming.atom.xml" rel="self"></link><id>https://slott56.github.io/</id><updated>2026-02-05T11:13:00-05:00</updated><entry><title>LLM Vibe Coding or Illiterate Programming</title><link href="https://slott56.github.io/2026-01-31_llm_vibe_coding_or_illiterate_programming.html" rel="alternate"></link><published>2026-02-05T11:13:00-05:00</published><updated>2026-02-05T11:13:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2026-02-05:/2026-01-31_llm_vibe_coding_or_illiterate_programming.html</id><summary type="html">&lt;div class="section" id="bluf"&gt;
&lt;h2&gt;BLUF&lt;/h2&gt;
&lt;p&gt;Your LLM conversations are emphatically &lt;strong&gt;not&lt;/strong&gt; Literate Programming.
The term &amp;quot;Literate Programming&amp;quot; cannot include code with separate documentation.&lt;/p&gt;
&lt;p&gt;I won't call it &amp;quot;Illiterate Programming.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sad-story"&gt;
&lt;h2&gt;Sad Story&lt;/h2&gt;
&lt;p&gt;An LLM coder had a lot of things to say about productivity, and explained their approach.
They wrote 800 or so words, and …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="section" id="bluf"&gt;
&lt;h2&gt;BLUF&lt;/h2&gt;
&lt;p&gt;Your LLM conversations are emphatically &lt;strong&gt;not&lt;/strong&gt; Literate Programming.
The term &amp;quot;Literate Programming&amp;quot; cannot include code with separate documentation.&lt;/p&gt;
&lt;p&gt;I won't call it &amp;quot;Illiterate Programming.&amp;quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sad-story"&gt;
&lt;h2&gt;Sad Story&lt;/h2&gt;
&lt;p&gt;An LLM coder had a lot of things to say about productivity, and explained their approach.
They wrote 800 or so words, and -- thankfully -- it didn't seem to have too much AI-slop-talk in it.
Here's my 12-word summary:&lt;/p&gt;
&lt;blockquote&gt;
I save all LLM discussions in the repository along with the code.&lt;/blockquote&gt;
&lt;p&gt;This was followed by something that doesn't seem to make sense to me:&lt;/p&gt;
&lt;blockquote&gt;
This follows Donald Knuth’s literate programming approach.
The narrative is more important than the code.
The code should be easily comprehensible by humans and LLMs alike.&lt;/blockquote&gt;
&lt;p&gt;What? The narrative is distinct from the code? That's not Literate Programming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="disagreement"&gt;
&lt;h2&gt;Disagreement&lt;/h2&gt;
&lt;p&gt;I disagreed: &amp;quot;It seem like this doesn’t precisely fit the original Knuth point of having a single source of truth that creates published results and compiler-friendly code with absolutely transparent tooling.&amp;quot;&lt;/p&gt;
&lt;p&gt;By way of my background, here are two links:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is to suggest that I know a little about Literate Programming.
(I didn't provide this in my response. I'm only providing it here.)&lt;/p&gt;
&lt;p&gt;Here's yet more reference material: &lt;a class="reference external" href="http://www.literateprogramming.com"&gt;http://www.literateprogramming.com&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="non-responsive-response"&gt;
&lt;h2&gt;Non-Responsive Response&lt;/h2&gt;
&lt;p&gt;Their response was 800+ words of what read like AI-slop-talk.
It's hard to parse AI slop.&lt;/p&gt;
&lt;p&gt;I wish folks would include the LLM prompt they used
so I can understand what they were trying to get the LLM to say for them.&lt;/p&gt;
&lt;p&gt;I think I found 5 points floating in the sea of words.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Knuth’s system never caught on.&lt;/p&gt;
&lt;p&gt;True in a narrow sense of &amp;quot;it never surpassed old-fashioned code+comments with separate documentation.&amp;quot;
However, it still has practitioners.
It's still well-defined.
It's still a single narrative that contains the code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Knuth's approach dates in a different time and different technology.&lt;/p&gt;
&lt;p&gt;I don't see how. Code is still code. Documentation is still documentation.
They can still be unified so there's a single narrative that contains the code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Knuth was referring to the combination of the narrative and the code.&lt;/p&gt;
&lt;p&gt;Um. No. In Literate Programming, the narrative &lt;strong&gt;is&lt;/strong&gt; the code.
There's no &amp;quot;combination&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The narrative was not a single, reproducible source of truth.&lt;/p&gt;
&lt;p&gt;Still no. The narrative &lt;strong&gt;is&lt;/strong&gt; the code and &lt;strong&gt;is&lt;/strong&gt; a single document with everything in it.
That was and remains the core principle.
The tooling to extract compliable code from the narrative is transparent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The idea of literate programming is finally taking off, but in a slightly different form.&lt;/p&gt;
&lt;p&gt;Only if &amp;quot;Literate Programming&amp;quot; is twisted out of alignment with what it originally meant.
Collocating the LLM vibe-conversation with the code means the narrative is separate from the code.
This isn't literate programming.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I found this aggravating because I don't think we should bend the terminology like that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-suggestion"&gt;
&lt;h2&gt;A Suggestion&lt;/h2&gt;
&lt;p&gt;I provided the Bart Childs &amp;quot;Literate Programming, A Practitioner's View&amp;quot;, Tugboat, December 1992, pg. 261-262 quote from &lt;a class="reference external" href="http://www.literateprogramming.com"&gt;http://www.literateprogramming.com&lt;/a&gt; as background for my viewpoint.&lt;/p&gt;
&lt;p&gt;I followed it with this: &amp;quot;I think this LLM-based programming is something new and different and needs a new and different descriptive phrase.&amp;quot;&lt;/p&gt;
&lt;p&gt;I tried (and failed) to make it clear that they're misusing the words.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The response was dismissive. Thank god it wasn't 800 words of slop.
Merely 350 words that seemed to suggest they didn't waste time reading the material I provided.
(And if they did, they refuse to change their approach.)&lt;/p&gt;
&lt;p&gt;The bottom line was they couldn't think of another way to describe the idea of keeping the LLM conversation with the code.
They were going to continue to call it Literate Programming.
In spite of the documentation being explicitly separate from the code.&lt;/p&gt;
&lt;p&gt;Sigh.&lt;/p&gt;
&lt;p&gt;Since the next stop on this journey is a flame war, I exited the original conversation and posted my angry response here.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Literate Programming"></category><category term="AI"></category><category term="LLM"></category><category term="vibe coding"></category></entry><entry><title>Literate Programming with PyWebLP</title><link href="https://slott56.github.io/2023-07-18-literate_programming_with_pyweblp.html" rel="alternate"></link><published>2023-07-18T09:00:00-04:00</published><updated>2023-07-18T09:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2023-07-18:/2023-07-18-literate_programming_with_pyweblp.html</id><summary type="html">&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And &lt;a class="reference external" href="https://pypi.org/project/py-web-lp/"&gt;https://pypi.org/project/py-web-lp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I finally made the PyWeb LP tool installable from PyPI.&lt;/p&gt;
&lt;p&gt;I need to fix the name of the GitHub repo (some day) to make it also say &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;py-web-lp&lt;/span&gt;&lt;/tt&gt;.
I should also fixup my tag cloud to say pyweblp …&lt;/p&gt;</summary><content type="html">&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And &lt;a class="reference external" href="https://pypi.org/project/py-web-lp/"&gt;https://pypi.org/project/py-web-lp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I finally made the PyWeb LP tool installable from PyPI.&lt;/p&gt;
&lt;p&gt;I need to fix the name of the GitHub repo (some day) to make it also say &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;py-web-lp&lt;/span&gt;&lt;/tt&gt;.
I should also fixup my tag cloud to say pyweblp instead of &lt;a class="reference external" href="https://slott56.github.io/tag/pyweb.html"&gt;pyweb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I cleaned up a few small things in the project.&lt;/p&gt;
&lt;p&gt;This whole thing started a loooong time ago. See &lt;a class="reference external" href="https://slott56.github.io/2007_02_02-editing_docbook_xml.html"&gt;Editing DocBook XML&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Click the &lt;a class="reference external" href="https://slott56.github.io/tag/literate-programming.html"&gt;literate programming tag&lt;/a&gt; for a lot more on this topic.&lt;/p&gt;
&lt;p&gt;Background:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2010_03_14-literate_programming.html"&gt;Literate Programming&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2010_04_07-fancy_literate_programming.html"&gt;Fancy Literate Programming&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also, I found &lt;cite&gt;pyLit&lt;/cite&gt;. See &lt;a class="reference external" href="https://slott56.github.io/2013_10_03-literate_programming_and_pylit.html"&gt;Literate Programming and PyLit&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But, back to the PyWeb LP thread and more recent changes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2017_05_13-literate_programming_life_cycle.html"&gt;Literate Programming Life Cycle&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2022_06_21-my_shifting_understanding_and_a_terrible_design_mistake.html"&gt;My Shifting Understanding and A Terrible Design Mistake&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2022_06_28-massive_rework_of_data_structures.html"&gt;Massive Rework of Data Structures&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2022_07_05-revised_understanding_revised_data_structures_revised_type_hints.html"&gt;Revised Understanding --&amp;gt; Revised Data Structures --&amp;gt; Revised Type Hints&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://slott56.github.io/2022_08_09-tragedy_averted.html"&gt;Tragedy Averted&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, it's installable.&lt;/p&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="pyweb"></category></entry><entry><title>Tragedy Averted</title><link href="https://slott56.github.io/2022_08_09-tragedy_averted.html" rel="alternate"></link><published>2022-08-09T08:00:00-04:00</published><updated>2022-08-09T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2022-08-09:/2022_08_09-tragedy_averted.html</id><summary type="html">&lt;p&gt;I almost made a terrible blunder.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt; for some background. This is
a &amp;quot;Literate Programming&amp;quot; tool. I started fooling around with this kind
of thing back in '05 (maybe even earlier.) This is not the blunder. The
whole idea of literate programming is not very …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I almost made a terrible blunder.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt; for some background. This is
a &amp;quot;Literate Programming&amp;quot; tool. I started fooling around with this kind
of thing back in '05 (maybe even earlier.) This is not the blunder. The
whole idea of literate programming is not very popular. I'm a fan of
&lt;a class="reference external" href="https://jupyterbook.org/en/stable/intro.html"&gt;Jupyter{Book}&lt;/a&gt; as the
state of the art in sophisticated literate programming, if you're
interested in it.&lt;/p&gt;
&lt;p&gt;In my case, I started this project so long ago, I
used &lt;a class="reference external" href="https://docutils.sourceforge.io"&gt;docutils&lt;/a&gt;. This was
long before &lt;a class="reference external" href="https://github.com/sphinx-doc/sphinx"&gt;Sphinx&lt;/a&gt; arrived on
the scene. I never updated my little project to use Sphinx. The point
was to have a kind of pure literate programming tool that could work
with a variety of markup languages, including (but not limited to) RST.&lt;/p&gt;
&lt;p&gt;Recently, I learned about &lt;a class="reference external" href="https://plantuml.com"&gt;PlantUML&lt;/a&gt;. The idea
of a text description of a diagram is appealing. I don't really need to
draw it; I just need to specify what's in it and let
&lt;a class="reference external" href="https://graphviz.org"&gt;graphviz&lt;/a&gt; do the rest. This tool is very, very
cool. You can capture ideas quickly. You can refine and expand on ideas
until you reach a point where code makes more sense than a picture of
code.&lt;/p&gt;
&lt;p&gt;For some things, you can gather data and draw a picture of things *as
they are*. This is particularly valuable for cloud-based infrastructure
where a few queries leads to PlantUML source that is depicted very
nicely.&lt;/p&gt;
&lt;p&gt;Which leads to the idea of Literate Programming including UML diagrams.&lt;/p&gt;
&lt;p&gt;Doesn't sound too difficult. I can create an extension to &lt;strong&gt;docutils&lt;/strong&gt;
to introduce a UML directive. The resulting RST would look like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
..  uml::

    left to right direction
    skinparam actorStyle awesome

    actor &amp;quot;Developer&amp;quot; as Dev
    rectangle PyWeb {
        usecase &amp;quot;Tangle Source&amp;quot; as UC_Tangle
        usecase &amp;quot;Weave Document&amp;quot; as UC_Weave
    }
    rectangle IDE {
        usecase &amp;quot;Create WEB&amp;quot; as UC_Create
        usecase &amp;quot;Run Tests&amp;quot; as UC_Test
    }
    Dev --&amp;gt; UC_Tangle
    Dev --&amp;gt; UC_Weave
    Dev --&amp;gt; UC_Create
    Dev --&amp;gt; UC_Test

    UC_Test --&amp;gt; UC_Tangle
&lt;/pre&gt;
&lt;p&gt;This could be handy to have the diagrams as part of the documentation
that tangles the working the code. One source for all of it.&lt;/p&gt;
&lt;p&gt;I started down the path of researching &lt;strong&gt;docutils&lt;/strong&gt; extensions. Got
pretty far. Far enough that I had an empty repository and everything. I
was about ready to start creating spike solutions.&lt;/p&gt;
&lt;p&gt;Then.&lt;/p&gt;
&lt;p&gt;[&lt;em&gt;music cue&lt;/em&gt;] *&lt;a class="reference external" href="https://www.youtube.com/watch?v=9mSVzGnKsXw"&gt;duh duh
duuuuuuh&lt;/a&gt;*&lt;/p&gt;
&lt;p&gt;I found that Sphinx already has an extension for PlantUML. I almost
started reading the code to see how it worked.&lt;/p&gt;
&lt;p&gt;Then I realized how dumb that was. It already works. Why read the code?
Why not install it?&lt;/p&gt;
&lt;p&gt;I had a choice to make.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Continue building my own &lt;strong&gt;docutils&lt;/strong&gt; plug-in.&lt;/li&gt;
&lt;li&gt;Switch to Sphinx.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some complications:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;My Literate Programming tool produces RST that *may* not be
compatible with Sphinx.&lt;/li&gt;
&lt;li&gt;It's yet another dependency in a tool that started out with zero
dependencies. I've added pytest and tox. What next?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What to do?&lt;/p&gt;
&lt;p&gt;I have to say that Git is amazing. I can make a branch for the spike. If
it works, pull request. If it doesn't work, delete the branch. This
continues to be game-changing to me. I'm old. I remember when we had to
back up the whole project directory tree before making this kind of
change.&lt;/p&gt;
&lt;p&gt;It worked. My tool's RST (with one exception) worked perfectly with
Sphinx. The one exception was an obscure directive, &lt;tt class="docutils literal"&gt;.. class:: name&lt;/tt&gt;,
used to provide an HTML class name for the following block. This always
should have been the &lt;strong&gt;docutils&lt;/strong&gt; &lt;tt class="docutils literal"&gt;.. container:: name&lt;/tt&gt; directive.
With this fix, we're good to go.&lt;/p&gt;
&lt;p&gt;I'm happy I avoided the trap of reimplementing something. Instead of
that, I upgraded from &amp;quot;bare&amp;quot; &lt;strong&gt;docutils&lt;/strong&gt; with my own CSS to Sphinx with
it's sophisticated templates and HTML Themes.&lt;/p&gt;
</content><category term="literate programming"></category><category term="sphinx"></category><category term="#python"></category><category term="docutils"></category><category term="plantuml"></category><category term="pyWeb"></category></entry><entry><title>Revised Understanding --&gt; Revised Data Structures --&gt; Revised Type Hints</title><link href="https://slott56.github.io/2022_07_05-revised_understanding_revised_data_structures_revised_type_hints.html" rel="alternate"></link><published>2022-07-05T08:00:00-04:00</published><updated>2022-07-05T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2022-07-05:/2022_07_05-revised_understanding_revised_data_structures_revised_type_hints.html</id><summary type="html">&lt;p&gt;My literate programming tool, pyWeb, has moved to version 3.1 --
supporting modern Python.&lt;/p&gt;
&lt;p&gt;Next up, version 3.2. This is a massive reworking of the data structures
involved. The rework lets me use Jinja2 for templates. There's a lot of
fiddliness to getting the end-of-line spacing right. Jinja has …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My literate programming tool, pyWeb, has moved to version 3.1 --
supporting modern Python.&lt;/p&gt;
&lt;p&gt;Next up, version 3.2. This is a massive reworking of the data structures
involved. The rework lets me use Jinja2 for templates. There's a lot of
fiddliness to getting the end-of-line spacing right. Jinja has the
following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{% for construct in container -%}
{{construct}}
{%- endfor %}
&lt;/pre&gt;
&lt;p&gt;The easy-to-overlook hyphens suppress spacing, allowing the construct to
be spread onto multiple lines without introducing extra newlines into
the output. This makes it a little easier to debug the templates.&lt;/p&gt;
&lt;p&gt;It now works. But. Until I get past strict type checks, there's no
reason for calling it done.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Found 94 errors in 1 file (checked 3 source files)
&lt;/pre&gt;
&lt;p&gt;The bulk of the remaining problems seem to be new methods where I forgot
to include a type hint. The more pernicious problems are places where I
have inconsistent hints and Liskov substitution problems. The worst a
places where I had a last-minute change change and switched from &lt;tt class="docutils literal"&gt;str&lt;/tt&gt;
to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; and did not actually follow-through and make required
changes.&lt;/p&gt;
&lt;p&gt;The biggest issue?&lt;/p&gt;
&lt;p&gt;When building an AST, it's common to have a union of a wide variety of
types. This union often has a discriminator value to separate
&lt;tt class="docutils literal"&gt;NamedChunk&lt;/tt&gt; from &lt;tt class="docutils literal"&gt;OutputChunk&lt;/tt&gt;. This is &amp;quot;type narrowing&amp;quot; and there
are a variety of approaches. I think my best choice is a &lt;tt class="docutils literal"&gt;TypeGuard&lt;/tt&gt;
declaration. This is new to me, so I've got to do some learning before I
can properly define the required type guard function(s).
(See &lt;a class="reference external" href="https://mypy.readthedocs.io/en/stable/type_narrowing.html#user-defined-type-guards"&gt;https://mypy.readthedocs.io/en/stable/type_narrowing.html#user-defined-type-guards&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;I'm looking forward (eagerly) to finishing the cleanup.&lt;/p&gt;
&lt;p&gt;The problem is that I'm -- also -- working on the updates to &lt;a class="reference external" href="https://www.google.com/search?client=safari&amp;amp;rls=en&amp;amp;q=packt+functional+python+programming+2e&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8"&gt;Functional
Python
Programming&lt;/a&gt;.
The PyWeb project is a way to relax my brain from editing the book.&lt;/p&gt;
&lt;p&gt;Which means the pyWeb updates have to wait for Chapter 4 and 5 edits.
(Sigh.)&lt;/p&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="pyWeb"></category></entry><entry><title>Massive Rework of Data Structures</title><link href="https://slott56.github.io/2022_06_28-massive_rework_of_data_structures.html" rel="alternate"></link><published>2022-06-28T08:00:00-04:00</published><updated>2022-06-28T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2022-06-28:/2022_06_28-massive_rework_of_data_structures.html</id><summary type="html">&lt;p&gt;As noted in &lt;a class="reference external" href="https://slott56.github.io/2022_06_21-my_shifting_understanding_and_a_terrible_design_mistake.html"&gt;My Shifting Understanding and A Terrible Design
Mistake&lt;/a&gt;,
I had a design that focused on serialization instead of proper modeling
of the objects in question.&lt;/p&gt;
&lt;p&gt;Specifically, I didn't start with a suitable abstract syntax tree (AST)
structure. I started with an algorithmic view of &amp;quot;weaving&amp;quot; and
&amp;quot;tangling …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As noted in &lt;a class="reference external" href="https://slott56.github.io/2022_06_21-my_shifting_understanding_and_a_terrible_design_mistake.html"&gt;My Shifting Understanding and A Terrible Design
Mistake&lt;/a&gt;,
I had a design that focused on serialization instead of proper modeling
of the objects in question.&lt;/p&gt;
&lt;p&gt;Specifically, I didn't start with a suitable abstract syntax tree (AST)
structure. I started with an algorithmic view of &amp;quot;weaving&amp;quot; and
&amp;quot;tangling&amp;quot; to transform a WEB of definitions into documentation and
code. The weaving and tangling are two of the three distinct
serializations of a common AST.&lt;/p&gt;
&lt;p&gt;The third serialization is the common source format that underpins the
WEB of definitions. Here's an example that contains a number of
definitions and a tangled output file.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Fast Exponentiation
===================

A classic divide-and-conquer algorithm.

&amp;#64;d fast exp &amp;#64;{
def fast_exp(n: int, p: int) -&amp;gt; int:
    match p:
        case 0:
            return 1
        case _ if p % 2 == 0:
            t = fast_exp(n, p // 2)
            return t * t
        case _ if p % 1 == 0:
            return n * fast_exp(n, p - 1)
&amp;#64;| fast_exp
&amp;#64;}

With a test case.

&amp;#64;d test case &amp;#64;{
&amp;gt;&amp;gt;&amp;gt; fast_exp(2, 30)
1073741824
&amp;#64;}

&amp;#64;o example.py &amp;#64;{
&amp;#64;&amp;lt; fast exp &amp;#64;&amp;gt;

__test__ = {
    &amp;quot;test 1&amp;quot;: '''
&amp;#64;&amp;lt; test case &amp;#64;&amp;gt;
    '''
}
&amp;#64;| __test__
&amp;#64;}

Use ``python -m doctest`` to test.

Macros
------

&amp;#64;m

Names
-----

&amp;#64;u
&lt;/pre&gt;
&lt;p&gt;This example uses RST as the markup language for the woven document. A
tool can turn this simplified document into complete RST with
appropriate wrappers around the code blocks. The tool can also weave the
&lt;tt class="docutils literal"&gt;example.py&lt;/tt&gt; file from the source document.&lt;/p&gt;
&lt;p&gt;The author can focus on exposition, explaining the algorithm. The reader
gets the key points without the clutter of programming language
overheads and complications.&lt;/p&gt;
&lt;p&gt;The compiler gets a tangled source.&lt;/p&gt;
&lt;p&gt;The key point is to have a tool that's (mostly) agnostic with respect to
programming language and markup language. Being fully agnostic isn't
possible, of course. The &lt;tt class="docutils literal"&gt;&amp;#64;d name &amp;#64;{code&amp;#64;}&lt;/tt&gt; constructs are transformed
into markup blocks of some sophistication. The &lt;tt class="docutils literal"&gt;&amp;#64;&amp;lt;name&amp;#64;&amp;gt;&lt;/tt&gt; becomes a
hyperlink, with suitable markup. Similarly, the cross
reference-generating commands, &lt;tt class="docutils literal"&gt;&amp;#64;m&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&amp;#64;u&lt;/tt&gt;, generate a fair amount
of markup content.&lt;/p&gt;
&lt;p&gt;I now have Jinja templates to do this in RST. I'll also have to provide
LaTeX and HTML. Further, I need to provide generic LaTeX along with
LaTeX I can use with PacktPub's LaTeX publishing pipeline. But let's not
look too far down the road. First things first.&lt;/p&gt;
&lt;div class="section" id="tl-dr"&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Here's today's progress measurement.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
==================== 67 failed, 13 passed, 1 error in 1.53s ====================
&lt;/pre&gt;
&lt;p&gt;This comforts me a great deal. Some elements of the original structure
still work. There are two kinds of failures: new test fixtures that
require &lt;tt class="docutils literal"&gt;TestCase.setUp()&lt;/tt&gt; methods, and tests for features that are no
longer part of the design.&lt;/p&gt;
&lt;p&gt;In order to get the refactoring to a place where it would even run, I
had to incorporate some legacy methods that -- it appears -- will
&lt;em&gt;eventually&lt;/em&gt; become dead code. It's not totally dead, yet, because I'm
still mid-way through the refactoring.&lt;/p&gt;
&lt;p&gt;But. I'm no longer beating back and forth trying to see if I've got a
better design. I'm now on the downwind broad reach of finding and fixing
the 67 test cases that are broken.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="Test-Driven Development"></category><category term="#python"></category><category term="pyWeb"></category></entry><entry><title>My Shifting Understanding and A Terrible Design Mistake</title><link href="https://slott56.github.io/2022_06_21-my_shifting_understanding_and_a_terrible_design_mistake.html" rel="alternate"></link><published>2022-06-21T08:00:00-04:00</published><updated>2022-06-21T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2022-06-21:/2022_06_21-my_shifting_understanding_and_a_terrible_design_mistake.html</id><summary type="html">&lt;p&gt;I've been fascinated by Literate Programming forever.&lt;/p&gt;
&lt;p&gt;I have two utterly divergent takes on this.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt; for one.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt; for another.&lt;/p&gt;
&lt;p&gt;And yet, I've still done a really bad design job. Before we get to the
design, a little bit …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've been fascinated by Literate Programming forever.&lt;/p&gt;
&lt;p&gt;I have two utterly divergent takes on this.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt; for one.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;https://github.com/slott56/py-web-tool&lt;/a&gt; for another.&lt;/p&gt;
&lt;p&gt;And yet, I've still done a really bad design job. Before we get to the
design, a little bit of back story.&lt;/p&gt;
&lt;div class="section" id="back-story"&gt;
&lt;h2&gt;Back Story&lt;/h2&gt;
&lt;p&gt;Why two separate literate programming projects? Because it's not
&lt;strong&gt;clear&lt;/strong&gt; what's best. It's a field without too many boundaries and a
lot of questions about the value produced.&lt;/p&gt;
&lt;p&gt;PyLit I found, forked, and upgraded to Python 3. I didn't design it.
It's far more clever than something I'd design.&lt;/p&gt;
&lt;p&gt;Py-Web-Tool is something I wrote based on using a whole bunch of tools
that follow along behind the original WEB tools. Nothing to do with web
servers or web.py.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-problem-domain"&gt;
&lt;h2&gt;The Problem Domain&lt;/h2&gt;
&lt;p&gt;The design problem is, in retrospect, pretty obvious. I set it out here
as a cautionary tale.&lt;/p&gt;
&lt;p&gt;I'm looking at the markup languages for doing literate programming. The
idea is to have named blocks of code in your document, presented in an
order that makes sense to your reader. A tool will &amp;quot;weave&amp;quot; a document
from your source. It will also &amp;quot;tangle&amp;quot; source code by rearranging the
code snippets from presentation order into compiler-friendly order.&lt;/p&gt;
&lt;p&gt;This means you can present your core algorithm first, even though it's
buried in the middle of some module in the middle of your package.&lt;/p&gt;
&lt;p&gt;The presentation order is *not* tied to the order needed by your
language's toolchain.&lt;/p&gt;
&lt;p&gt;For languages like C this is huge freedom. For Python, it's not such a
gigantic win.&lt;/p&gt;
&lt;p&gt;The source material is a &amp;quot;web&amp;quot; of code and information about the code. A
web file may look like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Important insight.

&amp;#64;d core feature you need to know about first &amp;#64;{
    def somecode() -&amp;gt; None:
        pass
&amp;#64;}

And see how this fits into a larger context?

&amp;#64;d something more expansive &amp;#64;{
def this() -&amp;gt; None:
    pass

def that() -&amp;gt; None:
    pass

&amp;#64;&amp;lt;core feature you need to know about first&amp;#64;&amp;gt;
&amp;#64;}

See how that works?
&lt;/pre&gt;
&lt;p&gt;This is easy to write and (relatively) easy to read. The
&lt;tt class="docutils literal"&gt;&amp;#64;&amp;lt;core feature you need to know about first&amp;#64;&amp;gt;&lt;/tt&gt; becomes a hyperlink in
the published documentation. So you can flip between the sections. It's
physically expanded inline to tangle the code, but you don't often need
to look at the tangled code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-design-question"&gt;
&lt;h2&gt;The Design Question&lt;/h2&gt;
&lt;p&gt;The essential Literate Programming tool is a compiler with two outputs:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The &amp;quot;woven&amp;quot; document with markup and such&lt;/li&gt;
&lt;li&gt;The &amp;quot;tangled&amp;quot; code files which are code, largely untouched, but
reordered.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We've got four related problems.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Parsing the input&lt;/li&gt;
&lt;li&gt;An AST we can process&lt;/li&gt;
&lt;li&gt;Emitting tangled output from the AST&lt;/li&gt;
&lt;li&gt;Emitting woven output form the AST&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Or, we can look at it as three classic problems: deserialization, AST
representation, and serialization. Additionally, we have two distinct
serialization alternatives.&lt;/p&gt;
&lt;p&gt;What did I do?&lt;/p&gt;
&lt;p&gt;I tackled serialization first. Came up with a cool bunch of classes and
methods to serialize the two kinds of documents.&lt;/p&gt;
&lt;p&gt;Then I wrote the deserialization (or parsing) of the source WEB file.
This is pretty easy, since the markup is designed to be as trivial as
possible.&lt;/p&gt;
&lt;p&gt;The representation is little more than glue between the two.&lt;/p&gt;
&lt;p&gt;What a mistake.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-wrong-answer"&gt;
&lt;h2&gt;A Wrong Answer&lt;/h2&gt;
&lt;p&gt;Focusing on serialization was an epic mistake.&lt;/p&gt;
&lt;p&gt;I want to try using
&lt;a class="reference external" href="https://jinja.palletsprojects.com/en/3.1.x/"&gt;Jinja2&lt;/a&gt; for the markup
templates instead of
&lt;a class="reference external" href="https://docs.python.org/3/library/string.html#template-strings"&gt;string.Template&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However.&lt;/p&gt;
&lt;p&gt;My AST was such a bad hack job it was essentially impossible to use it.
It was a quagmire of inconsistent ad-hoc methods to solve a specific
serialization issue.&lt;/p&gt;
&lt;p&gt;As I start down the Jinja road, I found a need to be able to build an
AST without the overhead of parsing.&lt;/p&gt;
&lt;p&gt;Which caused me to realize that the AST was -- while structurally
sensible -- far from the simple ideal.&lt;/p&gt;
&lt;p&gt;What's the ideal?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-right-answer"&gt;
&lt;h2&gt;The Right Answer&lt;/h2&gt;
&lt;p&gt;This ideal AST is something that lets me build test fixtures like this:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
example = Web(
   chunks=[
       TextChunk(&amp;quot;\n&amp;quot;),
       NamedCodeChunk(name=&amp;quot;core feature you need to know about first&amp;quot;, lines=[&amp;quot;def someconme() -&amp;gt; None: ...&amp;quot;, &amp;quot;pass&amp;quot;])),
       TextChunk(&amp;quot;\nAnd see how this fits into a larger context?\n&amp;quot;),
       NamedCodeChunk(name=&amp;quot;something more expansive&amp;quot;, lines=[etc. etc.])
   ]
)
&lt;/pre&gt;
&lt;p&gt;Here's my test for usability: I can build the AST &amp;quot;manually&amp;quot; without a
parser.&lt;/p&gt;
&lt;p&gt;The parser can build one, also, but I can build it as a sensible,
readable, first-class Python object.&lt;/p&gt;
&lt;p&gt;This has pointed me to a better design for the overall constructs of the
WEB source document. Bonus. It's helping me define Jinja templates that
can render this as a sensible woven document.&lt;/p&gt;
&lt;p&gt;Tangling does not need Jinja. It's simpler. And -- by convention -- the
tangled code does not have anything injected into it. The woven code is
in a markup language (Markdown, RST, HTML, LaTeX, ASCII DOC, whatever)
and some markup is required to create hyperlinks and code sections.
Jinja is super helpful here.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tl-dr"&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;The essence of the problem is rarely serialization or deserialization.&lt;/dt&gt;
&lt;dd&gt;It's the internal representation.&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="when-learning-how-to-use-a-word-processor-it-turn"&gt;
&lt;h2&gt;When learning how to use a word processor, it turn...&lt;/h2&gt;
&lt;p&gt;Unknown&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2022-07-16 13:24:35.832000-04:00&lt;/p&gt;
&lt;p&gt;When learning how to use a word processor, it turns out the second word
processor you learn takes longer than the first. As you explore the
second one, the core ideas get contemplated and refined. The third one
on is just &amp;quot;where's the quick reference&amp;quot;. We do the same with rewriting
code, as you are discovering. One point of literate programming is to
explain the insights we gain.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="jinja"></category><category term="pyWeb"></category><category term="PyLit3"></category></entry><entry><title>A LaTeX Thing I Did -- And A ToDo:</title><link href="https://slott56.github.io/2022_06_14-a_latex_thing_i_did_and_a_todo.html" rel="alternate"></link><published>2022-06-14T08:00:00-04:00</published><updated>2022-06-14T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2022-06-14:/2022_06_14-a_latex_thing_i_did_and_a_todo.html</id><summary type="html">&lt;p&gt;When writing about code in LaTeX, the essential strategy is to use an
environment to format the code so it stands out from surrounding text.
There are a few of these environments available as LaTeX add-on
packages. The three popular ones are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;verbatim&lt;/strong&gt;. I think this is built-in to LaTeX …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;When writing about code in LaTeX, the essential strategy is to use an
environment to format the code so it stands out from surrounding text.
There are a few of these environments available as LaTeX add-on
packages. The three popular ones are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;verbatim&lt;/strong&gt;. I think this is built-in to LaTeX. It's not very
clever, but it is simple to use.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;listings&lt;/strong&gt;. See &lt;a class="reference external" href="https://www.overleaf.com/learn/latex/Code_listing"&gt;https://www.overleaf.com/learn/latex/Code_listing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;minted&lt;/strong&gt;.
See &lt;a class="reference external" href="https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted"&gt;https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are nice for making code readable and distinct from the
surrounding text.&lt;/p&gt;
&lt;p&gt;A common way to talk about the code is to use inline verbatim
&lt;tt class="docutils literal"&gt;\verb|code|&lt;/tt&gt; sections. I prefer inline &lt;tt class="docutils literal"&gt;\lstinline|code|&lt;/tt&gt;, but, my
editor prefers &lt;tt class="docutils literal"&gt;\verb&lt;/tt&gt;. (I have trouble getting all the moving parts
of minted installed properly, so I use &lt;strong&gt;listings&lt;/strong&gt;.)&lt;/p&gt;
&lt;p&gt;Also. And more important.&lt;/p&gt;
&lt;p&gt;There's the
&lt;tt class="docutils literal"&gt;\lstinputlisting[language=Python, firstline=2, &lt;span class="pre"&gt;lastline=12]{some_module.py}&lt;/span&gt;&lt;/tt&gt;
command. This lets an author incorporate examples from working, tested
modules. Minted doesn't seem to have this, but it might work with an
&lt;tt class="docutils literal"&gt;\input&lt;/tt&gt; command. Don't know. Haven't tried.&lt;/p&gt;
&lt;p&gt;Let's talk about workflow.&lt;/p&gt;
&lt;div class="section" id="workflow"&gt;
&lt;h2&gt;Workflow&lt;/h2&gt;
&lt;p&gt;The idea behind these tools is you have code and after that, you write
about the code. I call this &lt;strong&gt;code first&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Doing this means you can include code snippets from a file.&lt;/p&gt;
&lt;p&gt;Which is okay, but, there's another point of view: you have a document
that contains the code. This is closer to the Literate Programming POV.
I call this &lt;strong&gt;document first&lt;/strong&gt;. I've got all the code in the document
you're reading, I've just broken it up and spread it around in an order
to serve my purpose as a writer, not serve the limitations of a parser
or compiler.&lt;/p&gt;
&lt;p&gt;There is a development environment --
&lt;a class="reference external" href="https://texfaq.org/FAQ-webpkgs"&gt;WEB&lt;/a&gt; -- to create code that can be
run through the Weave and Tangle tools to create working code and usable
documentation. This is appealing in many ways.&lt;/p&gt;
&lt;p&gt;For now, I'm settling for the following workflow:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Write the document with code samples. Use &lt;tt class="docutils literal"&gt;\lstlisting&lt;/tt&gt; environment
with explicit unique labels for each snippet. The idea is to focus on
the documentation with explanations.&lt;/li&gt;
&lt;li&gt;Write a Jinja template that references the code samples. This is a
lot of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;{{extract['lst:listing_1']}}&lt;/span&gt;&lt;/tt&gt; kind of references. There's a
bit more that can go in here, we'll return to the templates in a
moment.&lt;/li&gt;
&lt;li&gt;Run a tool to extract all the &lt;tt class="docutils literal"&gt;\lstlisting&lt;/tt&gt; environments to a
dictionary with the label as the key and the block of text as the
value. This serializes nicely as a JSON (or TOML or YAML) file. It
can even be pickled, but I prefer to be able to look at the file to
see what's in it.&lt;/li&gt;
&lt;li&gt;The tool to populate the template is a kind of trivial thing to build
a Jinja environment, load up the template, fill in the code samples,
and write the result.&lt;/li&gt;
&lt;li&gt;I can then use &lt;strong&gt;tox&lt;/strong&gt; (and &lt;strong&gt;doctest&lt;/strong&gt; and &lt;strong&gt;pytest&lt;/strong&gt; and &lt;strong&gt;mypy&lt;/strong&gt;)
to test the resulting module to be sure it works.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This tangles code from a source document. There's no weave step, since
the source is already designed for publication. This does require me to
make changes to the LaTeX document I'm writing and run a &lt;tt class="docutils literal"&gt;make test&lt;/tt&gt;
command to extract, tangle, and test. This is not a huge burden. Indeed,
it's easy to implement in PyCharm, because the latest release of PyCharm
understands Makefiles and tox. Since each chapter is a distinct
environment, I can use &lt;tt class="docutils literal"&gt;tox &lt;span class="pre"&gt;-e&lt;/span&gt; ch01&lt;/tt&gt; to limit the testing to only the
chapter I'm working on.&lt;/p&gt;
&lt;p&gt;I like this because it lets me focus on explanation, not implementation
details. It helps me make sure that all the code in the book is fully
tested.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-templates"&gt;
&lt;h2&gt;The Templates&lt;/h2&gt;
&lt;p&gt;The template files for an example module have these three kinds of code
blocks:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Ordinary Listings. These fall into two subclasses.&lt;/li&gt;
&lt;li&gt;&lt;ol class="first arabic"&gt;
&lt;li&gt;Complete function or class definitions.&lt;/li&gt;
&lt;li&gt;Lines of code taken out of context.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;REPL Examples.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These have three different testing requirements. We'll start with the
&amp;quot;complete function or class definitions.&amp;quot;  For these, the template might
look like the following&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{{extract['lst:listing_1']}}

def test_listing_1() -&amp;gt; None:
    assert listing_1(42)
    assert not listing_1(None)
&lt;/pre&gt;
&lt;p&gt;This has both the reference to the code in the text of the book and a
test case for the code.&lt;/p&gt;
&lt;p&gt;For lines of code out of context, we have to be more careful. We might
have this.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
def some_example(arg: int) -&amp;gt; bool:
    {{extract['lst:listing_2']}}

def test_listing_2() -&amp;gt; None:
    assert listing_2(42)
    assert not listing_2(None)
&lt;/pre&gt;
&lt;p&gt;This is similar to a complete definition, but it has a fiddly
indentation that needs to be properly managed, also. Jinja's generally
good about not inserting spaces. The template, however, is full of what
&lt;em&gt;could&lt;/em&gt; appear to be syntax errors, so the code editor &lt;strong&gt;could&lt;/strong&gt; have a
conniption with all those &lt;tt class="docutils literal"&gt;{}&lt;/tt&gt; blocks of code. They happen to be valid
Python set literals, so, they're tolerated. PyCharm's type checking
hates them.&lt;/p&gt;
&lt;p&gt;The REPL examples, look like this.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
REPL_listing_3 = &amp;quot;&amp;quot;&amp;quot;
{{extract['lst:listing_3']}}
&amp;quot;&amp;quot;&amp;quot;
&lt;/pre&gt;
&lt;p&gt;I collect these into a &lt;tt class="docutils literal"&gt;__test__&lt;/tt&gt; variable to make them easy for
doctest to find. The extra fussiness of  a &lt;tt class="docutils literal"&gt;__test__&lt;/tt&gt; variable isn't
needed, but it provides a handy audit for me to make sure everything has
a home.&lt;/p&gt;
&lt;p&gt;The following line of code is in most (not all) templates.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
__test__ = {
    name: value
    for name, value in globals().items()
    if name.startswith(&amp;quot;REPL&amp;quot;)
}
&lt;/pre&gt;
&lt;p&gt;This will locate all of the global variables with names starting with
REPL and put them in the &lt;tt class="docutils literal"&gt;__test__&lt;/tt&gt; mapping. The REPL names then
become the test case names, making any test failures easier to spot.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-goal"&gt;
&lt;h2&gt;My Goal&lt;/h2&gt;
&lt;p&gt;I do have some Literate Programming tools that I might be able to
leverage to make myself a Weaver that produces useful LaTeX my publisher
can work with. I should do this because it would be slightly simpler.
The problem is my Web/Weave/Tangle tooling has a bunch of dumb
assumptions about the weave and tangle outputs; a problem I really need
to fix.&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/py-web-tool"&gt;py-web-tool&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea here is to mimic other WEB-based tooling. These are the two
primary applications:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Weave&lt;/strong&gt;. This makes documentation in a fairly transparent way from
the source. There are a bunch of substitutions required to fill in
HTML or LaTeX or Markdown or RST around the generic source. Right
now, this is pretty inept and almost impossible to configure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tangle&lt;/strong&gt;. This makes code from the source. The point here is the
final source file is not necessarily built in any &lt;em&gt;obvious&lt;/em&gt; order.
It's a tangle of things from the documentation, put into the order
required by parser or compiler or build system or whatever.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The weaving requires a better way to provide the various templates that
fill in missing bits. Markdown, for example, works well with fenced
blocks. RST uses a code directive that leads to an extra level of
indentation that needs to be carefully excised. Futher, most markup
languages have a mountain of cruft that goes around the content. This is
unpleasantly complex, and very much subject to odd little changes that
don't track against the content, but are part of the evolution of the
markup language.&lt;/p&gt;
&lt;p&gt;My going-in assumption on tangling was the document contained &lt;strong&gt;all&lt;/strong&gt;
the code. All of it. Without question or exception. For C/C++ this means
all the fiddly little pre-processor directives that add no semantic
clarity yet must be in the code file. This means the preprocessor
nonsense had to be relegated to an appendix of &amp;quot;yet more code that just
has to be there.&amp;quot;&lt;/p&gt;
&lt;p&gt;After writing a tangler to pull code from a book into a variety of
contexts, I'm thinking I need to have a tangler that works with a
template engine. I think there would be the following two use cases:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;No-Template Case&lt;/strong&gt;. The WEB source is complete. This works well for
a lot of languages that don't have the kind of cruft that C/C++ has.
It generally means a WEB source document will contain definition(s)
for the final code file(s) as a bunch of references to the
previously-explained bits. For C/C++, this final presentation can
include the fiddly bits of preprocessor cruft.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template Case&lt;/strong&gt;. A template is used to with the source to create
the tangled output. This is what I have now for pulling book content
into a context where it is testable. For the most part, the template
files are quite small because the book includes test cases in the
form of REPL blocks. This presents a bit of a problem because it
breaks the &amp;quot;all in one place&amp;quot; principle of a WEB project. I have a
WEB source file with the visible content plus one or more templates
with invisible content.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What I like about this is an attempt to reduce some of the cruftiness of
the various tools.&lt;/p&gt;
&lt;p&gt;I think my py-web-tool might be expanded to handle my expanded
understanding of literate programming.&lt;/p&gt;
&lt;p&gt;I have a book to finish, first, though. Then I can look at improving my
workflow. (And yes, this is backwards from a properly Agile approach.)&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="packtpub"></category><category term="#python"></category></entry><entry><title>PyLit-3 Maintenance, Love and Care</title><link href="https://slott56.github.io/2019_04_09-pylit_3_maintenance_love_and_care.html" rel="alternate"></link><published>2019-04-09T08:00:00-04:00</published><updated>2019-04-09T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2019-04-09:/2019_04_09-pylit_3_maintenance_love_and_care.html</id><summary type="html">&lt;p&gt;The PyLit tool dates from 2009. Here's a historical
reference: &lt;a class="reference external" href="http://wiki.c2.com/?PyLit"&gt;http://wiki.c2.com/?PyLit&lt;/a&gt;
It was Python 2. It had some minor problems. I forked it and cleaned it
up for Python 3.
Then I set it aside for a few years (six or so.)
Dusting it off. Rearranging …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The PyLit tool dates from 2009. Here's a historical
reference: &lt;a class="reference external" href="http://wiki.c2.com/?PyLit"&gt;http://wiki.c2.com/?PyLit&lt;/a&gt;
It was Python 2. It had some minor problems. I forked it and cleaned it
up for Python 3.
Then I set it aside for a few years (six or so.)
Dusting it off. Rearranging things. The legacy Python 2 version -- it
appears -- is gone forever.
The current thing available in PyPI doesn't even download and install on
a modern Python because the metadata makes it look like it won't be
compatible with a Python 3.7 world. So. That needs to be fixed. And
while I'm at it...
- Add tox support for Python 3.5, 3.6, and 3.7 properly.
- Restructure the docs to use Github Pages from master/docs.
- Get the download squared away so pip install will work.
- Use pathlib.
- Start down the road toward type hinting. Which will likely exclude
py35 support.
I may, as part of type hinting, be forced to make some more changes to
the essential structure of the app(s).
For now, I simply need to get it to be pip installable.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="hey-steven-is-there-any-public-repo-to-see-your-a"&gt;
&lt;h2&gt;Hey Steven! Is there any public repo to see your a...&lt;/h2&gt;
&lt;p&gt;David&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2019-05-08 03:14:39.349000-04:00&lt;/p&gt;
&lt;p&gt;Hey Steven! Is there any public repo to see your advances? Congrats for
your blog/books/initiatives!!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="thanks-for-this-relevant-information-i-will-also"&gt;
&lt;h2&gt;Thanks for this relevant information. I will also ...&lt;/h2&gt;
&lt;p&gt;John Martin&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2019-05-10 07:36:48.884000-04:00&lt;/p&gt;
&lt;p&gt;Thanks for this relevant information. I will also share information
where you can find good info about &lt;a class="reference external" href="https://jiwebtech.com"&gt;online software solutions
company&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-economic-landscape-of-today-is-not-only-demand"&gt;
&lt;h2&gt;The economic landscape of today is not only demand...&lt;/h2&gt;
&lt;p&gt;Asset Finance And Leasing&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2019-05-29 23:33:57.483000-04:00&lt;/p&gt;
&lt;p&gt;The economic landscape of today is not only demanding but it also comes
with a lot of pressure.
Businesses are starting to see that they need to do something different
and unique if they want to make an impact and grow.
&lt;a class="reference external" href="https://netsoltech.com/"&gt;Asset Finance And Leasing&lt;/a&gt; is a great way
for any company to grow.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="crystal-water-is-georgia-pools-builders-company-wi"&gt;
&lt;h2&gt;Crystal water is Georgia pools builders company wi...&lt;/h2&gt;
&lt;p&gt;Swimming Pool Contractors&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2019-09-02 06:39:09.289000-04:00&lt;/p&gt;
&lt;p&gt;Crystal water is Georgia pools builders company with budget friendly
customs solutions based in atlanta swimming
&lt;a class="reference external" href="https://www.crystalwaterpools.com/"&gt;pool contractors near me&lt;/a&gt;
creative design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="hello-steven-is-there-any-public-repo-to-see-your"&gt;
&lt;h2&gt;Hello Steven! Is there any public repo to see your...&lt;/h2&gt;
&lt;p&gt;contentrist.blog&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2021-07-27 13:16:11.239000-04:00&lt;/p&gt;
&lt;p&gt;Hello Steven! Is there any public repo to see your advances? Congrats
for your blog/books/initiatives!!
Also visit my Blog &lt;a class="reference external" href="https://contenterist.com/what-is-the-most-important-thing-to-remember-about-steering-a-pwc/"&gt;What is the Most Important thing to Remember about
Steering a
PWC?&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="PyLit"></category><category term="#python"></category></entry><entry><title>The SourceForge vs. GitHub Conundrum</title><link href="https://slott56.github.io/2018_10_30-the_sourceforge_vs_github_conundrum.html" rel="alternate"></link><published>2018-10-30T08:00:00-04:00</published><updated>2018-10-30T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2018-10-30:/2018_10_30-the_sourceforge_vs_github_conundrum.html</id><summary type="html">&lt;p&gt;Or &amp;quot;When is it time to move?&amp;quot;&lt;/p&gt;
&lt;p&gt;I've got &lt;a class="reference external" href="https://sourceforge.net/projects/stingrayreader/"&gt;https://sourceforge.net/projects/stingrayreader/&lt;/a&gt; which has
been on SourceForge since forever.&lt;/p&gt;
&lt;p&gt;Really since about 2014. Not that long. But. Maybe long enough?&lt;/p&gt;
&lt;p&gt;The velocity of change is relatively slow.&lt;/p&gt;
&lt;p&gt;However.&lt;/p&gt;
&lt;p&gt;(And this is a big however.) SourceForge seems kind of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Or &amp;quot;When is it time to move?&amp;quot;&lt;/p&gt;
&lt;p&gt;I've got &lt;a class="reference external" href="https://sourceforge.net/projects/stingrayreader/"&gt;https://sourceforge.net/projects/stingrayreader/&lt;/a&gt; which has
been on SourceForge since forever.&lt;/p&gt;
&lt;p&gt;Really since about 2014. Not that long. But. Maybe long enough?&lt;/p&gt;
&lt;p&gt;The velocity of change is relatively slow.&lt;/p&gt;
&lt;p&gt;However.&lt;/p&gt;
&lt;p&gt;(And this is a big however.) SourceForge seems kind of complicated
when compared with Github.&lt;/p&gt;
&lt;p&gt;It's not a completely fair comparison. SourceForge has a *lot* of
features. I don't use very many of those features.&lt;/p&gt;
&lt;p&gt;The troubling issues are these.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Documentation.
SourceForge -- while it has a Git interface --
doesn't handle my documentation very well. Instead of a docs
directory, I do a separate upload of the HTML. It's inelegant.
SourceForge may handle this more smoothly nowadays. Or maybe I should
switch to readthedocs?&lt;/li&gt;
&lt;li&gt;The Literate Programming Workflow.
There's an extra step (or two)
in LP workflows. The PyLit3 synchronization to create the working
Python from the RST source. This is followed by the ubiquitous steps
creation of a release, creation of a distribution, and the upload to
PyPI. I don't have an elegant handle on this because my velocity of
change is so low. SourceForge imposed a &amp;quot;make your own ZIP file&amp;quot;
mentality that could be replaced by a nicer &amp;quot;use PyPI&amp;quot; approach.&lt;/li&gt;
&lt;li&gt;Clunky Design Issue.
I've uncovered a clunky, stateful design
problem in the StingrayReader. I really really really need to fix it.
And while fixing it, why not move to Github?&lt;/li&gt;
&lt;li&gt;Compatibility Testing.
The StingrayReader seems to work with
Python 3.5 and up. I don't have a formal Tox suite. I think it works
with a number of versions of XLRD. And it *should* be amenable to
other tools for Excel processing. Not sure. And (until I start using
tox) can't tell.&lt;/li&gt;
&lt;li&gt;Type Hints.
See #3. The stateful design problem can be finessed
into a much more elegant use of NamedTuples. And then mypy can be
used.&lt;/li&gt;
&lt;li&gt;Unit Tests.
Currently, the testing is all unittest.TestCase. I
really want to convert to pytest and simplify all of it.&lt;/li&gt;
&lt;li&gt;Lack of a proper workflow in the first place.
See #2. It's a
more-or-less sitting in the master branch of a git repo that's part
of SourceForge. That's kind of shabby.&lt;/li&gt;
&lt;li&gt;Version Numbering Vagueness.
When I was building my own Zip
archives from the code manually (because that's the way SourceForge
worked.) I wasn't super careful about semantic versioning, and I've
been release patch-number versions for a while. Which is wrong. A few
of those versions included new features. Minor, but features.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But. One tiny new feature. So. It will be release 4.5.
See &lt;a class="reference external" href="https://sourceforge.net/p/stingrayreader/blog/2018/10/moving-to-github/"&gt;https://sourceforge.net/p/stingrayreader/blog/2018/10/moving-to-github/&lt;/a&gt;
for status, also&lt;/p&gt;
</content><category term="Literate Programming"></category><category term="open source"></category><category term="stingray reader"></category><category term="github"></category><category term="source forge"></category></entry><entry><title>Literate Programming Life Cycle</title><link href="https://slott56.github.io/2017_05_13-literate_programming_life_cycle.html" rel="alternate"></link><published>2017-05-13T10:11:00-04:00</published><updated>2017-05-13T10:11:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2017-05-13:/2017_05_13-literate_programming_life_cycle.html</id><summary type="html">&lt;p&gt;The question is a deep one. What is the Literate Programming Life
Cycle? Why is it so difficult? What are the three barriers and how do
we cross them?&lt;/p&gt;
&lt;p&gt;Here's most of the original question.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Last week I threw together an F# script to parse markdown-style
text into one or …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;The question is a deep one. What is the Literate Programming Life
Cycle? Why is it so difficult? What are the three barriers and how do
we cross them?&lt;/p&gt;
&lt;p&gt;Here's most of the original question.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Last week I threw together an F# script to parse markdown-style
text into one or more F# files.&lt;/p&gt;
&lt;p&gt;&amp;quot;The thing is, nearly all the references I can find online talk
about the finished article, but not the design process. Obviously
for my first attempt, I necessarily had to start out by writing
the F#, then writing the document with embedded code afterwards.
But now I’ve got that working, I have difficulty working out how
the ongoing development process actually works. Currently only
having a text editor with no colour coding, then having to
‘compile’ my markdown to code, then compile my code to test it,
all seems like too much hard work, and the temptation is just hack
the code directly.&lt;/p&gt;
&lt;p&gt;&amp;quot;Given that I imagine the python development process is similar to
F#, I wondered what your experience is with the hack/test/finalise
development cycle.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="some-background"&gt;
&lt;h2&gt;Some Background&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.tug.org/TUGboat/Articles/tb13-3/childs.pdf"&gt;http://www.tug.org/TUGboat/Articles/tb13-3/childs.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Also, this quote from the discussion on &lt;a class="reference external" href="http://lambda-the-ultimate.org/node/3663#comment-51878"&gt;Lambda the
Ulimate&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;The issue of literate programming is an issue of writing a
program
that LIVES rather than writing a program that WORKS. In a
commercial
setting you pay to train new people on programs but in an open
source setting there is no training. ...&amp;quot;&lt;/p&gt;
&lt;p&gt;&amp;quot;... But if your program needs to live forever then you
really need literate code.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently, I did some major overhauls of two literate programming
exercises. I revised the &lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;pyWeb
tool&lt;/a&gt; to better handle LaTeX
output, as well as add unit tests and -- consequently -- fix some
long-standing problems. Also, I revised the &lt;a class="reference external" href="http://cobol-dde.sourceforge.net/"&gt;COBOL
DDE&lt;/a&gt; parser to better handle
numeric data, replace the old FixedPoint module with Decimal, add
unit tests and -- of course -- fix other bugs that showed up.&lt;/p&gt;
&lt;p&gt;Based on my recent experience, I have some advice on &amp;quot;Full
Life-Cycle Literate Programming&amp;quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-life-cycle"&gt;
&lt;h2&gt;A Life Cycle&lt;/h2&gt;
&lt;p&gt;In order to identify the barriers, we need to look at the
deliverables and the software development life cycle that produces
those deliverables. Let's break the software development
life-cycle down as follows.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;New Development&lt;/li&gt;
&lt;li&gt;Maintenance&lt;/li&gt;
&lt;li&gt;Adaptation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll presume that each of these efforts includes some elaboration
of requirements, some design, and some transition to operational
use. We only care about the coding part of the job, so we're not
going to dwell on all of the other activities that are part of
Application Life Cycle Management.&lt;/p&gt;
&lt;p&gt;The question is about that transition from New Development to
Maintenance or Adaptation. Doing new development seems somehow
easier than maintenance or adaptation. How do we work with an
established Literate Program?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="new-development"&gt;
&lt;h2&gt;New Development&lt;/h2&gt;
&lt;p&gt;New Development of a program is always a delicate subject. We have
an explicit goal of creating some deliverable. We'll look at the
deliverables next. First, we'll look at the conflicting forces
that must be balanced.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;It must satisfy the need. There are requirements for the
program's behavior, interfaces and implementation. Above all it
must work.&lt;/li&gt;
&lt;li&gt;It must use appropriate resources. The data structures and
algorithms must reflect sensible engineering choices. There's
no call for &amp;quot;micro-optimization&amp;quot; of each silly piece of syntax.
However, the algorithm's (and data structures) should be
minimized.&lt;/li&gt;
&lt;li&gt;It must be adaptable.&lt;/li&gt;
&lt;li&gt;It must be maintainable.&lt;/li&gt;
&lt;li&gt;It must meet other organizational needs like cost,
time-to-develop, language and toolset, infrastructure
requirements, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One can maximize one at the expense of others. For instance, one
can reduce development costs to the minimum by creating a mess
that's neither adaptable nor maintainable. Indeed, one can create
software very cheaply if one starts relaxing functional
requirements. Software that doesn't work well can be very cheap to
create.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="forward-vs-reverse-literate-programming"&gt;
&lt;h2&gt;Forward vs. Reverse Literate Programming&lt;/h2&gt;
&lt;p&gt;As a digression, we'll note that some folks recognize two broad
approaches to literate programming (LP). This isn't the whole
story, however. Ordinary LP encourages the author to create a
document that contains and explains working software. A simple
tool extracts a nice final publication-ready document and working
code from the author's original source document.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.ssw.uni-linz.ac.at/Research/Projects/RevLitProg/"&gt;Reverse LP&lt;/a&gt;
is the technique used by tools like JavaDoc, Sphinx, Epydoc,
DOxygen. This usually takes the form of detailed API
documentation, but it can be richer than simply the API's. In this
case, comments in the source code are extracted to create the
final publication-ready document. In Sphinx the author uses a
mixture of source code plus external text to create final
documentation. This isn't as interesting, since the resulting
document can't easily contain the entire source.&lt;/p&gt;
&lt;p&gt;We can assign the retronym &amp;quot;Forward Literate Programming&amp;quot; to
ordinary LP to distinguish it from Reverse LP.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="code-first-literate-programming"&gt;
&lt;h2&gt;Code-First Literate Programming&lt;/h2&gt;
&lt;p&gt;There's an apparent distinction between two variations on the
Forward LP theme: Document-First and Code-First LP. In
Document-First, we aspire to a noble ideal of writing the document
and the code from first principles, from scratch, &amp;quot;&lt;em&gt;de novo&lt;/em&gt;&amp;quot;,
starting with a blank page. The code-first approach, on the other
hand, refactors working code is into a literate programming
document.&lt;/p&gt;
&lt;p&gt;One can argue that code-first refactoring is A Bad Thing™ and
subverts the intent of literate programming. The argument is that
one should think the program through carefully, and the resulting
document should be a tidy explanation of the development of the
ideas leading to the working software.&lt;/p&gt;
&lt;p&gt;However, Knuth's analysis of &amp;quot;The original Crowther/Woods
Adventure game, Version 1.0, translated into CWEB form&amp;quot; (at
&lt;a class="reference external" href="http://www-cs-faculty.stanford.edu/~uno/programs/advent.w.gz"&gt;ADVENT&lt;/a&gt;)
shows that even ancient Fortran code can be carefully analyzed and
retro-actively transformed into a piece of literature.&lt;/p&gt;
&lt;p&gt;Working forward -- starting with a blank sheet of paper -- isn't
always the best approach. The bad ideas and dead-ends don't belong
in that explanation. All of the erasing and rewriting should be
left out of the LP document. This means that the document should
really focus on the final, working, completed code. Not the
process of arriving at the code. Why start with a blank page? Why
not start with the code?&lt;/p&gt;
&lt;p&gt;In short, code-first LP isn't &lt;em&gt;wrong&lt;/em&gt;. Indeed, it isn't even a
useful distinction. If the resulting document (a) contains the
entire source and (b) stands as piece of well-written description,
then the literate programming mandate has been satisfied.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="center-of-balance"&gt;
&lt;h2&gt;Center of Balance&lt;/h2&gt;
&lt;p&gt;Literate Programming strikes a balance among the various
development forces. It emphasizes working software with abundant
documentation. It does not emphasize the short-term cost to
develop. It does, however, emphasize the long-term value that's
created.&lt;/p&gt;
&lt;p&gt;Interestingly, the idea is to minimize the labor involved in
creating and maintaining this documentation. To some folks, it
seems odd that all that writing would somehow be &amp;quot;minimal&amp;quot;.
Consider the alternative, however.&lt;/p&gt;
&lt;p&gt;We can try to create software and documentation &lt;em&gt;separately&lt;/em&gt;,
claiming it's somehow easier. First, we write the software, since
that's the only deliverable that matters. Second, we slap on some
extra documentation, since only the software really matters. While
satisfying in some respects, most folks find -- in the long run --
that this is unworkable. They often diverge.&lt;/p&gt;
&lt;p&gt;When the code and the comments disagree, probably both are
wrong.
-----------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;The goal of LP is to prevent this.&lt;/p&gt;
&lt;p&gt;Literate Programming seems like a lot of work. But it's work we
have to do anyway. And a non-literate approach is simply &lt;em&gt;more&lt;/em&gt;
work. Almost any approach that seems to create software &amp;quot;quickly&amp;quot;
doesn't create any enduring value. Why not?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-deliverables"&gt;
&lt;h2&gt;The Deliverables&lt;/h2&gt;
&lt;p&gt;The point of &lt;strong&gt;all&lt;/strong&gt; software development is to create a two-part
deliverable.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The working software&lt;/li&gt;
&lt;li&gt;Some supporting justification or reason for trusting the software&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The justification can take several forms: test results, formal
proof, API Documentation (&amp;quot;Reverse Literate Programming&amp;quot;), an
explanation (separate from the code) or a Literate Programming
document.&lt;/p&gt;
&lt;p&gt;In many cases, our customers want most of the above. Folks
don't expect a formal proof, but they often demand everything
else.&lt;/p&gt;
&lt;p&gt;Claiming that the software can exist &lt;em&gt;without the supporting
justification&lt;/em&gt; is to reduce software development to a hobby.
The worst-run of amateur software development organizations do
tolerate a piece of software without a single test or scrap of
documentation. That only proves the point: if your organization
tolerates junk software without supporting documentation, it's
one of the worst-run of organizations; feel free to quit.&lt;/p&gt;
&lt;p&gt;The point of LP is to create the software (and supporting
documents) from a single LP source document. LP seeks to
&lt;em&gt;minimize&lt;/em&gt; the effort required to create software with
supporting documentation that actually matches the software.&lt;/p&gt;
&lt;p&gt;I'll emphasize that.&lt;/p&gt;
&lt;p&gt;Literate Programming seeks to minimize the effort required to
create software with supporting documentation
-----------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;If we have to produce software, tests and explanations, clearly
it is simpler to have a single source file which emits all of
that stuff in a coherent, easy-to-follow format. While it's
clearly simpler, there are some barriers to be overcome.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="if-it-s-so-much-easier"&gt;
&lt;h2&gt;If It's So Much Easier... ?&lt;/h2&gt;
&lt;p&gt;The Jon Bentley issue with LP is that it doesn't feel easier to
write a coherent document because we aren't all good writers.
Bentley notes that there are good writers and good programmers
and that some folks are not members of both sets. I think this
misses the point. We're going to produce documentation, no
matter how good a writer we are.&lt;/p&gt;
&lt;p&gt;Most people do not see LP as simpler. They see it as a lot of
work. Weirdly, it's work they already do, but they choose to
keep the program and the explanation separate from each other,
making it &lt;em&gt;more&lt;/em&gt; work to keep them in synch. I can see why they
claim it's more work.&lt;/p&gt;
&lt;p&gt;If it's easier to do this in one document, why doesn't everyone
simply create a literate program?&lt;/p&gt;
&lt;p&gt;Generally, we've got three kinds of barriers that make Literate
Programming hard. First, the tools at our disposal don't really
support an LP kind of development effort. We get very used to
intelligent syntax coloring and code folding. We find tools
which lack these features to be harder to use. Second, we're
working in multiple languages in a single document. Finally, it
takes some experience to get settled into an LP mode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-tool-barrier"&gt;
&lt;h2&gt;The Tool Barrier&lt;/h2&gt;
&lt;p&gt;The first of the barriers to effective literate programming is
the tool pipeline. The complaint is that &amp;quot;having to ‘compile’
my markdown to code, then compile my code to test it, all seems
like too much hard work&amp;quot;.&lt;/p&gt;
&lt;p&gt;This is interesting, but specious. The multi-step process is
what &lt;a class="reference external" href="http://www.scons.org/"&gt;scons&lt;/a&gt;, make,
&lt;a class="reference external" href="http://ant.apache.org/"&gt;ant&lt;/a&gt; and
&lt;a class="reference external" href="http://maven.apache.org/"&gt;maven&lt;/a&gt; are for. A simple
SConstruct file will handle web, weave, publication,
compilation and unit test in a single smooth motion.&lt;/p&gt;
&lt;p&gt;There are a lot of tools involved in literate programming.
We've introduced an additional markup language into the mix,
creating additional steps. This isn't any more complex than
working with any compiled language. We often forget that the C
compiler is really a multi-stage pipeline. Our LP tools --
similarly -- are multi-stage pipelines.&lt;/p&gt;
&lt;p&gt;Also, for Python and F# programmers, there's something else
that Seems Very Important™. It isn't. F# and Python have
console interfaces (sometimes called the Read Evaluate Print
Loop, REPL); this clutters up the problem with an irrelevant
detail. Console hacking is helpful, but it isn't literate and
it's barely programming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-language-barrier"&gt;
&lt;h2&gt;The Language Barrier&lt;/h2&gt;
&lt;p&gt;In addition the tool barrier, we also have a language barrier.
When we're doing literate programming we're working in at least
three different languages concurrently. This makes our life
seem difficult.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Literate Programming Markup&lt;/strong&gt;. This might be CWEB, pyWeb
or any of a number of LP markup systems.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target Document Markup&lt;/strong&gt;. This might be LaTeX, RST,
Markdown, DocBook XML or some other markup.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target Programming Languages&lt;/strong&gt;. For classic, Knuth-style
projects, there's only a single language. However, for many
projects this will not be a single language. For example, in
a web environment, we'll have program source, SQL, HTML,
CSS, and possibly other languages thrown in.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It's difficult to sort this out from an IDE's perspective. How
to handle syntax highlighting and code coloring? How to handle
code folding and indexing the document as presented?&lt;/p&gt;
&lt;p&gt;The old-school techniques of decomposing a big document into
small sections still applies to literate programming. The
document sections do not in any way correspond with the final
program source, making the LP document tree far, far easier to
work with.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-mental-barrier"&gt;
&lt;h2&gt;The Mental Barrier&lt;/h2&gt;
&lt;p&gt;The final barrier is entirely mental. This is really one of
experience and expectation.&lt;/p&gt;
&lt;p&gt;It's hard -- really hard -- to step back from the code and ask
&amp;quot;What's this &lt;em&gt;mean&lt;/em&gt;?&amp;quot; and &amp;quot;How would I explain it?&amp;quot;&lt;/p&gt;
&lt;p&gt;Too often, we see a problem, we know the code, and we
understand the fix -- as code. This is a skill as well as a
habit we build up. It's not the best habit because the meaning
and explanatory power can be ignored or misplaced.&lt;/p&gt;
&lt;p&gt;Stepping back from the code seems slow. &amp;quot;It's a one-line change
with a 10-paragraph explanation!&amp;quot; developers gripe. &amp;quot;I could
make the change now or spend hours explaining the change to
you. The value is in making the change and putting it into
production.&amp;quot;&lt;/p&gt;
&lt;p&gt;And that's potentially wrong.&lt;/p&gt;
&lt;p&gt;Only a very small part of the a developer's value is the code
change itself. If code will be in production for decades (my
personal best is 17 years in production) then the 10-paragraph
explanation will -- over the life of the software -- be worth
it's weight in gold. A one line fix may actually be a
liability, not an asset.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="solid-approach"&gt;
&lt;h2&gt;Solid Approach&lt;/h2&gt;
&lt;p&gt;I think the approach has to be the following.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Create a Spike Solution. Something that works, is
incomplete, but shows the core approach, algorithms and data
structures.&lt;/li&gt;
&lt;li&gt;Outline the next more complete solution using LP tools. The
component structure, the logical model, the basics of the
first sprint.&lt;/li&gt;
&lt;li&gt;Create a &lt;strong&gt;publication pipeline&lt;/strong&gt; to process the LP source
into document, code and tests, and run the test suite. A
kind of the Continuous Integration daily build. This is
easily a double-clickable script, or &amp;quot;tool&amp;quot; in an IDE.&lt;/li&gt;
&lt;li&gt;Fill in the code, the unit tests, and the necessary
packaging and release stuff. Follow TDD practices, writing
unit tests and code in that order. What's cool is being able
to write about them side-by-side, even though the unit tests
are kept separate from the deliverable code in the build
area.&lt;/li&gt;
&lt;li&gt;Review the final document for it's explanatory power.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Consider a number of things we do in comments that are
better done outside the comments.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;TODO lists. We often write special TODO comments. These
can go in the proper Literate Programming text, not in
the code.&lt;/li&gt;
&lt;li&gt;Code samples. In JavaDocs, particularly, sample code
isn't fun because of the volume of markup required. LP
code samples are just more code; you can make them part
of small &amp;quot;demo&amp;quot; or &amp;quot;test&amp;quot; structures that actually
compile and are actually tested. Why not?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consider a number of things we don't often do well.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Background on an algorithm or data structure.
Footnotes, links, etc., are often slightly easier to
write in word-processing markup than comments in the
code.&lt;/li&gt;
&lt;li&gt;Performance information on the choice of a data
structure. Merely claiming that a HashMap is faster
isn't quite as compelling as running timeit and
including the results.&lt;/li&gt;
&lt;li&gt;Binding unit tests and code side-by-side. Current
practice keeps the unit tests well separated from
code. (Django framework models are a pleasant
exception.) What could be nicer than a method followed
by unit tests that show hot it works? You may write
the tests first, but the code-first explanation is
sometimes nicer than the test-first development.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I think that LP isn't all that hard, but we have three
barriers to overcome. We don't have exceptional tools.
We have a complex welter of languages. And we have bad
habits to break and transform into new habits.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-links"&gt;
&lt;h2&gt;Some Links&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www-cs-faculty.stanford.edu/~uno/programs.html"&gt;http://www-cs-faculty.stanford.edu/~uno/programs.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://tex.loria.fr/english/litte.html"&gt;http://tex.loria.fr/english/litte.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lambda-the-ultimate.org/node/3663"&gt;http://lambda-the-ultimate.org/node/3663&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://c2.com/cgi/wiki?LiterateProgramming"&gt;http://c2.com/cgi/wiki?LiterateProgramming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://vasc.ri.cmu.edu/old_help/Programming/Literate/literate.html"&gt;http://vasc.ri.cmu.edu/old_help/Programming/Literate/literate.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.desy.de/user/projects/LitProg.html"&gt;http://www.desy.de/user/projects/LitProg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://infohost.nmt.edu/~shipman/soft/litprog/"&gt;http://infohost.nmt.edu/~shipman/soft/litprog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.vivtek.com/litprog.html"&gt;http://www.vivtek.com/litprog.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.literateprogramming.com/"&gt;http://www.literateprogramming.com/&lt;/a&gt; - Good stuff, but not
a real wiki or forum site.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.squidoo.com/literateprogramming"&gt;http://www.squidoo.com/literateprogramming&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="some-tools"&gt;
&lt;h2&gt;Some Tools&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://en.literateprograms.org/LiteratePrograms:Welcome"&gt;http://en.literateprograms.org/LiteratePrograms:Welcome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://nuweb.sourceforge.net/"&gt;http://nuweb.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://pylit.berlios.de/literate-programming.html"&gt;http://pylit.berlios.de/literate-programming.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://webpages.charter.net/edreamleo/design.html"&gt;http://webpages.charter.net/edreamleo/design.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;http://pywebtool.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="nice-simple-blog-layout-i-will-click-through-on-y"&gt;
&lt;h2&gt;Nice simple blog layout. I will click through on y...&lt;/h2&gt;
&lt;p&gt;Maintenance Man&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-03-29 18:12:17.998000-04:00&lt;/p&gt;
&lt;p&gt;Nice simple blog layout. I will click through on your AdSense.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="you-might-want-to-have-a-look-at-the-leo-programme"&gt;
&lt;h2&gt;You might want to have a look at the LEO programme...&lt;/h2&gt;
&lt;p&gt;Michael&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-03-29 18:10:26.404000-04:00&lt;/p&gt;
&lt;p&gt;You might want to have a look at the LEO programmer's editor
&lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;http://webpages.charter.net/edreamleo/front.html&lt;/a&gt; which is written in
Python and supports literate programming. It can be used to import
existing code in order to either document it, or to continue development
in a literate manner. The author has also written a bit about how he
uses LEO features in a very practical exposition of literate
programming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nice-outline-of-a-lp-lifecycle-i-ll-try-to-us"&gt;
&lt;h2&gt;Nice outline of a LP lifecycle. I'll try to us...&lt;/h2&gt;
&lt;p&gt;Ryan&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-04-12 18:43:40.819000-04:00&lt;/p&gt;
&lt;p&gt;Nice outline of a LP lifecycle. I'll try to use that on my next LP
project (a procedurally generated text adventure).
I was personally planning on using Sphinx with it's ability to include
external *.py files.&lt;/p&gt;
&lt;p&gt;The *.py files and *.rst files would have cross references that could
be moved between with a vim macro (that's the hope, at least).
I guess the approach I'm trying to take is a bit closer to Elucidative
Programming
[&lt;a class="reference external" href="http://www.cs.aau.dk/~normark/elucidative-programming/index.html"&gt;http://www.cs.aau.dk/~normark/elucidative-programming/index.html&lt;/a&gt;]
rather than pure Literate Programming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="very-detailed-and-serious-article-i-m-absolut"&gt;
&lt;h2&gt;Very detailed and serious article, I'm absolut...&lt;/h2&gt;
&lt;p&gt;Anonymous&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2013-02-14 11:22:38.368000-05:00&lt;/p&gt;
&lt;p&gt;Very detailed and serious article, I'm absolutely agree with author with
his thesises (please, exuse my English). Itried different tools (PyWeb
too), wrote 3, and now I'm developing NanoLP tool, for me it's syntax
and approach is the best (no language barrier, supports many formats
(Asciidoc, reStructuredText, TeX, HTML, XML and other) includes
OpenOffice/LibreOffice, so it can be use in WYSIWYG manner,&lt;/p&gt;
&lt;p&gt;collaborative usage - with LP libraries support, publishing on Web), and
as main for me - very light syntax, so LP program is very readable, no
weird syntax as it's usual for CWEB or other tools. It's project page
is: &lt;a class="reference external" href="http://code.google.com/p/nano-lp/"&gt;http://code.google.com/p/nano-lp/&lt;/a&gt; (me is author).&lt;/p&gt;
&lt;p&gt;What LP missed? We can compare LP tools with the best but opposite tool&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Doxygen. Doxygen is good due to its 'smart'&lt;/li&gt;
&lt;li&gt;Doxygen creates structured, classified &amp;quot;guide&amp;quot; of input sources, something like &amp;quot;map&amp;quot;
for navigation of code. So, LP can not help us to navigate (like in IDE,
or Source Navigator) in code, it looks like 2 different dimensions of
one, the same cube :) And attempts to summarize both in one text will be
terrible (for user).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="F#"></category></entry><entry><title>Functional Python, Literate Programming &amp; Trello Board Analysis</title><link href="https://slott56.github.io/2017_05_02-functional_python_literate_programming_trello_board_analysis.html" rel="alternate"></link><published>2017-05-02T08:00:00-04:00</published><updated>2017-05-02T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2017-05-02:/2017_05_02-functional_python_literate_programming_trello_board_analysis.html</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;The general advice to people using Kanban/Agile Project boards of
various kinds is this:&lt;/div&gt;
&lt;div class="line"&gt;&lt;strong&gt;Stop Starting -- Start Finishing&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.agilebuddha.com/agile/agile-thinking-stop-starting-start-finishing/"&gt;http://www.agilebuddha.com/agile/agile-thinking-stop-starting-start-finishing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.allaboutagile.com/stop-starting-start-finishing-unfinished-work-is-debt/"&gt;http://www.allaboutagile.com/stop-starting-start-finishing-unfinished-work-is-debt/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.leanagiletraining.com/key-problems/stop-starting-start-finishing/"&gt;http://www.leanagiletraining.com/key-problems/stop-starting-start-finishing/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div class="line"&gt;&lt;em&gt;etc&lt;/em&gt;.&lt;/div&gt;
&lt;div class="line"&gt;There's a lot of this advice. Some of it is helpful.&lt;/div&gt;
&lt;div class="line"&gt;Many tools …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;The general advice to people using Kanban/Agile Project boards of
various kinds is this:&lt;/div&gt;
&lt;div class="line"&gt;&lt;strong&gt;Stop Starting -- Start Finishing&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.agilebuddha.com/agile/agile-thinking-stop-starting-start-finishing/"&gt;http://www.agilebuddha.com/agile/agile-thinking-stop-starting-start-finishing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.allaboutagile.com/stop-starting-start-finishing-unfinished-work-is-debt/"&gt;http://www.allaboutagile.com/stop-starting-start-finishing-unfinished-work-is-debt/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.leanagiletraining.com/key-problems/stop-starting-start-finishing/"&gt;http://www.leanagiletraining.com/key-problems/stop-starting-start-finishing/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div class="line"&gt;&lt;em&gt;etc&lt;/em&gt;.&lt;/div&gt;
&lt;div class="line"&gt;There's a lot of this advice. Some of it is helpful.&lt;/div&gt;
&lt;div class="line"&gt;Many tools have various dashboards and metrics computations.&lt;/div&gt;
&lt;div class="line"&gt;However.&lt;/div&gt;
&lt;div class="line"&gt;The basic velocity calculations -- starts v. finishes -- is pretty
straight-forward. The rules to classify a Trello action as &amp;quot;start&amp;quot; or
&amp;quot;finish&amp;quot; are actually nice examples of simple functions or lambdas.
Which also means that the basic pipeline required to gather the data
can be written as a lazy, functional process.&lt;/div&gt;
&lt;div class="line"&gt;Which leads to writing a Literate Programming version of a small
program that gathers data from a Trello board.&lt;/div&gt;
&lt;div class="line"&gt;&lt;a class="reference external" href="https://github.com/slott56/Trello-Action-Counts"&gt;https://github.com/slott56/Trello-Action-Counts&lt;/a&gt;&lt;/div&gt;
&lt;div class="line"&gt;It's a kind of deep-dive into some aspects of Python functional-style
programming. It's also a dive into Literate Programming via a longish
example. And it has a fair number of type hints. It's not perfectly
clean from MyPy-'s analysis. So there's some more to do on that front.&lt;/div&gt;
&lt;/div&gt;
</content><category term="Literate Programming"></category><category term="#python"></category><category term="functional python programming"></category></entry><entry><title>Writing About Code -- Or -- Why I love RST</title><link href="https://slott56.github.io/2015_12_15-writing_about_code_or_why_i_love_rst.html" rel="alternate"></link><published>2015-12-15T08:00:00-05:00</published><updated>2015-12-15T08:00:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2015-12-15:/2015_12_15-writing_about_code_or_why_i_love_rst.html</id><summary type="html">&lt;p&gt;I blog. I write books. I write code. There are profound tool-chain
issues in all three of these. Mostly, I'm tired of shabby &amp;quot;What You
See Is All You Get&amp;quot; editing.&lt;/p&gt;
&lt;p&gt;First. I use this blogger site as well as a
&lt;a class="reference external" href="https://www.jivesoftware.com/"&gt;Jive-based&lt;/a&gt; site at work. They're
handy. But. There are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I blog. I write books. I write code. There are profound tool-chain
issues in all three of these. Mostly, I'm tired of shabby &amp;quot;What You
See Is All You Get&amp;quot; editing.&lt;/p&gt;
&lt;p&gt;First. I use this blogger site as well as a
&lt;a class="reference external" href="https://www.jivesoftware.com/"&gt;Jive-based&lt;/a&gt; site at work. They're
handy. But. There are a lot of issues. A lot. Web-based editing leaves
a lot to be desired.&lt;/p&gt;
&lt;p&gt;Second. Books. &lt;a class="reference external" href="https://www.packtpub.com/"&gt;Packt&lt;/a&gt; requires MS-Word
for drafts. The idea here is that authors, editors, and reviewers
should all use a single tool. I push the boundaries by using &lt;a class="reference external" href="https://www.libreoffice.org/"&gt;Libre
Office&lt;/a&gt; and &lt;a class="reference external" href="https://www.openoffice.org/"&gt;Open
Office&lt;/a&gt;. This works out most of the
time, since these tools will absorb the MS-office style sheet that
Packt uses. It doesn't work out well for typesetting math, but the
technical editors are good about tracking down the formulae when they
get lost in the conversions. These over-wrought do-too-much word
processing nightmares leave a lot to be desired.&lt;/p&gt;
&lt;p&gt;Third. Code. I use &lt;a class="reference external" href="http://komodoide.com/komodo-edit/"&gt;ActiveState Komodo
Edit&lt;/a&gt;.  Both at work and outside
of work. This rocks.&lt;/p&gt;
&lt;div class="section" id="web-based-editing-fail"&gt;
&lt;h2&gt;Web-Based Editing Fail&lt;/h2&gt;
&lt;p&gt;What's wrong with Jive or Blogger? The stark contrast between
JavaScript-based text edit tools and HTML. It's either too little
control or too much detail.&lt;/p&gt;
&lt;p&gt;The JS-based editors are fine for simple, running text. They're
actually kind of nice for that. Simple styles. Maybe a heading here or
there.&lt;/p&gt;
&lt;p&gt;Code? Ugh. Epic Fail.&lt;/p&gt;
&lt;p&gt;It gets worse.&lt;/p&gt;
&lt;p&gt;I've become a real fan of semantic markup.
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/DocBook"&gt;DocBook&lt;/a&gt; has a rich set of
constructs available.
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;RST&lt;/a&gt;, similarly, has a
short list of text roles that can be expanded to include the same kind
of rich markup as DocBook. &lt;a class="reference external" href="http://sphinx-doc.org/"&gt;Sphinx&lt;/a&gt;
leverages these roles to allow very sophisticated references to code
from text. &lt;a class="reference external" href="https://www.latex-project.org/"&gt;LaTeX&lt;/a&gt; has a great deal
of &lt;a class="reference external" href="http://www.informit.com/articles/article.aspx?p=675273"&gt;semantic
markup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Web-based editors lack any of this. We have HTML. We have HTML
&lt;a class="reference external" href="http://microformats.org/"&gt;microformats&lt;/a&gt; available. But. For a
JavaScript web editor, we're really asking for a lot. More than seems
possible for a quick download.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="desktop-tool-fail"&gt;
&lt;h2&gt;Desktop Tool Fail&lt;/h2&gt;
&lt;p&gt;What's wrong with desktop tools? We have very rich style sheets
available. We should be able to define a useful set of styles and
produce a useful document. Right?&lt;/p&gt;
&lt;p&gt;Sadly, it's not easy.&lt;/p&gt;
&lt;p&gt;First, the desktop tools are extremely tolerant of totally messed-up
markup. They're focus is explicitly on making it look acceptable. It
doesn't have to be well-structured. It just has to look good.&lt;/p&gt;
&lt;p&gt;Second, and more important, the file formats are almost utterly
opaque. Yes. There are standards now. Yes. It's all just XML. No. It's
still nearly impossible to process. Try it.&lt;/p&gt;
&lt;p&gt;Most word-processing documents feel like XML serializations of
in-memory data structures. It's possible to locate the relevant
document text in there somewhere. It's not like they're being
intentionally obscure. But they're obscure.&lt;/p&gt;
&lt;p&gt;Third, and most important, is the reliance on either complex GUI
gestures (pointing and clicking and what-not) or complex keyboard
&amp;quot;shortcuts&amp;quot; and stand-ins for GUI gestures. It might be possible to
use that row of F-keys to define some kinds of short-cuts that might
be helpful. But there's a lot of semantic markup and only a dozen
keys, some of which have common interpretations for help, copy, paste,
turn off the keyboard lights, play music, etc.&lt;/p&gt;
&lt;p&gt;The Literate Programming ideal is to have the words and the code
existing cheek by jowls. No big separation. No hyper-complex tooling.
To me, this means sensible pure-text in-line markup.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="text-markup"&gt;
&lt;h2&gt;Text Markup&lt;/h2&gt;
&lt;p&gt;I find that I really like RST markup. The more I write, the more I
like it.&lt;/p&gt;
&lt;p&gt;I really like the idea of writing code/documentation in a simple,
uniform code-centric tooling. The pure-text world using RST pure-text
markup is delightfully simple.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Write stuff. Words. Code. Whatever. Use RST markup to segregate
the formal language (e.g. Python) from the natural language (e.g.,
English in my case.)&lt;/li&gt;
&lt;li&gt;Click on some icon the right side of the screen (or maybe use an
F-key) to run the test suite.&lt;/li&gt;
&lt;li&gt;Click on some icon (or hit a key) to produce prettified HTML page
from
&lt;tt class="docutils literal"&gt;python3 &lt;span class="pre"&gt;-m&lt;/span&gt; pylit3 doc.py doc.rst; rst2html.py doc.rst doc.html&lt;/tt&gt;.
Having a simple toolchain to emit doc from code (or emit code from
doc) is a delight.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The genesis for this blog post was an at-work blog post (in Jive)
that had a code error in it. Because of Jive's code markup features
(using non-breaking spaces everywhere) there's no easy copy-and-paste
to check syntax. It's nearly impossible to get the code off the web
page in a form that's useful.&lt;/p&gt;
&lt;p&gt;If people can't copy-and-paste the code, the blog posts are
approximately worthless. Sigh.&lt;/p&gt;
&lt;p&gt;If I rewrite the whole thing into RST, I lose the Jive-friendly
markup. Now it looks out-of-place, but is technically correct.&lt;/p&gt;
&lt;p&gt;Either. Or.&lt;/p&gt;
&lt;p&gt;Exclusive Xor.&lt;/p&gt;
&lt;p&gt;Ugh. Does this mean I have to think about gathering the Jive .CSS
files, and create a version of those that's compatible with the
classes and ID's that Docutils uses?  I have some doubts about making
this work, since the classes and ID's might have overlaps that cause
problems.&lt;/p&gt;
&lt;p&gt;Or. Do I have to publish on some small web-server at work, and use
the &lt;tt class="docutils literal"&gt;&amp;lt;iframe&amp;gt;&lt;/tt&gt; tag to include RST-built content on the main
intranet? This probably works the best. But it leads to a multi-step
dance of writing, publishing on a private server, and then using a
iframe on the main intranet site. It seems needlessly complex.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="PyLit"></category></entry><entry><title>Navigation: Latitude, Longitude, Haversine, and all that</title><link href="https://slott56.github.io/2015_11_24-navigation_latitude_longitude_haversine_and_all_that.html" rel="alternate"></link><published>2015-11-24T08:00:00-05:00</published><updated>2015-11-24T08:00:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2015-11-24:/2015_11_24-navigation_latitude_longitude_haversine_and_all_that.html</id><summary type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;For a few years, I was a tech nomad. See &lt;a class="reference external" href="http://www.itmaybeahack.com/TeamRedCruising/"&gt;Team Red
Cruising&lt;/a&gt; for some
stories of life on a sailboat. Warning: it's pretty dull.&lt;/div&gt;
&lt;div class="line"&gt;As a tech nomad, I lived and died (literally) by my ability to
navigate. Modern GPS devices make the dying part relatively unlikely.
So, let's …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="line-block"&gt;
&lt;div class="line"&gt;For a few years, I was a tech nomad. See &lt;a class="reference external" href="http://www.itmaybeahack.com/TeamRedCruising/"&gt;Team Red
Cruising&lt;/a&gt; for some
stories of life on a sailboat. Warning: it's pretty dull.&lt;/div&gt;
&lt;div class="line"&gt;As a tech nomad, I lived and died (literally) by my ability to
navigate. Modern GPS devices make the dying part relatively unlikely.
So, let's not oversell the danger aspect of this.&lt;/div&gt;
&lt;div class="line"&gt;The prudent mariner plans a long voyage with a great deal of respect
for the many things which can go wrong. One aspect of this is to
create a &amp;quot;Float Plan&amp;quot;. Read more about it
here: &lt;a class="reference external" href="http://floatplancentral.cgaux.org/"&gt;http://floatplancentral.cgaux.org&lt;/a&gt;.&lt;/div&gt;
&lt;div class="line"&gt;The idea is to create a summary of the voyage, provide that summary to
trusted shore crew, and then check in periodically so that the shore
crew can confirm that you're making progress safely. Failure to check
in is an indicator of a problem, and action needs to be taken. We use
a &lt;a class="reference external" href="http://findmespot.com/en/"&gt;SPOT Messenger&lt;/a&gt; to check in at noon
(and sometimes at waypoints.)&lt;/div&gt;
&lt;div class="line"&gt;Creating a float plan involved an extract of the waypoints from our
navigation software (&lt;a class="reference external" href="http://www.gpsnavx.com/"&gt;GPS NavX&lt;/a&gt;). I would
enrich the list of waypoints with estimated travel time between the
points.  Folding in a departure time would lead to a schedule that
could be tracked. I also include some navigation hints in the form of
a bearing between waypoints so we know which way to steer to find the
next point.&lt;/div&gt;
&lt;div class="line"&gt;The travel time is the distance (in  nautical miles) coupled with an
assumption about speed (5 knots.) It's a really simple thing. But the
core &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Haversine_formula"&gt;haversine&lt;/a&gt;
calculation is not a first-class part of any spreadsheet app. Because
of the degrees-to-radians conversions required, and the common
practice of annotating degrees with a lot of internal punctuation
(38°54ʹ57″ 077°13ʹ36″), it becomes right awkward to simply implement
this as a spreadsheet.&lt;/div&gt;
&lt;div class="line"&gt;Some clever software has a good planning mode. The chartplotter on the
boat can do a respectable job of estimating time between waypoints.
But. It's not connected to a computer or the internet. So we can't
upload that information in the form of a float plan. The idea of
copying the data from the chart plotter to a spreadsheet is fraught
with errors.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="navtools"&gt;
&lt;h2&gt;Navtools&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Enter &lt;a class="reference external" href="https://github.com/slott56/navtools"&gt;navtools&lt;/a&gt;. This is a
library that I use to transform a route into a .csv with distances and
bearings that I can use to create a useful float plan. I can add an
estimated arrival time calculation so that a change to departure time
creates the entire check-in schedule.&lt;/div&gt;
&lt;div class="line"&gt;This isn't a sophisticated GUI app. It's just enough software to
transform a GPS NavX extract file into a more useful form. The GUI was
a spreadsheet (i.e., Numbers.) From this we created a PDF with the
details.&lt;/div&gt;
&lt;div class="line"&gt;Practically, we don't have good connectivity on the boat.  So we would
create a number of alternative plans (&amp;quot;leave tomorrow&amp;quot;, &amp;quot;leave the day
after&amp;quot;, &amp;quot;leave next Monday&amp;quot;, etc.) we would go ashore, find a coffee
shop, and email the various plans to ourselves. They could sit in our
inbox, waiting for weather and tide to be favorable.&lt;/div&gt;
&lt;div class="line"&gt;Then, when the weather and tides were finally aligned, we could
forward the relevant details to our trusted shore crew. This was a
quick spurt of cell phone connectivity to forward an email. It worked
out well. When the scheduled departure time arrived, we'd coax Mr.
Lehman to life, raise the anchor and away.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="literate-programming"&gt;
&lt;h2&gt;Literate Programming&lt;/h2&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;This is an exercise in literate programming. The code that's executed
and the HTML documentation are both derived from source ReStructured
Text (RST) documents. The documentation for the &lt;a class="reference external" href="http://slott56.github.io/navtools/navigation.html"&gt;navigation
module&lt;/a&gt; includes
the math along with the code that implements the math.&lt;/div&gt;
&lt;div class="line"&gt;I have to say that I'm enthralled with the intimate connection between
requirements, design, and implementation that literate programming
embodies.&lt;/div&gt;
&lt;div class="line"&gt;I'm excited to (finally) publish the thing to GitHub.
See &lt;a class="reference external" href="https://github.com/slott56/navtools"&gt;https://github.com/slott56/navtools&lt;/a&gt;.  I'm looking at some other
projects that require the navtools module. What I wind up doing is
copying and pasting the navigation calculation module into other
projects. I had something like three separate copies on my laptop. It
was time to fold all of the features together, delete the clones, and
focus on one authoritative copy going forward.&lt;/div&gt;
&lt;div class="line"&gt;I still have to remove some crufty old code. One step at a time.
First, get all the tests to pass. Then expunge the old code. Then make
progress on the other projects that leverage the navtools.navigation
module.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="longitude"></category><category term="#python"></category><category term="haversine"></category><category term="latitude"></category><category term="navigation"></category><category term="navtools"></category></entry><entry><title>Literate Programming and GitHub</title><link href="https://slott56.github.io/2015_06_23-literate_programming_and_github.html" rel="alternate"></link><published>2015-06-23T08:00:00-04:00</published><updated>2015-06-23T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2015-06-23:/2015_06_23-literate_programming_and_github.html</id><summary type="html">&lt;p&gt;I remain captivated by the ideals of &lt;a class="reference external" href="http://www.literateprogramming.com/"&gt;Literate
Programming&lt;/a&gt;. My fork of PyLit
(&lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt;) coupled with
&lt;a class="reference external" href="http://sphinx-doc.org/"&gt;Sphinx&lt;/a&gt; seems to handle LP programming in
a very elegant way.&lt;/p&gt;
&lt;p&gt;It works like this.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Write RST files describing the problem and the solution. This
includes the actual implementation code …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;I remain captivated by the ideals of &lt;a class="reference external" href="http://www.literateprogramming.com/"&gt;Literate
Programming&lt;/a&gt;. My fork of PyLit
(&lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt;) coupled with
&lt;a class="reference external" href="http://sphinx-doc.org/"&gt;Sphinx&lt;/a&gt; seems to handle LP programming in
a very elegant way.&lt;/p&gt;
&lt;p&gt;It works like this.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Write RST files describing the problem and the solution. This
includes the actual implementation code. And everything else that's
relevant.&lt;/li&gt;
&lt;li&gt;Run PyLit3 to build final Python code from the RST documentation.
This should include the setup.py so that it can be installed
properly.&lt;/li&gt;
&lt;li&gt;Run Sphinx to build pretty HTML pages (and LaTeX) from the RST
documentation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I often include the unit tests along with the sphinx build so that I'm
sure that things are working.&lt;/p&gt;
&lt;p&gt;The challenge is final presentation of the whole package.&lt;/p&gt;
&lt;p&gt;The HTML can be easy to publish, but it can't (trivially) be used to
recover the code. We have to upload two separate and distinct things.
(We could use BeautifulSoup to recover RST from HTML and then PyLit to
rebuild the code. But that sounds crazy.)&lt;/p&gt;
&lt;p&gt;The RST is easy to publish, but hard to read and it requires a pass
with PyLit to emit the code and then another pass with Sphinx to
produce the HTML. A single upload doesn't work well.&lt;/p&gt;
&lt;p&gt;If we publish only the Python code we've defeated the point of
literate programming. Even if we focus on the Python, we need to do a
separate upload of HTML to providing the supporting documentation.&lt;/p&gt;
&lt;p&gt;After working with this for a while, I've found that it's simplest to
have one source and several targets. I use RST ⇒ (.py, .html, .tex).
This encourages me to write documentation first. I often fail, and
have blocks of code with tiny summaries and non-existent explanations.&lt;/p&gt;
&lt;p&gt;PyLit allows one to use .py ⇒ .rst ⇒ .html, .tex. I've messed with
this a bit and don't like it as much. Code first leaves the
documentation as a kind of afterthought.&lt;/p&gt;
&lt;div class="section" id="how-can-we-publish-simply-and-cleanly-without-separate-uploads"&gt;
&lt;h2&gt;How can we publish simply and cleanly: without separate uploads?&lt;/h2&gt;
&lt;p&gt;Enter GitHub and &lt;a class="reference external" href="https://pages.github.com/"&gt;gh-pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See the
&amp;quot;&lt;a class="reference external" href="http://daler.github.io/sphinxdoc-test/index.html"&gt;sphinxdoc-test&lt;/a&gt;&amp;quot;
project for an example. Also this
&lt;a class="reference external" href="https://github.com/daler/sphinxdoc-test"&gt;https://github.com/daler/sphinxdoc-test&lt;/a&gt;. The bulk of this is useful
advice on a way to create the gh-pages branch from your RST source via
Sphinx and some GitHub commands.&lt;/p&gt;
&lt;p&gt;Following this line of thinking, we almost have the case for three
branches in a LP project.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The &amp;quot;master&amp;quot; branch with the RST source. And nothing more.&lt;/li&gt;
&lt;li&gt;The &amp;quot;code&amp;quot; branch with the generated Python code created by PyLit.&lt;/li&gt;
&lt;li&gt;The &amp;quot;gh-pages&amp;quot; branch with the generated HTML created by Sphinx.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I think I like this.&lt;/p&gt;
&lt;p&gt;We need three top-level directories. One has RST source. A build
script would run PyLit to populate the (separate) directory for the
code branch. The build script would also run Sphinx to populate a
third top-level directory for the gh-pages branch.&lt;/p&gt;
&lt;p&gt;The downside of this shows up when you need to create a branch for a
separate effort. You have a &amp;quot;some-major-change&amp;quot; branch to master.
Where's the code? Where's the doco? You don't want to commit either of
those derived work products until you merge the &amp;quot;some-major-change&amp;quot;
back into master.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="github-literate-programming"&gt;
&lt;h2&gt;GitHub Literate Programming&lt;/h2&gt;
&lt;p&gt;There are many LP projects on GitHub. There are perhaps a dozen which
focus on publishing with the Github-flavored Markdown as the source
language. Because Markdown is about as easy to parse as RST, the
tooling is simple. Because Markdown lacks semantic richness, I'm not
switching.&lt;/p&gt;
&lt;p&gt;I've found that semantically rich markup is essential. This is a key
feature of RST. It's carried forward by Sphinx to create very
sophisticated markup. Think &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:code:`sample`&lt;/span&gt;&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:py:func:`sample`&lt;/span&gt;&lt;/tt&gt; vs.
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:py:mod:`sample`&lt;/span&gt;&lt;/tt&gt; vs. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:py:exc:`sample`&lt;/span&gt;&lt;/tt&gt;. The final typesetting may be
similar, but they are clearly semantically distinct and create
separate index entries.&lt;/p&gt;
&lt;p&gt;A focus on Markdown seems to be a limitation. It's encouraging to see
folks experiment with literate programming using Markdown and GitHub.
Perhaps other folks will look at more sophisticated markup languages
like RST.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="previous-exercises"&gt;
&lt;h2&gt;Previous Exercises&lt;/h2&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://sourceforge.net/projects/stingrayreader/"&gt;https://sourceforge.net/projects/stingrayreader/&lt;/a&gt; for a seriously
large literate programming effort. The HTML is also hosted at
SourceForge: &lt;a class="reference external" href="http://stingrayreader.sourceforge.net/index.html"&gt;http://stingrayreader.sourceforge.net/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This project is awkward because -- well -- I have to do a separate FTP
upload of the finished pages after a change. It's done with a script,
not a simple &amp;quot;git push.&amp;quot; SourceForge has a GitHub
repository. &lt;a class="reference external" href="https://sourceforge.net/p/stingrayreader/code/ci/master/tree/"&gt;https://sourceforge.net/p/stingrayreader/code/ci/master/tree/&lt;/a&gt;.
But. SourceForge doesn't use  GitHub.com's UI, so it's not clear if it
supports the gh-pages feature. I assume it doesn't, but, maybe it
does. (I can't even login to SourceForge with Safari... I should
really stop using SourceForge and switch to GitHub.)&lt;/p&gt;
&lt;p&gt;See &lt;a class="reference external" href="https://github.com/slott56/HamCalc-2.1"&gt;https://github.com/slott56/HamCalc-2.1&lt;/a&gt; for another complex, LP
effort. This predates my dim understanding of the gh-pages branch, so
it's got HTML (in doc/build/html), but it doesn't show it elegantly.&lt;/p&gt;
&lt;p&gt;I'm still not sure this three-branch Literate Programming approach is
sensible. My first step should probably be to rearrange the
&lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;PyLit3&lt;/a&gt; project into this
three-branch structure.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="sphinx"></category><category term="#python"></category><category term="PyLit"></category><category term="github"></category><category term="stingray reader"></category></entry><entry><title>Literate Programming with pyWeb 2.3</title><link href="https://slott56.github.io/2014_04_24-literate_programming_with_pyweb_23.html" rel="alternate"></link><published>2014-04-24T08:00:00-04:00</published><updated>2014-04-24T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2014-04-24:/2014_04_24-literate_programming_with_pyweb_23.html</id><summary type="html">&lt;p&gt;Updates completed.
See &lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/"&gt;https://sourceforge.net/projects/pywebtool/&lt;/a&gt; and &lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;http://pywebtool.sourceforge.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The list of changes is extensive.&lt;/p&gt;
&lt;p&gt;However, the essential API and the markup language for creating
literate programs hasn't (significantly) changed. A few experimental
features were replaced with a first-class implementation.&lt;/p&gt;
&lt;p&gt;The interesting (to me) bit is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Updates completed.
See &lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/"&gt;https://sourceforge.net/projects/pywebtool/&lt;/a&gt; and &lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;http://pywebtool.sourceforge.net&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The list of changes is extensive.&lt;/p&gt;
&lt;p&gt;However, the essential API and the markup language for creating
literate programs hasn't (significantly) changed. A few experimental
features were replaced with a first-class implementation.&lt;/p&gt;
&lt;p&gt;The interesting (to me) bit is this sequence of events.&lt;/p&gt;
&lt;p&gt;I started out using &lt;a class="reference external" href="https://wiki.python.org/moin/LeoEditor"&gt;Leo&lt;/a&gt;
and &lt;a class="reference external" href="http://interscript.sourceforge.net/"&gt;Interscript&lt;/a&gt; as a
literate programming tools. They worked. But they were larger and
clunky and I wasn't happy.&lt;/p&gt;
&lt;p&gt;I wrote my own too, not &lt;strong&gt;really&lt;/strong&gt; getting the use cases.&lt;/p&gt;
&lt;p&gt;I found &lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;pyLit&lt;/a&gt; and liked it a
lot. For a long time, I liked it better than my own
&lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/"&gt;pyWeb&lt;/a&gt; tool.&lt;/p&gt;
&lt;p&gt;Then I ran across some problem domains for which pyLit didn't work out
well. It's not that I've abandoned pyLit, but I believe I'll focus
more on pyWeb.&lt;/p&gt;
&lt;div class="section" id="the-awkward-problem-domains"&gt;
&lt;h2&gt;The Awkward Problem Domains&lt;/h2&gt;
&lt;p&gt;Here are the two awkward problem domains.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Historical Story Lines&lt;/strong&gt;. In some cases, we want to describe a
module or package based on the path of exploration. Rather than
simply drop the design, we want to show the path followed which lead
to the design. This can be helpful for certain kinds of pedagogical
exercises where we're steering the reader through a process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Complex Packages that Don't Follow Python's Presentation Order&lt;/strong&gt;.
In some cases, we need to present things out of order. Python
constrains us to have docstring and imports first. Our class
definitions must proceed in &amp;quot;dependency&amp;quot; order. But this may not be
the best order for explanation. Sometimes, we want to start with the
&amp;quot;def main():&amp;quot; function first to explain &lt;strong&gt;why&lt;/strong&gt; a class looks the way
it does.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PyWeb handles these nicely.  One of the handiest things is this for
out-of-order presentation.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;d Some Class... &amp;#64;{

class TheClass:
    etc.
&amp;#64;}

This class uses the following imports

&amp;#64;d Imports...&amp;#64;{
import this
import that
&amp;#64;}
&lt;/pre&gt;
&lt;p&gt;We can then scatter imports through the documentation in the relevant
places. And they &lt;strong&gt;follow&lt;/strong&gt; the more interesting material.&lt;/p&gt;
&lt;p&gt;When it comes to final assembly, we have this.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;o some_module.py &amp;#64;{
    &amp;#64;&amp;lt;Imports for this module&amp;#64;&amp;gt;
    &amp;#64;&amp;lt;Some Class that does the real work of this module&amp;#64;&amp;gt;
&amp;#64;}
&lt;/pre&gt;
&lt;p&gt;This builds the module, tangling the imports into one cluster up
front, and putting the class definition later.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="pyWeb"></category></entry><entry><title>Literate Programming: PyLit3</title><link href="https://slott56.github.io/2013_10_15-literate_programming_pylit3.html" rel="alternate"></link><published>2013-10-15T08:00:00-04:00</published><updated>2013-10-15T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2013-10-15:/2013_10_15-literate_programming_pylit3.html</id><summary type="html">&lt;p&gt;I've revised PyLit to work with Python3.
See &lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt;
The code seems to pass all the unit tests.
The changes include Python3 revisions, plus a small change to handle
trailing spaces in a sightly cleaner fashion. This was necessary because
I have most of my editors …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've revised PyLit to work with Python3.
See &lt;a class="reference external" href="https://github.com/slott56/PyLit-3"&gt;https://github.com/slott56/PyLit-3&lt;/a&gt;
The code seems to pass all the unit tests.
The changes include Python3 revisions, plus a small change to handle
trailing spaces in a sightly cleaner fashion. This was necessary because
I have most of my editors set to remove trailing spaces from the files I
create, and PyLit tended to create trailing spaces. This made the
expected output from the unit tests not precisely match the actual
output.&lt;/p&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="PyLit"></category></entry><entry><title>Literate Programming and PyLit</title><link href="https://slott56.github.io/2013_10_03-literate_programming_and_pylit.html" rel="alternate"></link><published>2013-10-03T08:00:00-04:00</published><updated>2013-10-03T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2013-10-03:/2013_10_03-literate_programming_and_pylit.html</id><summary type="html">&lt;p&gt;Even though I wrote a literate programming tool
(&lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;PyWeb&lt;/a&gt;) I slowly came to
realize that it's not very good.&lt;/p&gt;
&lt;p&gt;Mostly, I followed the Web/Weave world view and cribbed their markup
syntax. It's not bad, but, the PyWeb markup is based on some
presumptions about literate programming that were, perhaps …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Even though I wrote a literate programming tool
(&lt;a class="reference external" href="http://pywebtool.sourceforge.net/"&gt;PyWeb&lt;/a&gt;) I slowly came to
realize that it's not very good.&lt;/p&gt;
&lt;p&gt;Mostly, I followed the Web/Weave world view and cribbed their markup
syntax. It's not bad, but, the PyWeb markup is based on some
presumptions about literate programming that were, perhaps, true with
some languages, but are not true at all when working with Python.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;The source presentation order incomprehensible. To fix this, we
create a literate programming document, and from that tangle the
source into an order that's acceptable to the compiler, but perhaps
hard to understand for people. We weave a document that's easy for
people to understand.&lt;/li&gt;
&lt;li&gt;The source syntax may be incomprehensible. To fix this, we have fine
grained substitution. The target source can be built at any level of
syntax (token, line, or higher-level language construct.) We can
assure that the woven document for people is written using elegant
symbols even if the tangled source code uses technical gibberish.&lt;/li&gt;
&lt;li&gt;The woven documentation needs a lot of additional output markup. The
original web/weave toolset create extensive TeX markup. Later tools
reduced the markup to allow HTML or XML, minimizing the added markup
in a woven document.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In Python, there's very little &amp;quot;boilerplate&amp;quot; or overhead in a module
file. Also, because of very late binding, the presentation order of
the source can better match reader expectations. For definitions,
inter-class references mandate an order for the class statements in
an inheritance hierarchy, but almost everything else is remarkably
flexible.&lt;/p&gt;
&lt;p&gt;Python syntax doesn't benefit from fine-grained web/weave techniques.
It's pretty clear as written in it's normal form.&lt;/p&gt;
&lt;p&gt;Finally, the presence of &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;RST
markup&lt;/a&gt; language means
that a whole new meta-markup for literate programming isn't
&lt;strong&gt;necessary&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pypi.python.org/pypi/pylit"&gt;PyLit&lt;/a&gt; demonstrates that an
additional markup language is not helpful. RST is sufficient. PyLit
is an elegant parser of RST and Python. It can reshape RST into
Python as well as reshape Python into RST. Do your literate
programming in either language and produce the other easily.&lt;/p&gt;
&lt;div class="section" id="enter-python-3"&gt;
&lt;h2&gt;Enter Python 3&lt;/h2&gt;
&lt;p&gt;The problem with PyLit is that it's oriented to Python 2.4 through
2.7. How can we use PyLit for Python 3?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use six.py to make a single version that covers both Python2 and Python3.&lt;/li&gt;
&lt;li&gt;Rewrite PyLit it for Python3 and move forward.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My preference is to move forward. The backward compatibility is
helpful when there's a vast user base, lots of ongoing
development, and the very real possibility of bug fixes that apply
to Python2 as well as Python3.&lt;/p&gt;
&lt;p&gt;PyLit has a small user base, no real development to speak of, and a
very remote possibility of backward compatible bug fixes.&lt;/p&gt;
&lt;p&gt;The rewrites are small. Here's the summary.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remove print statement and exec statements.&lt;/li&gt;
&lt;li&gt;Replace string formatting % with .format().&lt;/li&gt;
&lt;li&gt;Replace raise statements and except statements with Python3 (and Python2.7) syntax.&lt;/li&gt;
&lt;li&gt;Upgrade for dict method changes in Python3.&lt;/li&gt;
&lt;li&gt;Replace DefaultDict with collections.defaultdict.&lt;/li&gt;
&lt;li&gt;Replace optparse with argparse.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I've done this in my Python3.2 installation.&lt;/p&gt;
&lt;p&gt;This doesn't address the Sphinx documentation, however, which should
probably be tweaked to be the latest and greatest Sphinx version,
also. Not much will change, there, however, since the RST remains
compatible.&lt;/p&gt;
&lt;p&gt;Also, it doesn't address the files with names that differ only in
case. There are two graphics files in the /trunk/rstdocs/logo/ path
that differ only in &lt;strong&gt;case&lt;/strong&gt; of letters. Bad, but acceptable for
Linux. Fatal for Mac OS X with the default filesystem.&lt;/p&gt;
&lt;p&gt;The question is, what's the polite way to proceed?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Fork the PyLit 0.7.5 to create PyLit3 release 1.0? A whole, new project.&lt;/li&gt;
&lt;li&gt;Try to use six.py to create a 2-3 compatible source file and call this PyLit 0.8?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Adding six.py to a package that was a single module file seems
like a bit of overkill. One of the elegant features of PyLit was
that it was so simple, it didn't even have a setup.py. However,
there may be a community of staunchly Python2 literate programming
advocates.&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="PyLit"></category><category term="pyWeb"></category></entry><entry><title>pyWeb Literate Programming Tool | Download pyWeb Literate Programming Tool software for free at SourceForge.net</title><link href="https://slott56.github.io/2010_12_30-pyweb_literate_programming_tool_download_pyweb_literate_programming_tool_software_for_free_at_sourceforgenet.html" rel="alternate"></link><published>2010-12-30T13:31:00-05:00</published><updated>2010-12-30T13:31:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2010-12-30:/2010_12_30-pyweb_literate_programming_tool_download_pyweb_literate_programming_tool_software_for_free_at_sourceforgenet.html</id><summary type="html">&lt;p&gt;I've (finally) updated the pyWeb Literate Programming Tool.&lt;/p&gt;
&lt;p&gt;There were feature requests and bug reports. Much to do. Sadly, I'm
really slow at doing it.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/?sms_ss=blogger&amp;amp;at_xt=4d1ccf8b638ad5eb%2C0"&gt;pyWeb Literate Programming Tool | Download pyWeb Literate
Programming Tool software for free at
SourceForge.net&lt;/a&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="pyweb-patch-for-c"&gt;
&lt;h2&gt;pyweb-patch-for-c&lt;/h2&gt;
&lt;p&gt;Anonymous&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2011-02-01 02:31:48.402000-05 …&lt;/p&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;I've (finally) updated the pyWeb Literate Programming Tool.&lt;/p&gt;
&lt;p&gt;There were feature requests and bug reports. Much to do. Sadly, I'm
really slow at doing it.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/?sms_ss=blogger&amp;amp;at_xt=4d1ccf8b638ad5eb%2C0"&gt;pyWeb Literate Programming Tool | Download pyWeb Literate
Programming Tool software for free at
SourceForge.net&lt;/a&gt;&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="pyweb-patch-for-c"&gt;
&lt;h2&gt;pyweb-patch-for-c&lt;/h2&gt;
&lt;p&gt;Anonymous&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2011-02-01 02:31:48.402000-05:00&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://itpith.blogspot.com/2011/01/pyweb-patch-for-c.html"&gt;http://itpith.blogspot.com/2011/01/pyweb-patch-for-c.html&lt;/a&gt;
little (limited) workaround&lt;/p&gt;
&lt;p&gt;Excellent tool!! Thanks a lot!
But can you help me...
-----------------------------------------------------&lt;/p&gt;
&lt;p&gt;Anonymous&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2011-01-29 10:57:10.919000-05:00&lt;/p&gt;
&lt;p&gt;Excellent tool!! Thanks a lot!
But can you help me with one little problem? I want to use it with
C/C++, a special with C-macros which is ended with '\' (backslash). So,
if I use '\' - I get in doc chunk in ONE line, in .H file all is good.
If I use '\\' (2 backslashes), doc looks good but I get in .H file two
ending ('\\').
How to use the tool for C-macros?&lt;/p&gt;
&lt;/div&gt;
</content><category term="literate programming"></category><category term="#python"></category><category term="pyWeb"></category></entry><entry><title>Fancy Literate Programming</title><link href="https://slott56.github.io/2010_04_07-fancy_literate_programming.html" rel="alternate"></link><published>2010-04-07T08:00:00-04:00</published><updated>2010-04-07T08:00:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2010-04-07:/2010_04_07-fancy_literate_programming.html</id><summary type="html">&lt;p&gt;My bias is toward &amp;quot;printable&amp;quot; documents. I like the idea of an HTML
document that is directly printable. I've used tools like &lt;a class="reference external" href="https://xhtmlrenderer.dev.java.net/"&gt;Flying
Saucer&lt;/a&gt; (and appropriate CSS) to
guarantee printability.&lt;/p&gt;
&lt;p&gt;I like using &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReStructured Text&lt;/a&gt; to create HTML
and LaTeX that match precisely.&lt;/p&gt;
&lt;p&gt;When I think of Literate Programming, I'm …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My bias is toward &amp;quot;printable&amp;quot; documents. I like the idea of an HTML
document that is directly printable. I've used tools like &lt;a class="reference external" href="https://xhtmlrenderer.dev.java.net/"&gt;Flying
Saucer&lt;/a&gt; (and appropriate CSS) to
guarantee printability.&lt;/p&gt;
&lt;p&gt;I like using &lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;ReStructured Text&lt;/a&gt; to create HTML
and LaTeX that match precisely.&lt;/p&gt;
&lt;p&gt;When I think of Literate Programming, I'm biased toward print.&lt;/p&gt;
&lt;p&gt;However, HTML has a lot of power. Taking off the blinkers for a
moment, one can see that rich HTML and Javascript may be a really
workable approach.&lt;/p&gt;
&lt;p&gt;Take a look at the &lt;a class="reference external" href="http://literate-molly.sourceforge.net/"&gt;Literate Molly Module&lt;/a&gt;: another
tool for Literate Programming. This is an example of using rich
HTML as a vehicle for literate programming.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="software-architect-s-key-responsibility-areas"&gt;
&lt;h2&gt;Software Architect's Key Responsibility Areas(...&lt;/h2&gt;
&lt;p&gt;Prashant S Akerkar&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-04-29 06:28:23.075000-04:00&lt;/p&gt;
&lt;p&gt;Software Architect's Key Responsibility Areas(KRA)
1.Identifying Business Needs.
2.Designing - High and Low Level Designs.
3.Creating Prototyping Model.
4.Possess Excellent Functional Domain Knowledge.
5.Identifying Technology,API,Framework viz Open Source, Microsoft, Sun
Microsystems for the solution
6.Identifying SDLC Model viz Waterfall,Iterative,Agile for Project
Execution
7.Write System Test Cases
8.Adhering to Quality Processes Standards for Software Products
Development.
Thanks &amp;amp; Regards,
Prashant S Akerkar
&lt;a class="reference external" href="http://www.linkedin.com/in/prashantakerkar"&gt;http://www.linkedin.com/in/prashantakerkar&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</content><category term="Literate Programming"></category><category term="restructured text"></category><category term="rst"></category></entry><entry><title>Literate Programming</title><link href="https://slott56.github.io/2010_03_14-literate_programming.html" rel="alternate"></link><published>2010-03-14T12:02:00-04:00</published><updated>2010-03-14T12:02:00-04:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2010-03-14:/2010_03_14-literate_programming.html</id><summary type="html">&lt;p&gt;About a decade ago, I discovered the concept of Literate Programming.
It's seductive. The idea is to write elegant documentation that embeds
the actual working code.&lt;/p&gt;
&lt;p&gt;For tricky, complex, high-visibility components, a literate
programming approach can give people confidence that the software
actually works as advertised.&lt;/p&gt;
&lt;p&gt;I actually wrote my …&lt;/p&gt;</summary><content type="html">&lt;p&gt;About a decade ago, I discovered the concept of Literate Programming.
It's seductive. The idea is to write elegant documentation that embeds
the actual working code.&lt;/p&gt;
&lt;p&gt;For tricky, complex, high-visibility components, a literate
programming approach can give people confidence that the software
actually works as advertised.&lt;/p&gt;
&lt;p&gt;I actually wrote my own Literate Programming tool. Amazingly, someone
actually cared deeply enough to send me a patch to fix some
long-standing errors in the LaTeX output. What do I do with a patch
kit?&lt;/p&gt;
&lt;div class="section" id="forward-and-reverse-lp"&gt;
&lt;h2&gt;Forward and Reverse LP&lt;/h2&gt;
&lt;p&gt;There are two schools of literate programming: Forward and Reverse.
Forward literate programming starts with a source text and generates
the documentation plus the source code files required by the
compilers or interpreters.&lt;/p&gt;
&lt;p&gt;Reverse literate programming generates documentation from the source
files. Tools like &lt;a class="reference external" href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; do this very
nicely. With a little bit of work, one can create a documentation
tree with uses Sphinx's
&lt;a class="reference external" href="http://sphinx.pocoo.org/ext/autodoc.html"&gt;autodoc&lt;/a&gt; extension to
create great documentation from the source.&lt;/p&gt;
&lt;p&gt;Reverse LP, however, tends to focus on the API's of the code &lt;em&gt;as
written&lt;/em&gt;. Sometimes it's hard to figure out why it's written that way
without further, deeper explanation. And keeping a separate
documentation tree in Sphinx means that the code and the
documentation can disagree.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="my-pyweb-tool"&gt;
&lt;h2&gt;My pyWeb Tool&lt;/h2&gt;
&lt;p&gt;The gold standard in Literate Programming is Knuth's Web. This is
available as
&lt;a class="reference external" href="http://www.literateprogramming.com/cweb_download.html"&gt;CWEB&lt;/a&gt;
which generates TeX output. It's quite sophisticated, allowing very
rich markup and formatting of the code.&lt;/p&gt;
&lt;p&gt;There are numerous imitators, each less and less sophisticated. When
you get to &lt;a class="reference external" href="http://nuweb.sourceforge.net/"&gt;nuweb&lt;/a&gt; and
&lt;a class="reference external" href="http://www.cs.tufts.edu/~nr/noweb/"&gt;noweb&lt;/a&gt;, you're getting down
to the bare bones of what the core use cases are.&lt;/p&gt;
&lt;p&gt;For reasons I can't recall, I wrote one, too. I wrote (and used)
pyWeb for a few small projects. I posted some code as an experiment
on the Zope site, since I was a Zope user for a while. I went to move
it and got emails from a couple of folks who are serious Literate
Programmers and where concerned when their links broke. Cool.&lt;/p&gt;
&lt;p&gt;I moved the code to my own personal site, where it sat between 2002
and today. It was hard-to-find; but there are some hard-core Literate
Programmers who are willing to chase down tools and play with them to
see how they work at producing elegant, readable code. Way cool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="patch-kit"&gt;
&lt;h2&gt;Patch Kit&lt;/h2&gt;
&lt;p&gt;Recently, I received a patch kit for pyWeb. This says several things.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;It's at least good enough that folks can use it and find the
errors in the LaTeX markup it produced&lt;/li&gt;
&lt;li&gt;Some folks care enough about good software to help correct the
errors.&lt;/li&gt;
&lt;li&gt;Hosting it on my personal web site is a bad idea.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, I created a SourceForge project, &lt;a class="reference external" href="https://sourceforge.net/projects/pywebtool/"&gt;pyWeb Literate Programming
Tool&lt;/a&gt;, to make it
easier for folks to find and correct any problems.&lt;/p&gt;
&lt;p&gt;I expect the number of downloads to hover right around zero
forever. But at least it's now fixable by someone other than me.&lt;/p&gt;
&lt;/div&gt;
&lt;hr class="docutils" /&gt;
&lt;div class="section" id="regarding-leo-it-has-advanced-by-leaps-and-bound"&gt;
&lt;h2&gt;Regarding Leo - it has advanced by leaps and bound...&lt;/h2&gt;
&lt;p&gt;Ville&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-03-14 16:24:11.895000-04:00&lt;/p&gt;
&lt;p&gt;Regarding Leo - it has advanced by leaps and bounds lately, including a
new fast (and good-looking!) Qt ui, simplified reST authoring, Python 3
support...&lt;/p&gt;
&lt;p&gt;It's actually quite an exciting project, even if you were not into LP at
all.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="do-you-know-leo"&gt;
&lt;h2&gt;Do you know Leo ?&lt;/h2&gt;
&lt;p&gt;luigi_scarso&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-03-04 14:03:27.855000-05:00&lt;/p&gt;
&lt;p&gt;Do you know Leo ?
&lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;http://webpages.charter.net/edreamleo/front.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hi Steven,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="i-ve-sent-you-a-patch-to-pyweb-2-1"&gt;
&lt;h2&gt;I've sent you a patch to pyWeb 2.1...&lt;/h2&gt;
&lt;p&gt;Unknown&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-06-18 02:59:21.054000-04:00&lt;/p&gt;
&lt;p&gt;Hi Steven,&lt;/p&gt;
&lt;p&gt;I've sent you a patch to pyWeb 2.1 related to RST generation yesterday
to s_lott at yahoo.com&lt;/p&gt;
&lt;p&gt;Duplicating this info here to make sure it wouldn't lost.&lt;/p&gt;
&lt;p&gt;Best regards,
Egor&lt;/p&gt;
&lt;p&gt;Hi Steven,&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="another-patch-for-pyweb-2-1-related-to"&gt;
&lt;h2&gt;Another patch for pyWeb 2.1 related to...&lt;/h2&gt;
&lt;p&gt;Unknown&amp;lt;&lt;a class="reference external" href="mailto:noreply&amp;#64;blogger.com"&gt;noreply&amp;#64;blogger.com&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;2010-08-02 12:17:54.267000-04:00&lt;/p&gt;
&lt;p&gt;Hi Steven,&lt;/p&gt;
&lt;p&gt;Another patch for pyWeb 2.1 related to RST generation was sent to s_lott
at yahoo.com&lt;/p&gt;
&lt;p&gt;Best regards,&lt;/p&gt;
&lt;p&gt;Egor&lt;/p&gt;
&lt;/div&gt;
</content><category term="Literate Programming"></category><category term="open source"></category><category term="#python"></category></entry><entry><title>Editing DocBook XML</title><link href="https://slott56.github.io/2007_02_02-editing_docbook_xml.html" rel="alternate"></link><published>2007-02-02T12:03:00-05:00</published><updated>2007-02-02T12:03:00-05:00</updated><author><name>S.Lott</name></author><id>tag:slott56.github.io,2007-02-02:/2007_02_02-editing_docbook_xml.html</id><summary type="html">&lt;p&gt;First, I wrote a book on &lt;a class="reference external" href="http://www.itmaybeahack.com/homepage/books/python.html"&gt;Programming with Python&lt;/a&gt;.
It was back in the Python 2.0 days (2001 or thereabouts.)  I used &lt;a class="reference external" href="http://www.apple.com/appleworks/"&gt;AppleWorks&lt;/a&gt;,
and it was fun.  Write all you want,
put in formulae, code samples, everything.  A few style sheets to give it a
reasonable look and I …&lt;/p&gt;</summary><content type="html">&lt;p&gt;First, I wrote a book on &lt;a class="reference external" href="http://www.itmaybeahack.com/homepage/books/python.html"&gt;Programming with Python&lt;/a&gt;.
It was back in the Python 2.0 days (2001 or thereabouts.)  I used &lt;a class="reference external" href="http://www.apple.com/appleworks/"&gt;AppleWorks&lt;/a&gt;,
and it was fun.  Write all you want,
put in formulae, code samples, everything.  A few style sheets to give it a
reasonable look and I was happy with it.  There's no market for a book on
Python, but it was more a book about programming than about Python.  There's
even less of a market for that.&lt;/p&gt;
&lt;p&gt;There may be no market for a book on programming, but I teach programming.  I've
taught programming in C, Ada, Java, PL/SQL, COBOL and Python.  So, I have a
pretty standard approach to programming, into which I plug the language.  It
works very well, and capturing the approach in a book was
helpful.&lt;/p&gt;
&lt;p&gt;Then I re-discovered DocBook markup.  I say rediscovered because in the mid-90's, I learned SGML, and was
aware of DocBook.  I'd ignored it partly because there wasn't any affordable
tooling, but also because SGML is a pain in the ass to write.  SGML isn't as
painful as XML, but the differences are microscopic when compared with WYSIWYG
AppleWorks.&lt;/p&gt;
&lt;div class="section" id="enter-leo"&gt;
&lt;h2&gt;Enter LEO&lt;/h2&gt;
&lt;p&gt;Meanwhile, as part of
developing a second book on &lt;a class="reference external" href="http://www.itmaybeahack.com/homepage/books/oodesign.html"&gt;Object-Oriented Design&lt;/a&gt; , I made serious use of
Literate Programming (LP).  I tried a number of tools, discarding many of them
as inappropriate for OO programming.  Many LP tools carry too much of the
original Web/Weave technology forward and provide too-complex macro
pre-processing features.  I found some minimalist tools (like &lt;a class="reference external" href="http://www.literateprogramming.com/tools.html"&gt;nuweb
and noweb&lt;/a&gt; ) and wrote my own pyWeb, which was even
simpler.&lt;/p&gt;
&lt;p&gt;But a pyWeb/HTML document is
still a pain to produce because of the flatness of the source file.  I want an
editor that respects my outline, and I was creating documents that were
essentially flat text.  Yes, they would become HTML, which (because of
&lt;tt class="docutils literal"&gt;&amp;lt;h&lt;/tt&gt;&lt;em&gt;x&lt;/em&gt;&lt;tt class="docutils literal"&gt;&amp;gt;&lt;/tt&gt; tags) reflects an outline.  But I wasn't able to use an outliner successfully to
create them.  Once it got respectably big, editing the pyWeb/HTML wasn't all
that easy and didn't provide any real intellectual
leverage.&lt;/p&gt;
&lt;p&gt;Then I hit on using &lt;a class="reference external" href="http://webpages.charter.net/edreamleo/front.html"&gt;LEO&lt;/a&gt;  to create pyWeb documents.  Which, after a
little experimentation, proved to be kind of silly.  LEO's RST module makes
emitting a pyWeb document redundant.  LEO can, with some care, emit a
nice-looking HTML document as well as the needed code files.  There's a bit of
jockeying around required to allow the author to mix and match non-code
documentation with code blocks, but it can be made to work.  LEO replaced the
pyWeb file rather than helping to build
it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="docbook-is-code"&gt;
&lt;h2&gt;DocBook is Code&lt;/h2&gt;
&lt;p&gt;While using LEO to produce
pyWeb is silly, using LEO to produce a complex DocBook project is much more
sensible.  The exact features of LEO that let it produce complex code projects
helped me produce complex writing projects.  Indeed, the presence of the
outliner made writing something as complex as a programming book
possible.&lt;/p&gt;
&lt;p&gt;Outliners introduce their own
problems, but it was a huge intellectual lever.  I could produce a DocBook 3.1
XML file, run the Xalan-based &lt;a class="reference external" href="http://docbook.sourceforge.net/"&gt;DocBook XSL&lt;/a&gt;  transformations
(version 1.66, later 1.68) to create HTML and FO, and use &lt;a class="reference external" href="http://xmlgraphics.apache.org/fop/"&gt;Apache
FOP&lt;/a&gt;  to produce PDF.  It was
marvelous.&lt;/p&gt;
&lt;p&gt;The problem that an outliner
introduces is the Deep Digression problem.  You can open another level of the
outline, presuming that the nested context is useful and helpful.  It turns out
that it isn't.  You think of it as depth when you start: your reader sees it as
an incomprehensible digression.  Other than legal documents and software, most
things must be relatively flat and rely on a narrative arc and explicit
signposts along the way.  An outline more than a few levels deep is uselessly
baffling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="docbook-5"&gt;
&lt;h2&gt;DocBook 5&lt;/h2&gt;
&lt;p&gt;DocBook hasn't stood still since
the 3.1 days.   Indeed, 3.1 didn't properly achieve standard status; 4.1 and 4.5
were accepted by &lt;a class="reference external" href="http://www.oasis-open.org"&gt;OASIS&lt;/a&gt;  as standards.  However, I stuck with my
3.1 technology stack because I'd customized my stylesheets to handle Python
correctly, and didn't want to migrate those changes into version 1.72 of the
XSL.&lt;/p&gt;
&lt;p&gt;However, there are now some XML
editing solutions that look far nicer than my LEO-based technology stack.  The
&lt;a class="reference external" href="http://www.docbook.org/docs/howto/"&gt;DocBook 5.0 Transition Guide&lt;/a&gt;  was enlightening.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.gnu.org/software/emacs/emacs.html"&gt;GNU Emacs&lt;/a&gt;  and
the &lt;a class="reference external" href="http://www.thaiopensource.com/nxml-mode/"&gt;nXML mode&lt;/a&gt;  add-on.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.oxygenxml.com/"&gt;oXygen&lt;/a&gt;  provides an XML editor that recognizes
and exploits the DocBook schema.&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.xmlmind.com/xmleditor/"&gt;XMLMind XML Editor&lt;/a&gt;  (XXE) also works
nicely.  The standard edition is free, and
produces files which go through my Xalan technology stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far, the XXE solution is marvelous.&lt;/p&gt;
&lt;/div&gt;
</content><category term="Literate Programming"></category><category term="books"></category><category term="docbook"></category><category term="xml"></category></entry></feed>